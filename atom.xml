<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个老程序猿</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zydeveloper.com/"/>
  <updated>2020-03-21T14:03:35.635Z</updated>
  <id>http://www.zydeveloper.com/</id>
  
  <author>
    <name>Zhangyue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler原理及源码分析（上）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/handlersource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/handlersource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:03:35.635Z</updated>
    
    <content type="html"><![CDATA[<p>Handler原理及源码分析（上）</p><a id="more"></a><h3 id="Handler原理及源码分析（上）"><a href="#Handler原理及源码分析（上）" class="headerlink" title="Handler原理及源码分析（上）"></a>Handler原理及源码分析（上）</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>如下是演示Demo，后续我将使用这个Demo来对Handler进行原理分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">btnHandlerDemoDo.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动了子线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//模拟耗时操作 睡了2s</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建Message对象</span></span><br><span class="line">Message message=Message.obtain();<span class="comment">//new Message();</span></span><br><span class="line">message.what=DemoFlag1;</span><br><span class="line">message.arg1=<span class="number">11</span>;</span><br><span class="line">message.arg2=<span class="number">22</span>;</span><br><span class="line">message.obj=<span class="keyword">new</span> Object();<span class="comment">// message.sendToTarget();</span></span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"threadname: "</span>+Thread.currentThread().getName());</span><br><span class="line"><span class="comment">//使用Handler发送Message</span></span><br><span class="line">mHandler.sendMessage(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DemoFlag1=<span class="number">1</span>;<span class="keyword">private</span> Handler mHandler=<span class="keyword">new</span> Handler()&#123;</span><br><span class="line"><span class="comment">//处理发送过来Message</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"><span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line"><span class="keyword">case</span> DemoFlag1:</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"handleMessage: [DemoFlag1]"</span>);</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"hm thread name: "</span>+Thread.currentThread().getName());</span><br><span class="line">tvHandlerDemoContent.setText(<span class="string">"handleMessage: [DemoFlag1]"</span>);</span><br><span class="line"><span class="comment">//tvHandlerDemoContent.setVisibility(View.VISIBLE);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><p>如上Demo代码演示了一个Handler很经典的使用场景，子线程发请求响应结果来更新UI。<br>然后下面我们先来关注两个问题：</p><h4 id="子线程中能否创建Handler？"><a href="#子线程中能否创建Handler？" class="headerlink" title="子线程中能否创建Handler？"></a>子线程中能否创建Handler？</h4><p>答案是肯定的，一定可以创建不过需要一个先决条件-&gt;指定Looper，下面示例代码演示了具体实现过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该位置我们指定了LooperLooper.prepare();Handler handler=new Handler()&#123;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"><span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"handleMessage: 00000"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line">handler.sendEmptyMessage(<span class="number">0</span>);Looper.loop();</span><br></pre></td></tr></table></figure><h4 id="主线程Handler为什么不用Looper-prepare"><a href="#主线程Handler为什么不用Looper-prepare" class="headerlink" title="主线程Handler为什么不用Looper.prepare()?"></a>主线程Handler为什么不用Looper.prepare()?</h4><p>这个问题我们就要分析一下Android源码，其中大家都知道ActivityThread（后面简称AT）是我们的“主线程”，其实AT并不是一个真实的线程，它只是一个final的class并没有继承或者实现任何与线程相关的类或接口。<br>之所以称它为主线程可能是因为这个类似android中唯一使用main函数加载启动并且是zygote fock完进程之后就直接加载的类。<br>下面我们来看一下具体的main函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">//出现了Looper.prepare</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line"><span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line"><span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line"><span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">startSeq = Long.parseLong(</span><br><span class="line">args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//Looper.loop</span></span><br><span class="line">Looper.loop();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可见我们在ActivityThread的main函数中发现了Looper已经关联好了，具体见如上注释部分。</p><p>我们都知道Handler一般是由4部分组成：<br>1 Message<br>2 MessageQueue<br>3 Looper<br>4 Handler</p><h4 id="首先我们来看看Message"><a href="#首先我们来看看Message" class="headerlink" title="首先我们来看看Message"></a>首先我们来看看Message</h4><p>如下是Message类的定义 很简单 final 实现 Parcelable序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* User-defined message code so that the recipient can identify</span></span><br><span class="line"><span class="comment">* what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment">* for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment">* with other handlers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">* few integer values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">* few integer values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An arbitrary object to send to the recipient. When using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Messenger&#125; to send the message across processes this can only</span></span><br><span class="line"><span class="comment">* be non-null if it contains a Parcelable of a framework class (not one</span></span><br><span class="line"><span class="comment">* implemented by the application). For other data transfer use</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that Parcelable objects here are not supported prior to</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#FROYO&#125; release.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br></pre></td></tr></table></figure><p>如上这几个属性是我们使用Message时比较常用的，很简单这边就不再解释。<br><img src="/2020/03/21/handlersource1/2020-03-21-22-01-31.png"><br>如上我们看到的是Message的obtain方法各种重载。下面来看看obtain（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">Message m = sPool;</span><br><span class="line">sPool = m.next;</span><br><span class="line">m.next = <span class="keyword">null</span>;</span><br><span class="line">m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法可以看出obtain是对Message的一个复用，即先看sPool中是否存在如果存在则复用，否则new一个Message实例返回。<br>其他的方法重载就是一些属性赋值操作这里不再阐述。</p><h5 id="下面来看看Message的target属性同时关注一些message的sendToTarget（）方法"><a href="#下面来看看Message的target属性同时关注一些message的sendToTarget（）方法" class="headerlink" title="下面来看看Message的target属性同时关注一些message的sendToTarget（）方法"></a>下面来看看Message的target属性同时关注一些message的sendToTarget（）方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br></pre></td></tr></table></figure><p>如上市target的定义，我们发现其实target是一个Handler，这个Handler可以通过如下方法进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;</span><br><span class="line">Message m = obtain();</span><br><span class="line">...</span><br><span class="line">m.target = orig.target;</span><br><span class="line">m.callback = orig.callback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line"><span class="comment">//以及obtain的其他方法重载，具体可以参加源码部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看message的sendToTarget方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span></span><br><span class="line"><span class="comment">* Throws a null pointer exception if this field has not been set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">target.sendMessage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最终调用的还是Handler的sendMessage方法（因为target就是Hander对象）。</p><h5 id="Message中还有data与callback属性"><a href="#Message中还有data与callback属性" class="headerlink" title="Message中还有data与callback属性"></a>Message中还有data与callback属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> Bundle data;<span class="comment">/*package*/</span> Runnable callback;</span><br></pre></td></tr></table></figure><p>我们发现data是Bundle类型，其中可以putXX数据。<br>callback在Message中进行了赋值也就是“setCallback”。</p><h5 id="下面我们来看看Message的复用是怎么处理的"><a href="#下面我们来看看Message的复用是怎么处理的" class="headerlink" title="下面我们来看看Message的复用是怎么处理的"></a>下面我们来看看Message的复用是怎么处理的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//提供给我们同步关键字使用的锁对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//缓存对象池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="comment">//当前对象池中的计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对象池最大缓存大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>如上属性是对Message的复用做设置的，具体使用我们来看一下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="comment">//首先判断sPool是否为空</span></span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//不为空将sPool赋值给m</span></span><br><span class="line">Message m = sPool;</span><br><span class="line"><span class="comment">//将m（也就是之前的sPool）的next对象给sPool</span></span><br><span class="line">sPool = m.next;</span><br><span class="line"><span class="comment">//将next清空</span></span><br><span class="line">m.next = <span class="keyword">null</span>;</span><br><span class="line">m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line"><span class="comment">//计数器减1</span></span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="comment">//返回复用的对象</span></span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果sPool为空则创建新Message对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现上面的sPool与next，但它们是在哪里赋值的呢？<br>我们可以参见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a Message instance to the global pool.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* You MUST NOT touch the Message after calling this function because it has</span></span><br><span class="line"><span class="comment">* effectively been freed. It is an error to recycle a message that is currently</span></span><br><span class="line"><span class="comment">* enqueued or that is in the process of being delivered to a Handler.</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment">* Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line"><span class="comment">// Clear out all other details.</span></span><br><span class="line"><span class="comment">//如下代码对Message的属性进行了还原即释放</span></span><br><span class="line">flags = FLAG_IN_USE;</span><br><span class="line">what = <span class="number">0</span>;</span><br><span class="line">arg1 = <span class="number">0</span>;</span><br><span class="line">arg2 = <span class="number">0</span>;</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">replyTo = <span class="keyword">null</span>;</span><br><span class="line">sendingUid = -<span class="number">1</span>;</span><br><span class="line">when = <span class="number">0</span>;</span><br><span class="line">target = <span class="keyword">null</span>;</span><br><span class="line">callback = <span class="keyword">null</span>;</span><br><span class="line">data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="comment">//判断当前计数器值是否大于限定的MAX_POOL_SIZE（也就是上面代码定义的50）</span></span><br><span class="line"><span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line"><span class="comment">//将sPool赋值给next</span></span><br><span class="line">next = sPool;</span><br><span class="line"><span class="comment">//将当前Message对象赋值给sPool</span></span><br><span class="line">sPool = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//计数器累加1</span></span><br><span class="line">sPoolSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现recycle（该方法调用时机我们后续再看）也就是释放方法中调用了recycleUnchecked方法，该方法对sPool sPoolSize next进行了处理，具体参见注释信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler原理及源码分析（上）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的原理及源码分析（上）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:39:51.340Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp的原理及源码分析（上）</p><a id="more"></a><p>注：我们的OkHttp源码分析是在3.12.0版本</p><p>如下是OkHttp的流程图（来源于网络）<br><img src="okhttpsource1/2020-03-21-21-35-41.png"></p><p>如下是我们经常使用的OkHttp的使用场景或者方法，下面我们用一个简单Get请求连进一步分析Okhttp的原理以及源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建OkHttpClient的实体对象  </span></span><br><span class="line"><span class="comment">//OkHttp给我提供两种创建OkHttpClient对象的方法</span></span><br><span class="line"><span class="comment">//一种是使用Builder.build（）典型建造者方式，可以不断的构建及丰富自己</span></span><br><span class="line"><span class="comment">//一种是直接new来创建，但是它是可以创建一个实例但是只能使用源码中的默认配置</span></span><br><span class="line">HttpLoggingInterceptor httpLoggingInterceptor=<span class="keyword">new</span> HttpLoggingInterceptor();</span><br><span class="line">        <span class="comment">//创建了一个http请求的日志拦截器</span></span><br><span class="line">        httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">        client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(httpLoggingInterceptor)</span><br><span class="line">                <span class="comment">//超时设置</span></span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//        client=new OkHttpClient();</span></span><br></pre></td></tr></table></figure><p>如下代码演示了一个Get请求使用同步方式获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                                            Post请求时创建的RequestBody -&gt; FormBody   MultipartBody ContentTypeOverridingRequestBody（这是一个private）</span></span><br><span class="line"><span class="comment">//                        RequestBody requestBody=new FormBody.Builder()</span></span><br><span class="line"><span class="comment">//                                .add("","")</span></span><br><span class="line"><span class="comment">//                                .build();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                                         使用建造者模式来构建一个Request对象</span></span><br><span class="line">                        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                                .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">                                .get()</span><br><span class="line"><span class="comment">//                                .post(requestBody)</span></span><br><span class="line">                                .build();</span><br><span class="line"><span class="comment">//                        如下同步请求</span></span><br><span class="line"><span class="comment">//                        try &#123;</span></span><br><span class="line"><span class="comment">//                            Response response = client.newCall(request).execute();</span></span><br><span class="line"><span class="comment">//                            Log.d("123", "initData: "+response.body().string());</span></span><br><span class="line"><span class="comment">//                        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                                          如下异步请求</span></span><br><span class="line">                        client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                                Log.e(<span class="string">"123"</span>, <span class="string">"onFailure: "</span>+e.getLocalizedMessage() );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, <span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                                <span class="keyword">final</span> String msg=response.body().string();</span><br><span class="line">                                Log.d(<span class="string">"123"</span>, <span class="string">"initData: "</span>+msg);</span><br><span class="line">                                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        tvOkhttpContent.setText(msg);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br></pre></td></tr></table></figure><p>首先分享OkHttpClient的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(httpLoggingInterceptor)</span><br><span class="line">                <span class="comment">//超时设置</span></span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>Builder（）中代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分发器初始化</span></span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">  <span class="comment">//协议部分 </span></span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">  authenticator = Authenticator.NONE;</span><br><span class="line">  <span class="comment">//初始化了连接池</span></span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">  followRedirects = <span class="keyword">true</span>;</span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//超时设置</span></span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder（）中属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">  .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure><p>.build（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建了OkhttpClient对象并把Builder传递进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将Builder中设置属性直接给OkHttpClient对象赋值了 this-&gt;Builder实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们来分析Request的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                                .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">                                .get()</span><br><span class="line">                                .build();</span><br></pre></td></tr></table></figure><p>Request.Builder() 设置了默认就是GET请求，所以上面.get（）可以不写。初始化了Headers.Builder().</p><img src="okhttpsource1/2020-03-21-21-37-20.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是将我们传递的String类型的Url转换为HttpUrl 并赋值</span></span><br><span class="line">.url(<span class="string">"https://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给method-&gt;"GET" requestBody进行了赋值 其中还包括对method的null 与 “”的判断  还有对requestBody的校验</span></span><br><span class="line">.get()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验url不可以为空 然后new 了Request对象并把Builder（）对象传递进去 Request中就是将Builder里面设置的属性赋值给Request中对应的属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是对Post请求的一些代码跟踪<br><img src="okhttpsource1/2020-03-21-21-38-01.png"></p><p>如下是requestBody的创建，同样这些核心的对象都是通过建造者模式创建的。<br><img src="okhttpsource1/2020-03-21-21-38-15.png"></p><p>RequestBody有如下三个子类：<br><img src="okhttpsource1/2020-03-21-21-38-30.png"><br>FormBody一般就是表单提交方式的Post<br>MultipartBody 一般文件上传/提交<br>…</p><p>FormBody.Builder()的源码如下：<br><img src="okhttpsource1/2020-03-21-21-38-51.png"><br>大家能看到Builder（）内部调用了一个构造重载函数，入口参数设置了null 该入口参数是字段字符编码。</p><p>接下来add方法，源码如下：<br><img src="okhttpsource1/2020-03-21-21-39-07.png"></p><p>这里值得我们注意的是 names  values 是两个ArrayList数据结构（不像我们平时经常使用的Map）。</p><p>如下是build（）的源码：<br><img src="okhttpsource1/2020-03-21-21-39-22.png"><br>我们发现创建了FormBody然后把上面的names values传递进去，然后给FormBody的对应属性赋值。<br>如上就是FormBody的构建构成。</p><p>接下来.post(requestBody)<br><img src="okhttpsource1/2020-03-21-21-39-40.png"><br>我们发现与GET请求调用了一样的方法 method（xx,xx）<br>入口参数 method 传递的是“POST”<br>第二个参数就是我们刚刚构建的FormBody实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp的原理及源码分析（上）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource3/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource3/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:58:05.709Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor</p><a id="more"></a><h3 id="ConnectInterceptor-链接拦截器"><a href="#ConnectInterceptor-链接拦截器" class="headerlink" title="ConnectInterceptor 链接拦截器"></a>ConnectInterceptor 链接拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="comment">//读取了StreamAllocation </span></span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//获取到我们使用的HttpCodec的实例 使用http 1.1版本协议 获取到的应该是Http1Codec实例</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//获取到RealConnection对象实例</span></span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line">    <span class="comment">//将获取到的这些业务实体对象传递给下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取并设置这些超时时间</span></span><br><span class="line">  <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">  <span class="comment">//是否开启链接失败后的重试逻辑</span></span><br><span class="line">  <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//从ConnectionPool获取一个健康的链接 findHealthyConnection 调用了findConnection 最终调用了ConnectionPool里面的get方法</span></span><br><span class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//根据我们获取到的链接创建了HttpCodec实例</span></span><br><span class="line">    HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      codec = resultCodec;</span><br><span class="line">      <span class="keyword">return</span> resultCodec;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CallServerInterceptor 链接拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">  RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">  realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">  <span class="comment">//发起请求</span></span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line">  realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">    <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">    <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      <span class="comment">//获取响应</span></span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">      realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">      <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">          <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">      realChain.eventListener()</span><br><span class="line">          .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">      <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">      <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">      <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">    <span class="comment">// try again to read the actual response</span></span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line">  realChain.eventListener()</span><br><span class="line">          .responseHeadersEnd(realChain.call(), response);</span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">      || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">        <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终获取响应数据</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于OkHttp的连接池及连接创建过程可以参见：<br><a href="https://sq.163yun.com/blog/article/188729834576564224" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/188729834576564224</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的原理及源码分析（下）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource2/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource2/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:55:11.354Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp的原理及源码分析（下）</p><a id="more"></a><p>接下来我们来分析OkHttp的真正的网络请求是如何发送的？</p><img src="okhttpsource2/2020-03-21-21-41-55.png"><p>client.newCall(request) 的源码分析如下：</p><img src="okhttpsource2/2020-03-21-21-42-21.png"><p>newCall实际是调用了RealCall.newRealCall 然后 把okhttpclient（this） 还有构建的get请求的Request对象  还有一个forWebSocket 传递进去。</p><img src="okhttpsource2/2020-03-21-21-42-45.png"><p>我们发现newRealCall方法里面首创建了一个RealCall的实例，然后设置了一下eventListener。</p><img src="okhttpsource2/2020-03-21-21-43-06.png"><p>如果是RealCall的构造函数，其中很容易发现对入口参数传递过来的值给予RealCall对应属性。重试拦截器的创建就超时处理，超时是在timeout.timeout设置的，其实也就是通过我们OkHttpClient的Builder来进行设置的，如：</p><img src="okhttpsource2/2020-03-21-21-43-37.png"><p>然后，如果超时就调用了timedOut方法，最后执行了cancel（）；方法，如下是cancel方法的源码</p><img src="okhttpsource2/2020-03-21-21-44-06.png"><p>其实就是调用了重试拦截器的cancel方法。<br>如上就是client.newCall(request)代码的执行逻辑。</p><hr><p>拓展内容：<br>分析RealCall 实现了 Call  Call 继承了 Cloneable<br>我们发现Call中使用了原型模式，目的是创建新Call对象。<br>对应我们的最终实现类是RealCall，所以如果我们要创建一个新的RealCall实例 就可以通过clone方法。<br>整个设计思路我们可以理解为使用了原型设计模式来进行的处理。</p><p>接下来我们将分析enqueue方法，注意入口参数Callback<br><img src="okhttpsource2/2020-03-21-21-45-54.png"><br>实际是调用了RealCall的enqueue方法，源码如下：<br><img src="okhttpsource2/2020-03-21-21-46-21.png"><br>判断是否当前任务已经在执行，直接就抛一个异常。<br>设置了一下eventListener的callStart 传入了RealCall实例。<br>使用client的分发器（dispatcher，它是在OkHttpClient的 Builder（）中初始化）的enqueue方法，该方法传递了一个AsyncCall对象实例，AsyncCall中有传递了responseCallback（它就是我们在代码中调用enqueue时传递的Callback对象）。</p><p>下面我们来看AsyncCall，源码如下：<br>构造函数如下，很简单就是把外面的responseCallback进行复制给它的对应属性。<br><img src="okhttpsource2/2020-03-21-21-47-13.png"><br>下面来看一下AsyncCall它的继承关系。<br><img src="okhttpsource2/2020-03-21-21-47-34.png"><br>我们发现继承了NamedRunnable，如下是NamedRunnable的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了Runnable接口 并且实现了Runnable的run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行子类中需要实现的execute（）方法</span></span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//该类需要子类必须实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来继续分享 client.dispather().enqueue(…)方法。</p><p>Dispather.java 类中enqueue方法如下：<br><img src="okhttpsource2/2020-03-21-21-50-07.png"><br>首先将传递过来的call加入到readyAsyncCalls队列中，如下是readyAsyncCalls的初始化代码：<br><img src="okhttpsource2/2020-03-21-21-50-32.png"><br>下面是promoteAndExecute代码的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">//初始化了一个任务执行计划</span></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//迭代readAsyncCalls队列</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="comment">//获取到请求任务</span></span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line">      <span class="comment">//runningAsyncCalls.size 如果大于 maxRequests(64) 直接跳出循环</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">//判断请求数量大于了已经设置的host的处理任务阀值（maxRequestRerHost=5）跳出当前循环</span></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">      <span class="comment">//readyAsyncCalls 中对于 AsyncCall 移除掉</span></span><br><span class="line">      i.remove();</span><br><span class="line">      <span class="comment">//然后把asyncCall加入到executableCalls集合中</span></span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      <span class="comment">//然后又把asyncCall加入到runningAsyncCalls队列里面来</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">//从上面局部定义请求集合中取出将要执行的任务</span></span><br><span class="line">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">    <span class="comment">//执行任务 传递了一个入口参数 使用的方法executorService（）（该方法目的是获取线程池）</span></span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executorService（）创建并获取线程池，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">  <span class="comment">//success 是否成功标记</span></span><br><span class="line">  <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用外面传入进来的线程池，调用线程池execute方法（该方法入口参数是this -&gt; AsyncCall）</span></span><br><span class="line">    <span class="comment">//为什么传入this给线程池就可以运行？因为AsyncCall继承了NamedRunnable，NamedRunnable实现了Runnable接口</span></span><br><span class="line">    executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//标记设置true</span></span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    <span class="comment">//自定义了IO异常</span></span><br><span class="line">    InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">    ioException.initCause(e);</span><br><span class="line">    <span class="comment">//回调给EventListener</span></span><br><span class="line">    eventListener.callFailed(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    <span class="comment">//回调给我们编写代码时传入的Callback</span></span><br><span class="line">    responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功走如下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会走到下面的execute（）？<br>原因是因为执行 executorService.execute(this);<br>this=AsyncCall的实例，AsyncCall继承NamedRunnable，NamedRunnable的run方法里面执行了execute（）方法，这个方法是必须由子类来实现的一个方法，也就AsyncCall的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">  timeout.enter();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//下面这行代码很重要了，从拦截器链中获取执行的响应结果数据</span></span><br><span class="line">    Response response = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e = timeoutExit(e);</span><br><span class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是责任链处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始真正的执行网络请求</span></span><br><span class="line">  <span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">// 责任链</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//在配置okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//负责处理失败后的重试与重定向</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息</span></span><br><span class="line">    <span class="comment">//从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">    <span class="comment">//设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">    <span class="comment">//可配置用户自己设置的缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//配置okhttpClient 时设置的networkInterceptors</span></span><br><span class="line">      <span class="comment">//返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">    <span class="comment">//进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">//创建责任链</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    <span class="comment">//执行责任链</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如下是责任链的执行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">    RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">//创建新的拦截链，链中的拦截器集合index+1</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">      connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">      writeTimeout);</span><br><span class="line"><span class="comment">//执行当前的拦截器-如果在配置okhttpClient，时没有设置intercept默认是先执行：retryAndFollowUpInterceptor 拦截器</span></span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line"><span class="comment">//执行拦截器</span></span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中说明了新建了一个RealInterceptorChain 责任链 并且 index+1获取到下一个拦截器，然后 执行interceptors.get(index); 获取当前的拦截器返回最终的Response响应结果数据。</p><p>这样设计的一个优点是，责任链中每个拦截器都会执行chain.proceed()方法之前的代码，等责任链最后一个拦截器执行完毕后会返回最终的响应数据。</p><p>如上源码中我们发现具体的拦截器以及顺序如下：<br>  自定义的拦截器<br>RetryAndFollowUpInterceptor<br>BridgeInterceptor<br>CacheInterceptor<br>ConnectIntercetot<br>CallServerInterceptor<br>下面分别来看一下具体的拦截器作用都有哪些（如下内容部分来源网络）？</p><p>自定义拦截器：</p><p>这个是开发人员自己实现具体要按实际业务分析</p><p>RetryAndFollowUpInterceptor：</p><p>请求失败后进行重试<br>服务器返回请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接</p><p>BridgeInterceptor：</p><p>设置内容长度，内容编码<br>设置gzip压缩，并在接收到内容后进行解压<br>添加cookie<br>设置其他报头，如User-Agent,Host,Keep-alive等，其中Keep-Alive是实现多路复用的必要步骤</p><p>CacheInterceptor</p><p>职责很明确，就是负责Cache的管理</p><p>当网络请求有符合要求的Cache时直接返回Cache<br>当服务器返回内容有改变时更新当前cache<br>如果当前cache失效，删除</p><p>ConnectInterceptor：</p><p>为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p><p>CallServerInterceptor：</p><p>负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回</p><p>StreamAllocation的作用是什么？</p><p>       StreamAllocation负责统筹管理Connection、Stream、Call三个实体类，具体就是为一个Call（Realcall），寻找（ findConnection() ）一个Connection（RealConnection），获取一个Stream（HttpCode）。</p><p>最后释放资源</p><p>最后无论是execute（）同步请求还是enqueue（）异步请求都会调用如下代码来善终。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果是异步请求就是AsyncCall</span></span><br><span class="line"><span class="comment">/** Used by &#123;<span class="doctag">@code</span> AsyncCall#run&#125; to signal completion. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是同步请求就是RealCall</span></span><br><span class="line"><span class="comment">/** Used by &#123;<span class="doctag">@code</span> Call#execute&#125; to signal completion. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">  finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//将请求对象call从对应的队列里面移除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">    <span class="comment">//给idleCallback赋值</span></span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否还有任务再执行</span></span><br><span class="line">  <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">  <span class="comment">//如果没有任务在执行了并且还有人注册了idleCallback 然后就回调idleCallback的run方法</span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp的原理及源码分析（下）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 三、音乐APP（添加Module并添加FFmpeg动态库）</title>
    <link href="http://www.zydeveloper.com/2019/09/05/ffmpeg-demo1-module/"/>
    <id>http://www.zydeveloper.com/2019/09/05/ffmpeg-demo1-module/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2019-09-05T03:56:27.850Z</updated>
    
    <content type="html"><![CDATA[<p>基于之前的工程来添加Module工程。</p><a id="more"></a><h2 id="创建Module工程"><a href="#创建Module工程" class="headerlink" title="创建Module工程"></a>创建Module工程</h2><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-04-20-08-12.png"><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-04-20-09-07.png">将新建的Module工程添加到APP工程中。<img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-25-30.png"><h2 id="Module添加C-支持"><a href="#Module添加C-支持" class="headerlink" title="Module添加C++支持"></a>Module添加C++支持</h2><h3 id="将app-gradle中的配置移植到module-gradle中"><a href="#将app-gradle中的配置移植到module-gradle中" class="headerlink" title="将app gradle中的配置移植到module gradle中"></a>将app gradle中的配置移植到module gradle中</h3><p>将app gradle中的如下配置移植到module gradle中。<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-29-46.png"><br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-30-55.png"></p><h3 id="将app中的CMakeLists-txt移植到module中"><a href="#将app中的CMakeLists-txt移植到module中" class="headerlink" title="将app中的CMakeLists.txt移植到module中"></a>将app中的CMakeLists.txt移植到module中</h3><p>注意我们要移植到module工程的根目录中，如：</p><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-51-06.png"><h3 id="module工程中创建类文件添加native方法"><a href="#module工程中创建类文件添加native方法" class="headerlink" title="module工程中创建类文件添加native方法"></a>module工程中创建类文件添加native方法</h3><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-39-00.png">有报红的是因为我们移植过来的cpp文件jni 方法包名不对引起的。修正为：<img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-41-55.png"><h3 id="修改app的MainActivity代码用于测试验证结果"><a href="#修改app的MainActivity代码用于测试验证结果" class="headerlink" title="修改app的MainActivity代码用于测试验证结果"></a>修改app的MainActivity代码用于测试验证结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.music.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">        tv.setText(<span class="keyword">new</span> Demo().stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-49-29.png"><p>我们看到上面已经正常输出了c++的运算结果。</p><h2 id="添加FFmpeg动态库"><a href="#添加FFmpeg动态库" class="headerlink" title="添加FFmpeg动态库"></a>添加FFmpeg动态库</h2><p>这里面提到的资源如果给位没有，请参考：</p><p><a href="http://www.zydeveloper.com/2019/09/04/ffmpeg-build/">FFmpeg系列 一、编译FFmpeg</a></p><h4 id="module-cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件"><a href="#module-cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件" class="headerlink" title="module cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件"></a>module cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件</h4><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-43-29.png"><h4 id="module-main文件夹中创建jniLibs-复制arm-和-x86的-so库到jinLibs中"><a href="#module-main文件夹中创建jniLibs-复制arm-和-x86的-so库到jinLibs中" class="headerlink" title="module main文件夹中创建jniLibs,复制arm 和 x86的.so库到jinLibs中"></a>module main文件夹中创建jniLibs,复制arm 和 x86的.so库到jinLibs中</h4><p>创建jniLibs目录<br>将arm和x86动态库拷贝到jinLibs目录下。<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-09-02-58.png"></p><h4 id="配置module-gradle文件"><a href="#配置module-gradle文件" class="headerlink" title="配置module gradle文件"></a>配置module gradle文件</h4><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-41-31.png"><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-42-19.png"><h4 id="cmakelists-txt-配置FFmpeg"><a href="#cmakelists-txt-配置FFmpeg" class="headerlink" title="cmakelists.txt 配置FFmpeg"></a>cmakelists.txt 配置FFmpeg</h4><h5 id="导入include路径"><a href="#导入include路径" class="headerlink" title="导入include路径"></a>导入include路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导入头文件路径</span><br><span class="line">include_directories(src/main/cpp/include)</span><br></pre></td></tr></table></figure><h5 id="添加动态库"><a href="#添加动态库" class="headerlink" title="添加动态库"></a>添加动态库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导入动态库</span><br><span class="line">add_library(avcodec-57 SHARED IMPORTED)</span><br></pre></td></tr></table></figure><h5 id="设置动态库路径"><a href="#设置动态库路径" class="headerlink" title="设置动态库路径"></a>设置动态库路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so)</span><br></pre></td></tr></table></figure><h5 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       avcodec-57</span><br><span class="line"></span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><h4 id="最终CMake"><a href="#最终CMake" class="headerlink" title="最终CMake"></a>最终CMake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#导入头文件路径</span><br><span class="line">include_directories(include)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avcodec-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avdevice-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avdevice-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavdevice-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avfilter-6 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avfilter-6 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavfilter-6.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avformat-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avformat-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavformat-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avutil-55 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avutil-55 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavutil-55.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(postproc-54 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(postproc-54 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libpostproc-54.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(swresample-2 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(swresample-2 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswresample-2.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(swscale-4 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(swscale-4 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswscale-4.so)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library(native-lib</span><br><span class="line">            SHARED</span><br><span class="line">            native-lib.cpp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_library(log-lib</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_link_libraries(native-lib</span><br><span class="line">        $&#123;log-lib&#125;</span><br><span class="line"></span><br><span class="line">                       avcodec-57</span><br><span class="line">                        avdevice-57</span><br><span class="line">                        avfilter-6</span><br><span class="line">                        avformat-57</span><br><span class="line">                        avutil-55</span><br><span class="line">                        postproc-54</span><br><span class="line">                        swresample-2</span><br><span class="line">                        swscale-4</span><br><span class="line"></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><p><strong>注意：CMakeLists.txt文件需要放到项目跟目录，否则会出现路径不对引发的错误。</strong></p><h2 id="Demo验证FFmpeg是否集成成功"><a href="#Demo验证FFmpeg是否集成成功" class="headerlink" title="Demo验证FFmpeg是否集成成功"></a>Demo验证FFmpeg是否集成成功</h2><p>在module 工程 Demo中导入动态库并加入native方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.music.mplayer;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // Used to load the &apos;native-lib&apos; library on application startup.</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;native-lib&quot;);</span><br><span class="line"></span><br><span class="line">        System.loadLibrary(&quot;avcodec-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avdevice-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avfilter-6&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avformat-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avutil-55&quot;);</span><br><span class="line">        System.loadLibrary(&quot;postproc-54&quot;);</span><br><span class="line">        System.loadLibrary(&quot;swresample-2&quot;);</span><br><span class="line">        System.loadLibrary(&quot;swscale-4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A native method that is implemented by the &apos;native-lib&apos; native library,</span><br><span class="line">     * which is packaged with this application.</span><br><span class="line">     */</span><br><span class="line">    public native String stringFromJNI();</span><br><span class="line"></span><br><span class="line">    public native void testFFmpeg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报红的部分 alt+enter 搞定。</p><p>native-lib.cpp代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,<span class="meta-string">"zhangyue"</span>,FORMAT,##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring</span><br><span class="line">JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Welcome to"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_testFFmpeg(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    AVCodec *c_temp = av_codec_next(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (c_temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c_temp-&gt;type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                LOGI(<span class="string">"[Video]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                LOGI(<span class="string">"[Audio]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                LOGI(<span class="string">"[Other]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c_temp = c_temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.music.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ****;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Demo().testFFmpeg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，logcat输出如下log：<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-48-24.png"></p><p>打印了ffmpeg支持的视频格式，说明我们已经集成成功了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于之前的工程来添加Module工程。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 番外篇 Android C++ 子线程 及 生产者消费者模型</title>
    <link href="http://www.zydeveloper.com/2019/09/05/ffmpeg-other1-thread/"/>
    <id>http://www.zydeveloper.com/2019/09/05/ffmpeg-other1-thread/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2019-09-05T07:10:54.083Z</updated>
    
    <content type="html"><![CDATA[<p>这篇来讲讲Android C++ 子线程 及 生产者消费者模型</p><a id="more"></a><p>Android 中的C++ 线程，我们要使用 POSIX 编写多线程 C++ 程序。</p><p>重要有三个方法：</p><p>pthread_t —— 声明线程<br>pthread_create —— 创建线程<br>pthread_exit  —— 终止线程</p><p>一个Demo来演示线程使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> native  <span class="keyword">void</span> <span class="title">normalThread</span><span class="params">()</span></span>;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">normalCallback</span><span class="params">(<span class="keyword">void</span> *data)</span></span>&#123;</span><br><span class="line">    LOGI(<span class="string">"create normal thread from c++"</span>);</span><br><span class="line">    pthread_exit(&amp;thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_normalThread(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    pthread_create(&amp;thread,<span class="literal">NULL</span>,normalCallback,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来相对简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇来讲讲Android C++ 子线程 及 生产者消费者模型&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 一、编译FFmpeg</title>
    <link href="http://www.zydeveloper.com/2019/09/04/ffmpeg-build/"/>
    <id>http://www.zydeveloper.com/2019/09/04/ffmpeg-build/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-09-04T08:58:51.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h2><p>在Ubuntu中编译Android平台的FFmpeg（arm和x86）</p><a id="more"></a><p>环境准备：</p><p>-下载FFmpeg源码（v3.3.9）<br>-下载NDK（r14b）<br>-编写Android编译脚本</p><h3 id="下载FFmpeg源码（v3-3-9）"><a href="#下载FFmpeg源码（v3-3-9）" class="headerlink" title="下载FFmpeg源码（v3.3.9）"></a>下载FFmpeg源码（v3.3.9）</h3><p><a href="http://www.ffmpeg.org/download.html#releases" target="_blank" rel="noopener">V3.3.9下载地址</a></p><img src="/2019/09/04/ffmpeg-build/2019-09-04-09-26-57.png"><h3 id="下载NDK（r14b）"><a href="#下载NDK（r14b）" class="headerlink" title="下载NDK（r14b）"></a>下载NDK（r14b）</h3><p><a href="https://developer.android.google.cn/ndk/downloads/older_releases.html" target="_blank" rel="noopener">NDK r14b 下载</a></p><p>因为在Ubuntu下编译，便于我们方便连接操作，我这里使用XShell与XFTP工具。</p><h3 id="使用FTP上传下载文件到Ubuntu中"><a href="#使用FTP上传下载文件到Ubuntu中" class="headerlink" title="使用FTP上传下载文件到Ubuntu中"></a>使用FTP上传下载文件到Ubuntu中</h3><img src="/2019/09/04/ffmpeg-build/2019-09-04-10-13-07.png"><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><h4 id="解压FFmpeg"><a href="#解压FFmpeg" class="headerlink" title="解压FFmpeg"></a>解压FFmpeg</h4><p>tar -zxvf ffmpeg-3.3.9.tar.gz</p><h4 id="解压NDK"><a href="#解压NDK" class="headerlink" title="解压NDK"></a>解压NDK</h4><p>unzip android-ndk-r14b-linux-x86_64.zip</p><h3 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h3><h4 id="修改FFmpeg的configure文件"><a href="#修改FFmpeg的configure文件" class="headerlink" title="修改FFmpeg的configure文件"></a>修改FFmpeg的configure文件</h4><p><strong><em>因为android只能加载.so的动态库，不能识别如</em>.so.57结尾的*</strong></p><p>将虚拟机中的configure文件使用FTP下载到本地进行如下修改：</p><p>进行如图修改：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-12-01-10.png"></p><p>修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;</span><br><span class="line">#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;</span><br><span class="line">#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;</span><br><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</span><br></pre></td></tr></table></figure><p>修改后更新到Ubuntu中。</p><p>设置configure权限并执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 configure</span><br><span class="line"></span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><img src="/2019/09/04/ffmpeg-build/2019-09-04-14-31-36.png"><h4 id="编写Android编译脚本"><a href="#编写Android编译脚本" class="headerlink" title="编写Android编译脚本"></a>编写Android编译脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>NDK路径 此次要改成你真实环境ndk所在目录</span><br><span class="line">export NDK_HOME=/home/**/ffmpeg/android-ndk-r14b  </span><br><span class="line"><span class="meta">#</span>android 平台版本</span><br><span class="line">export PLATFORM_VERSION=android-9</span><br><span class="line"><span class="meta">#</span>定义build函数</span><br><span class="line">function build</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#</span>输出编译的哪个平台</span><br><span class="line">echo "start build ffmpeg for $ARCH"</span><br><span class="line"><span class="meta">#</span>传入参数——目标平台linux</span><br><span class="line">./configure --target-os=linux \</span><br><span class="line"><span class="meta">#</span>输出路径</span><br><span class="line">--prefix=$PREFIX --arch=$ARCH \</span><br><span class="line"><span class="meta">#</span>排除 doc</span><br><span class="line">--disable-doc \</span><br><span class="line">--enable-shared \</span><br><span class="line"><span class="meta">#</span>去掉静态库</span><br><span class="line">--disable-static \</span><br><span class="line"><span class="meta">#</span>去掉汇编</span><br><span class="line">--disable-yasm \</span><br><span class="line">--disable-asm \</span><br><span class="line">--disable-symver \</span><br><span class="line">--enable-gpl \</span><br><span class="line"><span class="meta">#</span>去掉。。。</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--disable-ffplay \</span><br><span class="line">--disable-ffprobe \</span><br><span class="line">--disable-ffserver \</span><br><span class="line"><span class="meta">#</span>配置交叉编译环境</span><br><span class="line">--cross-prefix=$CROSS_COMPILE \</span><br><span class="line"><span class="meta">#</span>启用交叉编译环境</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line"><span class="meta">#</span>开启最小编译</span><br><span class="line">--enable-small \</span><br><span class="line">--extra-cflags="-Os -fpic $ADDI_CFLAGS" \</span><br><span class="line">--extra-ldflags="$ADDI_LDFLAGS" \</span><br><span class="line"><span class="meta">$</span>ADDITIONAL_CONFIGURE_FLAG</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">echo "build ffmpeg for $ARCH finished"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>arm</span><br><span class="line">ARCH=arm</span><br><span class="line">CPU=arm</span><br><span class="line"><span class="meta">#</span>输出路径为当前目录下的android下的架构 动态库及头文件会放到这里</span><br><span class="line">PREFIX=$(pwd)/android/$ARCH</span><br><span class="line"><span class="meta">#</span>配置编译工具</span><br><span class="line">TOOLCHAIN=$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span>交叉编译目录</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line">ADDI_CFLAGS="-marm"</span><br><span class="line"><span class="meta">#</span>系统平台目录</span><br><span class="line">SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>x86</span><br><span class="line">ARCH=x86</span><br><span class="line">CPU=x86</span><br><span class="line">PREFIX=$(pwd)/android/$ARCH</span><br><span class="line">TOOLCHAIN=$NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android-</span><br><span class="line">ADDI_CFLAGS="-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32"</span><br><span class="line">SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>（使用时要将上面中文注释都去掉，否则有坑哈<del>~</del>）</p><p>执行android编译脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 build_android.sh</span><br><span class="line"></span><br><span class="line">./build_android.sh</span><br></pre></td></tr></table></figure><p>其中可能遇到一些问题，解决方法可以参见下方说明。<br>编译中：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-15-35-12.png"></p><p>大概编译10分钟左右，我是虚拟机编译可能比较慢，各位可以使用真机编译会快一点。<br>最终编译完成后如下：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-04-46.png"><br>取出我们使用的文件：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-03-45.png"><br>include头文件使用arm或者x86的都可以。<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-06-34.png"><br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-07-07.png"></p><p>如上就是ffmpeg的编译过程。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc is unable to create an executable file.</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure><h3 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yasm/nasm not found or too old. Use --disable-yasm for a crippled build.</span><br></pre></td></tr></table></figure><p>原因：<br>yasm是汇编编译器，ffmpeg为了提高效率使用了汇编指令，如MMX和SSE等。所以系统中未安装yasm时，就会报上面错误。</p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install yasm</span><br></pre></td></tr></table></figure><h3 id="问题3："><a href="#问题3：" class="headerlink" title="问题3："></a>问题3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mark command not found</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译FFmpeg&quot;&gt;&lt;a href=&quot;#编译FFmpeg&quot; class=&quot;headerlink&quot; title=&quot;编译FFmpeg&quot;&gt;&lt;/a&gt;编译FFmpeg&lt;/h2&gt;&lt;p&gt;在Ubuntu中编译Android平台的FFmpeg（arm和x86）&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 二、音乐APP（创建工程）</title>
    <link href="http://www.zydeveloper.com/2019/09/04/ffmpeg-demo/"/>
    <id>http://www.zydeveloper.com/2019/09/04/ffmpeg-demo/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-09-04T11:58:30.047Z</updated>
    
    <content type="html"><![CDATA[<p>通过实现一个音乐APP来演示ffmpeg的使用。</p><a id="more"></a><p>使用AndroidStudio创建项目：</p><img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-34-51.png">下一步<img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-37-22.png">下一步<img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-38-13.png"><p>Finish</p><p>如有报错，要检查是否配置了NDK，如：<br><img src="/2019/09/04/ffmpeg-demo/2019-09-04-19-26-12.png"></p><p>下面来聊聊 CMakeLists.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#cmake的版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#添加一个library 名称为native-lib</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             native-lib.cpp )</span><br><span class="line"></span><br><span class="line">#动态库 log-lib —— 别名  log —— 实际动态库</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">#连接上面的动态库 native-lib 及 log动态库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>在来看看app gradle文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    。。。</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">//编译时加入的动态库</span></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          。。。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build文件路径</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"src/main/cpp/CMakeLists.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看MainActivity加入了哪些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入动态库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要c/c++实现的native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看看native-lib.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//使用C编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="comment">//导出方法 类型jsstring</span></span><br><span class="line">JNIEXPORT jstring</span><br><span class="line"><span class="comment">//JNI调用</span></span><br><span class="line">JNICALL</span><br><span class="line"><span class="comment">//命名为Java_开头 然后是包名.用_替换+类名+native方法名</span></span><br><span class="line">Java_com_music_app_MainActivity_stringFromJNI(</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行验证一下。</p><p>如果cmake没有按照，则需要安装如下：<br><img src="/2019/09/04/ffmpeg-demo/2019-09-04-19-58-13.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过实现一个音乐APP来演示ffmpeg的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>三次握手与四次挥手及Http协议</title>
    <link href="http://www.zydeveloper.com/2019/08/16/networkprotocol/"/>
    <id>http://www.zydeveloper.com/2019/08/16/networkprotocol/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-16T08:20:39.977Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下内容摘录自《Android进阶之光》——刘望舒</strong></p><h3 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h3><p>为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-03-06.png"></p><a id="more"></a><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP三次握手的过程如下。</p><p>• 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq） 为x； 接下来客户端进入SYN_SENT状态， 等待服务端的确认。</p><p>• 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置AcknowledgmentNumber（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将SYN设置为1、 seq为y。 服务端将上述所有信息放到SYN+ACK报文段中， 一并发送给客户端， 此时服务端进入SYN_RCVD状态。</p><p>• 第三次握手： 客户端收到服务端的SYN+ACK报文段； 然后将ACK设置为y+1， 向服务端发送ACK报文段， 这个报文段发送完毕后， 客户端和服务端都进入ESTABLISHED （TCP连接成功）状态， 完成TCP的三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务端通过三次握手建立了TCP连接以后， 当数据传送完毕， 断开连接时就需要进行TCP的四次挥手。 其四次挥手如下所示。</p><p>• 第一次挥手： 客户端设置seq和ACK， 向服务端发送一个FIN报文段。 此时， 客户端进入FIN_WAIT_1状态， 表示客户端没有数据要发送给服务端了。</p><p>• 第二次挥手： 服务端收到了客户端发送的FIN报文段， 向客户端回了一个ACK报文段。</p><p>• 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进LAST_ACK状态。</p><p>• 第四次挥手： 客户端收到服务端发送的FIN报文段， 向服务端发送ACK报文段， 然后客户端进入TIME_WAIT状态。 服务端收到客户端的ACK报文段以后， 就关闭连接。 此时， 客户端等待2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-05-25.png"><br>如果有大量的连接， 每次在连接、 关闭时都要经历三次握手、 四次挥手， 这很显然会造成性能低下。<br>因此， HTTP有一种叫作keepalive connections的机制， 它可以在传输数据后仍然保持连接， 当客户端需要再次获取数据时， 直接使用刚刚空闲下来的连接而无须再次握手.<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-06-28.png"></p><h3 id="HTTP协议原理"><a href="#HTTP协议原理" class="headerlink" title="HTTP协议原理"></a>HTTP协议原理</h3><p>作为移动开发者， 开发的应用不免会对网络进行访问。 虽然现在已经有很多开源库帮助我们可以轻而易举地访问网络， 但是我们仍需要去了解网络访问的原理， 这也是一个优秀开发人员所必备的知识点。 </p><h4 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h4><p>HTTP 是一个属于应用层的面向对象的协议， 由于其简捷、 快速的方式， 适用于分布式超媒体信息系统。 它于1990年被提出， 经过几年的使用与发展， 得到不断的完善和扩展。</p><h5 id="1-HTTP的历史版本"><a href="#1-HTTP的历史版本" class="headerlink" title="1.HTTP的历史版本"></a>1.HTTP的历史版本</h5><p>• HTTP 0.9： 1991年发布的第一个版本， 只有一个命令GET， 服务器只能回应HTML格式的字符串。<br>• HTTP 1.0： 1996年发布的版本， 内容量大大增加。 除了GET命令外， 还引入了POST命令和HEAD命令。 HTTP请求和回应的格式除了数据部分， 每次通信都必须包括头信息， 用来描述一些元数据。<br>• HTTP 1.1： 1997发布的版本， 进一步完善了HTTP协议， 直到现在还是最流行的版本。<br>• SPDY协议： 2009年谷歌为了解决 HTTP 1.1效率不高的问题而自行研发的协议。<br>• HTTP 2： 2015年新发布的版本， SPDY 协议的主要特性也在此版本中。</p><h5 id="2-HTTP协议的主要特点"><a href="#2-HTTP协议的主要特点" class="headerlink" title="2.HTTP协议的主要特点"></a>2.HTTP协议的主要特点</h5><p>HTTP协议的主要特点如下。<br>• 支持C/S（客户/服务器） 模式。<br>• 简单快速： 客户向服务器请求服务时， 只需传送请求方法和路径。 请求方法常用的有GET、 HEAD、POST， 每种方法规定了客户与服务器联系的类型不同。 由于 HTTP 协议简单，使得HTTP服务器的程序规模小， 因而通信速度很快。<br>• 灵活： HTTP允许传输任意类型的数据对象。 正在传输的类型由Content-Type加以标记。 • 无连接： 无连接的含义是限制每次连接只处理一个请求。 服务器处理完客户的请求， 并收到客户的应答后， 即断开连接。 采用这种方式可以节省传输时间。<br>• 无状态： HTTP协议是无状态协议， 无状态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据量增大； 而另一方面， 在服务器不需要先前信息时它的应答速度就较快。</p><p>HTTP URL的格式如下所示：</p><p><a href="http://host[＂:＂port][abs_path]" target="_blank" rel="noopener">http://host[＂:＂port][abs_path]</a></p><p>http表示要通过HTTP协议来定位网络资源； host表示合法的Internet主机域名或者IP地址； port指定一个端口号， 为空则使用默认端口80； abs_path指定请求资源的URI（Web上任意的可用资源） 。 HTTP有两种报文， 分别是请求报文和响应报文， 下面先来查看请求报文。</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>HTTP 报文是面向文本的， 报文中的每一个字段都是一些ASCII码串， 各个字段的长度是不确定的。 一般一个HTTP请求报文由请求行、 请求报头、 空行和请求数据4个部分组成<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-09-23.png"></p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h5><p>请求行由请求方法、 URL字段和HTTP协议的版本组成， 格式如下：</p><p>Method Request-URI HTTP-Version CRLF</p><p>其中 Method表示请求方法； Request-URI是一个统一资源标识符； HTTP-Version表示请求的HTTP协议版本； CRLF表示回车和换行（除了作为结尾的CRLF外， 不允许出现单独的CR或LF字符） 。</p><p>HTTP请求方法有8种， 分别是GET、 POST、 HEAD、 PUT、 DELETE、 TRACE、CONNECT、OPTIONS。</p><p> 对于移动开发最常用的就是GET和POST了。</p><p>• GET： 请求获取Request-URI所标识的资源。<br>• POST： 在Request-URI所标识的资源后附加新的数据。<br>• HEAD： 请求获取由Request-URI所标识的资源的响应消息报头。<br>• PUT： 请求服务器存储一个资源， 并用Request-URI作为其标识。<br>• DELETE： 请求服务器删除Request-URI所标识的资源。<br>• TRACE： 请求服务器回送收到的请求信息， 主要用于测试或诊断。<br>• CONNECT： HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>• OPTIONS： 请求查询服务器的性能， 或者查询与资源相关的选项和需求。</p><p>例如， 访问我的CSDN博客地址的请求行：<br>GET <a href="http://zydeveloper.com" target="_blank" rel="noopener">http://zydeveloper.com</a></p><h5 id="2-请求报头"><a href="#2-请求报头" class="headerlink" title="2.请求报头"></a>2.请求报头</h5><p>在请求行之后会有0个或者多个请求报头， 每个请求报头都包含一个名字和一个值， 它们之间用英文冒号“： ”分割。 关于请求报头， 我们会在后面做统一解释。</p><h5 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h5><p>请求数据不在GET方法中使用， 而在POST方法中使用。 POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求报头是Content-Type和Content-Length。</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><img src="/2019/08/16/networkprotocol/2019-08-16-16-11-37.png">HTTP 的响应报文由状态行、 响应报头、 空行、 响应正文组成。 关于响应报头， 我们会在后面做统一解释。 响应正文是服务器返回的资源的内容。 我们先来看看状态行。状态行格式如下所示：<p>HTTP-Version Status-Code Reason-Phrase CRLF</p><p>其中， HTTP-Version表示服务器HTTP协议的版本； Status-Code表示服务器发回的响应状态码； ReasonPhrase表示状态码的文本描述。 状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。</p><p>• 100～199： 指示信息， 收到请求， 需要请求者继续执行操作。<br>• 200～299： 请求成功， 请求已被成功接收并处理。<br>• 300～399： 重定向， 要完成请求必须进行更进一步的操作。<br>• 400～499： 客户端错误， 请求有语法错误或请求无法实现。<br>• 500～599： 服务器错误， 服务器不能实现合法的请求。</p><p>常见的状态码如下。<br>• 200 OK： 客户端请求成功。<br>• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。<br>• 401 Unauthorized： 请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。<br>• 403 Forbidden： 服务器收到请求， 但是拒绝提供服务。<br>• 500 Internal Server Error： 服务器内部错误， 无法完成请求。<br>• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。</p><p>例如， 访问我的CSDN博客地址， 响应的状态行如下所示：</p><p>HTTP/1.1 200 OK</p><h4 id="HTTP的消息报头"><a href="#HTTP的消息报头" class="headerlink" title="HTTP的消息报头"></a>HTTP的消息报头</h4><p>消息报头分为通用报头、 请求报头、 响应报头、 实体报头等。 消息报头由键值对组成， 每行一对， 关键字和值用英文冒号“： ”分隔。</p><h5 id="1-通用报头"><a href="#1-通用报头" class="headerlink" title="1.通用报头"></a>1.通用报头</h5><p>它既可以出现在请求报头， 也可以出现在响应报头中， 如下所示。<br>• Date： 表示消息产生的日期和时间。<br>• Connection： 允许发送指定连接的选项。 例如指定连接是连续的； 或者指定“close”选项， 通知服务器， 在响应完成后， 关闭连接。<br>• Cache-Control： 用于指定缓存指令， 缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现） ， 且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 。</p><h5 id="2-请求报头-1"><a href="#2-请求报头-1" class="headerlink" title="2.请求报头"></a>2.请求报头</h5><p>请求报头通知服务器关于客户端请求的信息。 典型的请求报头如下所示。<br>• Host： 请求的主机名， 允许多个域名同处一个IP地址， 即虚拟主机。<br>• User-Agent： 发送请求的浏览器类型、 操作系统等信息。<br>• Accept： 客户端可识别的内容类型列表， 用于指定客户端接收哪些类型的信息。<br>• Accept-Encoding： 客户端可识别的数据编码。<br>• Accept-Language： 表示浏览器所支持的语言类型。<br>• Connection： 允许客户端和服务器指定与请求/响应连接有关的选项。 例如， 这时为Keep-Alive则表示保持连接。<br>• Transfer-Encoding： 告知接收端为了保证报文的可靠传输， 对报文采用了什么编码方式。</p><h5 id="3-响应报头"><a href="#3-响应报头" class="headerlink" title="3.响应报头"></a>3.响应报头</h5><p>用于服务器传递自身信息的响应。 常见的响应报头如下所示。<br>• Location： 用于重定向接收者到一个新的位置， 常用在更换域名的时候。<br>• Server： 包含服务器用来处理请求的系统信息， 与User-Agent请求报头是相对应的。</p><h5 id="4-实体报头"><a href="#4-实体报头" class="headerlink" title="4.实体报头"></a>4.实体报头</h5><p>实体报头用来定义被传送资源的信息， 其既可用于请求也可用于响应。 请求和响应消息都可以传送一个实体。 常见的实体报头如下所示。<br>• Content-Type： 发送给接收者的实体正文的媒体类型。<br>• Content-Lenght： 实体正文的长度。<br>• Content-Language： 描述资源所用的自然语言。<br>• Content-Encoding： 实体报头被用作媒体类型的修饰符。 它的值指示了已经被应用到实体正文的附加内容的编码， 因而要获得Content-Type报头域中所引用的媒体类型， 必须采用相应的解码机制。<br>• Last-Modified： 实体报头用于指示资源的最后修改日期和时间。<br>• Expires： 实体报头给出响应过期的日期和时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下内容摘录自《Android进阶之光》——刘望舒&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#TCP的三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;/a&gt;TCP的三次握手与四次挥手&lt;/h3&gt;&lt;p&gt;为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。&lt;br&gt;&lt;img src=&quot;/2019/08/16/networkprotocol/2019-08-16-16-03-06.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://www.zydeveloper.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="其他" scheme="http://www.zydeveloper.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动流程</title>
    <link href="http://www.zydeveloper.com/2019/08/15/activitystart/"/>
    <id>http://www.zydeveloper.com/2019/08/15/activitystart/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-27T11:01:30.312Z</updated>
    
    <content type="html"><![CDATA[<p>这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。</p><a id="more"></a><img src="/2019/08/15/activitystart/2019-08-16-16-34-09.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。&lt;/p&gt;
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.zydeveloper.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="启动流程" scheme="http://www.zydeveloper.com/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android 多渠道打包</title>
    <link href="http://www.zydeveloper.com/2019/08/09/ReleaseApp/"/>
    <id>http://www.zydeveloper.com/2019/08/09/ReleaseApp/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-13T02:36:07.086Z</updated>
    
    <content type="html"><![CDATA[<p>我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。<br>这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。</p><a id="more"></a><p>下面我们来介绍如何使用Gradle进行多渠道打包。</p><p>使用Gradle多渠道打包主要使用<strong>ProductFlavors</strong>。</p><h3 id="ProductFlavors"><a href="#ProductFlavors" class="headerlink" title="ProductFlavors"></a>ProductFlavors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">    productFlavors&#123;</span><br><span class="line">        <span class="comment">//小米</span></span><br><span class="line">        xiaomi&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//豌豆荚</span></span><br><span class="line">        wandoujia&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用宝</span></span><br><span class="line">        yingyongbao&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现有3个渠道xiaomi wandoujia yingyongbao。<br>还有flavorDimensions,这个是干嘛用的呢？<br>如果不加就会报：</p><p>Error:All flavors must now belong to a named flavor dimension.Learn more at <a href="https://d.android.com/r/tools/flavorDimensions-missing-error-message.html" target="_blank" rel="noopener">https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</a> </p><p>大概意思是所有的flavors都要属于同一个规格。<br>点击链接地址后（要翻墙）：<br>Plugin 3.0.0 includes a new dependency mechanism that automatically matches variants when consuming a library. This means an app’s debug variant automatically consumes a library’s debug variant, and so on. It also works when using flavors—an app’s redDebug variant will consume a library’s redDebug variant. To make this work, the plugin now requires that all flavors belong to a named flavor dimension —even if you intend to use only a single dimension. Otherwise, you will get the following build error:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:All flavors must now belong to a named flavor dimension.</span><br><span class="line">The flavor <span class="string">'flavor_name'</span> is not assigned to a flavor dimension.</span><br></pre></td></tr></table></figure><p>To resolve this error, assign each flavor to a named dimension, as shown in the sample below. Because dependency matching is now taken care of by the plugin, you should name your flavor dimensions carefully. For example, if all your app and library modules use the foo dimension, you’ll have less control over which flavors are matched by the plugin.</p><p>我们可以参考友盟的渠道包方式在清单文件中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"MY_CHANNEL"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"$&#123;CHANNEL_VALUE&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>同时修改上面的Gradle为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"xiaomi"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"yingyongbao"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后到工程的跟目录下执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemble</span><br></pre></td></tr></table></figure><p>打包成功后：<br><img src="/2019/08/09/ReleaseApp/2019-08-11-18-31-11.png"><br>在app下的output下就可以看看我们刚刚打的渠道包了。<br><img src="/2019/08/09/ReleaseApp/2019-08-11-18-32-50.png"><br>我们看到已经打包好了不同渠道的debug与release版本的APK。</p><p>当然也可以指定打包：</p><p><strong>只打release版本包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assembleRelease</span><br></pre></td></tr></table></figure><p><strong>只打debug版本包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assembleDebug</span><br></pre></td></tr></table></figure><p><strong>只打小米渠道包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemblexiaomi</span><br></pre></td></tr></table></figure><p><strong>只打小米渠道Release包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemblexiaomiRelease</span><br></pre></td></tr></table></figure><p>多渠道打包时我们可能还会加入一些其他设置如：</p><p><strong>加入不同的APPID及版本号</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyyMMdd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.xiaomi.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"xiaomi"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.wandoujia.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.yingyongbao.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"yingyongbao"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包后发现我们的applicationid与版本信息都定制化了。</p><p><strong>manifestPlaceholders中也可以加入多个配置，如加入第三方的APPKEY</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>,BaiduMapAPPKEY:<span class="string">"s9s87d7f9s6df6s78sd"</span>]</span><br></pre></td></tr></table></figure><p><strong>还可以不同的渠道引入不同的jar包</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">'com.github.leifzhang:IjkLib:0.4.3'</span></span><br><span class="line">    xiaomiImplementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.1.1'</span></span><br><span class="line">    xiaomiImplementation <span class="string">'io.reactivex.rxjava2:rxjava:2.2.11'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用BuildConfig传递配置一些参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"xiaomi\""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"wandoujia\""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"yingyongbao\""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中获取：</span><br><span class="line"><span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"xiaomi"</span>))&#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"wandoujia"</span>))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"yingyongbao"</span>))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BuildConfig也有一些默认的配置属性：<br><img src="/2019/08/09/ReleaseApp/2019-08-13-10-35-45.png"></p><p><strong>甚至还可以各渠道包使用不同的资源</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">      main &#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line">      xiaomi&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      wandoujia&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      yingyongbao&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题？"><a href="#可能遇到的问题？" class="headerlink" title="可能遇到的问题？"></a>可能遇到的问题？</h3><p>问题1：<br>Android studio Error occurred during initialization of VM 问题解决</p><img src="/2019/08/09/ReleaseApp/2019-08-11-18-08-52.png"><p>问题2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':app:compileWandoujiaDebugJavaWithJavac'</span>.</span><br><span class="line">&gt; Could not find tools.jar. Please check that C:\<span class="function">Program <span class="title">Files</span> <span class="params">(x86)</span>\Java\jre1.8.0_211 contains a valid JDK installation.</span></span><br></pre></td></tr></table></figure><p>环境变量中配置JAVA_HOME 指向jdk所在目录，path中加入%JAVA_HOME%\bin </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。&lt;br&gt;这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。&lt;/p&gt;
    
    </summary>
    
      <category term="打包" scheme="http://www.zydeveloper.com/categories/%E6%89%93%E5%8C%85/"/>
    
    
      <category term="多渠道打包" scheme="http://www.zydeveloper.com/tags/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>帧动画和补间动画</title>
    <link href="http://www.zydeveloper.com/2019/08/08/Animation1/"/>
    <id>http://www.zydeveloper.com/2019/08/08/Animation1/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-09-04T01:18:57.145Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="动画" scheme="http://www.zydeveloper.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>属性动画</title>
    <link href="http://www.zydeveloper.com/2019/08/08/Animation2/"/>
    <id>http://www.zydeveloper.com/2019/08/08/Animation2/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:45:32.038Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="动画" scheme="http://www.zydeveloper.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>自实现页面注解框架</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomAnnFramwork/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomAnnFramwork/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T08:02:54.878Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事使用自定义注解+反射实现一个简单的页面注解框架，离项目中使用还有很大距离，纯属练习使用。</p><a id="more"></a><p>项目结构</p><img src="/2019/08/08/CustomAnnFramwork/2019-08-08-15-58-33.png"><p>页面应用</p><img src="/2019/08/08/CustomAnnFramwork/2019-08-08-15-59-01.png"><p>ContentView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ContentView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SuperEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuperEvent &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">listenerName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; listenerType();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费的事件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">callbackListenerName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OnClick</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary.annotation.eventannotation;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> com.baweigame.viewinjectlibrary.annotation.SuperEvent;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@SuperEvent</span>(listenerName = <span class="string">"setOnClickListener"</span>,listenerType = View.OnClickListener.class,callbackListenerName = <span class="string">"onClick"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OnClick &#123;</span><br><span class="line">    <span class="keyword">int</span>[] values();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.RequiresApi;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> com.baweigame.viewinjectlibrary.annotation.ContentView;</span><br><span class="line"><span class="keyword">import</span> com.baweigame.viewinjectlibrary.annotation.InjectView;</span><br><span class="line"><span class="keyword">import</span> com.baweigame.viewinjectlibrary.annotation.SuperEvent;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InjectManager instance=<span class="keyword">new</span> InjectManager();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InjectManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjectManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.KITKAT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectActivity</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        injectLayout(activity);</span><br><span class="line">        injectViews(activity);</span><br><span class="line">        injectEvents(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册activity布局</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectLayout</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; clazz = activity.getClass();</span><br><span class="line">        ContentView contentView = clazz.getAnnotation(ContentView.class);</span><br><span class="line">        <span class="keyword">if</span> (contentView!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> layoutId=contentView.value();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method setContentView = clazz.getMethod(<span class="string">"setContentView"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                setContentView.invoke(activity,layoutId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectViews</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; clazz = activity.getClass();</span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:</span><br><span class="line">             fields) &#123;</span><br><span class="line">            InjectView injectView = field.getAnnotation(InjectView.class);</span><br><span class="line">            <span class="keyword">if</span> (injectView!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> viewId=injectView.value();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Method fvbMethod = clazz.getMethod(<span class="string">"findViewById"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                    Object obj = fvbMethod.invoke(activity, viewId);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(activity,obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.KITKAT)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectEvents</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; clazz = activity.getClass();</span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            Annotation[] annotations = method.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">                Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span><br><span class="line">                <span class="keyword">if</span> (annotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    SuperEvent eventBase = annotationType.getAnnotation(SuperEvent.class);</span><br><span class="line">                    <span class="keyword">if</span> (eventBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        String listenerSetter = eventBase.listenerName();</span><br><span class="line">                        Class&lt;?&gt; listenerType = eventBase.listenerType();</span><br><span class="line">                        String callBackListener = eventBase.callbackListenerName();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Method valueMethod = annotationType.getDeclaredMethod(<span class="string">"values"</span>);</span><br><span class="line">                            <span class="keyword">int</span>[] viewIds = (<span class="keyword">int</span>[]) valueMethod.invoke(annotation);</span><br><span class="line">                            ListenerInvocationHandler handler = <span class="keyword">new</span> ListenerInvocationHandler(activity);</span><br><span class="line">                            handler.addMethod(callBackListener, method);</span><br><span class="line">                            Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(),</span><br><span class="line">                                    <span class="keyword">new</span> Class[]&#123;listenerType&#125;, handler);</span><br><span class="line">                            <span class="comment">// 遍历注解的值</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> viewId : viewIds) &#123;</span><br><span class="line">                                View view = activity.findViewById(viewId);</span><br><span class="line">                                Method setter = view.getClass().getMethod(listenerSetter, listenerType);</span><br><span class="line">                                setter.invoke(view, listener);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenerInvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baweigame.viewinjectlibrary;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要拦截的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 需要拦截的对象键值对</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Method&gt; methodHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//method 等于拦截的onclick</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取需要拦截的方法名</span></span><br><span class="line">            String methodName = method.getName(); <span class="comment">// 假如是onClick</span></span><br><span class="line">            <span class="comment">// 重新赋值</span></span><br><span class="line">            method = methodHashMap.get(methodName); <span class="comment">// 执行拦截的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将需要拦截的方法添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 需要拦截的方法，如：onClick()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 执行拦截后的方法，如：show()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">(String methodName, Method method)</span> </span>&#123;</span><br><span class="line">        methodHashMap.put(methodName, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲来无事使用自定义注解+反射实现一个简单的页面注解框架，离项目中使用还有很大距离，纯属练习使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Android第三方框架" scheme="http://www.zydeveloper.com/categories/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://www.zydeveloper.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="页面框架" scheme="http://www.zydeveloper.com/tags/%E9%A1%B5%E9%9D%A2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>自定义View使用</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomView1/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomView1/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:47:51.204Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="自定义View" scheme="http://www.zydeveloper.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>组合View和自定义属性</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomView2/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomView2/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:48:59.484Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="自定义View" scheme="http://www.zydeveloper.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>自定义View绘制一些基本图形</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomView3/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomView3/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:50:09.265Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="自定义View" scheme="http://www.zydeveloper.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>事件分发</title>
    <link href="http://www.zydeveloper.com/2019/08/08/Event/"/>
    <id>http://www.zydeveloper.com/2019/08/08/Event/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:46:40.699Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="事件" scheme="http://www.zydeveloper.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>AutoDispose 解决RxJava内存泄漏问题</title>
    <link href="http://www.zydeveloper.com/2019/08/05/AutoDispose/"/>
    <id>http://www.zydeveloper.com/2019/08/05/AutoDispose/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-09T06:07:18.452Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/uber/AutoDispose" target="_blank" rel="noopener">Auto Dispose GitHub地址</a></p><p>前一篇我们介绍了RxLifecycle解决Rxjava可能发生的内存泄漏问题：</p><p><a href="http://www.zydeveloper.com/2019/08/05/RxLifecycle/">RxLifecycle 解决RxJava内存泄漏问题</a></p><p>AutoDispose是一个RxJava2工具，用于解决Rxjava内存泄漏问题。</p><a id="more"></a><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h3><p>导入依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.uber.autodispose:autodispose-android-archcomponents:1.3.0'</span></span><br></pre></td></tr></table></figure><p>手写一个RxJava的内存泄漏问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">"123"</span>, <span class="string">"onNext: "</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Log.d(<span class="string">"123"</span>, <span class="string">"onComplete: "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码我们在前一篇文章中已经验证了存在内存泄漏问题，即点击back键后onNext仍然被回调，log一直持续输出。</p><p>下面我们通过使用AutoDispose来修复Rxjava内存泄漏问题。</p><p>修改代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">               .subscribeOn(Schedulers.io())</span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(<span class="keyword">this</span>)))</span><br><span class="line">               .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"123"</span>, <span class="string">"onNext: "</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       Log.d(<span class="string">"123"</span>, <span class="string">"onComplete: "</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>我们发现加入了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(<span class="keyword">this</span>)))</span><br></pre></td></tr></table></figure><p>运行项目后，再次验证是否还存在内存泄漏。<br>查看log输出：<br><img src="/2019/08/05/AutoDispose/2019-08-07-17-03-58.png"><br>我们发现onNext不再被回调。</p><p>我们来看看AndroidLifecycleScopeProvider.from 传入的参数为LifecycleOwner类型。该类型是Android中的生命周期类型，也就说实现了该接口的Activity及Fragment都可以使用AutoDispose。</p><p>注：</p><p>集成AutoDispose后如出现如下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Invoke-<span class="function">customs are only supported starting with Android <span class="title">O</span> <span class="params">(--min-api <span class="number">26</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>解决方法:</strong></p><p>app 的 build.gradle中android下加入如下配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">        compileOptions&#123;</span><br><span class="line">            sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">            targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/uber/AutoDispose&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Auto Dispose GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前一篇我们介绍了RxLifecycle解决Rxjava可能发生的内存泄漏问题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zydeveloper.com/2019/08/05/RxLifecycle/&quot;&gt;RxLifecycle 解决RxJava内存泄漏问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AutoDispose是一个RxJava2工具，用于解决Rxjava内存泄漏问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Android第三方框架" scheme="http://www.zydeveloper.com/categories/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://www.zydeveloper.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="AutoDispose" scheme="http://www.zydeveloper.com/tags/AutoDispose/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符</title>
    <link href="http://www.zydeveloper.com/2019/08/05/RxJava2/"/>
    <id>http://www.zydeveloper.com/2019/08/05/RxJava2/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-08T07:02:08.926Z</updated>
    
    <content type="html"><![CDATA[<p>借用网上一仁兄博客,讲的很全面：</p><h4 id="《RxJava操作符汇总》"><a href="#《RxJava操作符汇总》" class="headerlink" title="《RxJava操作符汇总》"></a><a href="https://blog.csdn.net/zengke1993/article/details/80388510" target="_blank" rel="noopener">《RxJava操作符汇总》</a></h4><a id="more"></a><img src="/2019/08/05/RxJava2/2019-08-05-17-14-52.png"><hr><img src="/2019/08/05/RxJava2/2019-08-05-17-15-03.png"><hr><img src="/2019/08/05/RxJava2/2019-08-05-17-15-10.png"><hr><img src="/2019/08/05/RxJava2/2019-08-05-17-15-19.png"><hr><img src="/2019/08/05/RxJava2/2019-08-05-17-15-27.png"><p>参考链接地址：</p><p><a href="https://blog.csdn.net/zengke1993/article/details/80388673" target="_blank" rel="noopener">RxJava操作符（一） —-创建操作符</a><br><a href="https://blog.csdn.net/zengke1993/article/details/80389262" target="_blank" rel="noopener">RxJava操作符（二）—-转换操作符</a><br><a href="https://blog.csdn.net/zengke1993/article/details/80389852" target="_blank" rel="noopener">RxJava操作符（三）—-合并操作符</a><br><a href="https://blog.csdn.net/zengke1993/article/details/80391719" target="_blank" rel="noopener">RxJava操作符（四）—-功能操作符</a><br><a href="https://blog.csdn.net/zengke1993/article/details/80392508" target="_blank" rel="noopener">RxJava操作符（五） —-过滤操作符</a><br><a href="https://blog.csdn.net/zengke1993/article/details/80394003?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">RxJava操作符（六）—-条件操作符</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借用网上一仁兄博客,讲的很全面：&lt;/p&gt;
&lt;h4 id=&quot;《RxJava操作符汇总》&quot;&gt;&lt;a href=&quot;#《RxJava操作符汇总》&quot; class=&quot;headerlink&quot; title=&quot;《RxJava操作符汇总》&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/zengke1993/article/details/80388510&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《RxJava操作符汇总》&lt;/a&gt;&lt;/h4&gt;
    
    </summary>
    
      <category term="Android第三方框架" scheme="http://www.zydeveloper.com/categories/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://www.zydeveloper.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxJava" scheme="http://www.zydeveloper.com/tags/RxJava/"/>
    
  </entry>
  
</feed>

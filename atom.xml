<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个老程序猿</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zydeveloper.com/"/>
  <updated>2020-03-21T14:26:41.174Z</updated>
  <id>http://www.zydeveloper.com/</id>
  
  <author>
    <name>Zhangyue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus原理及源码分析</title>
    <link href="http://www.zydeveloper.com/2020/03/21/eventbussource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/eventbussource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:26:41.174Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus原理及源码分析</p><a id="more"></a><h1 id="EventBus原理及源码分析"><a href="#EventBus原理及源码分析" class="headerlink" title="EventBus原理及源码分析"></a>EventBus原理及源码分析</h1><h2 id="一个Demo"><a href="#一个Demo" class="headerlink" title="一个Demo"></a>一个Demo</h2><h3 id="Demo1-普通事件的发布-接收"><a href="#Demo1-普通事件的发布-接收" class="headerlink" title="Demo1 普通事件的发布/接收"></a>Demo1 普通事件的发布/接收</h3><p>普通消息的发布：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 发送普通事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      btnEventbusSend.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//发布一个普通的事件</span></span><br><span class="line">              EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"我是一条普通的消息..."</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>普通消息的接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onStart();</span><br><span class="line">       <span class="keyword">if</span> (!EventBus.getDefault().isRegistered(<span class="keyword">this</span>))&#123;</span><br><span class="line">           <span class="comment">//注册</span></span><br><span class="line">           EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       <span class="keyword">if</span> (EventBus.getDefault().isRegistered(<span class="keyword">this</span>))&#123;</span><br><span class="line">           注销</span><br><span class="line">           EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//订阅方法 MessageEvent-事件类型</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetMessage</span><span class="params">(MessageEvent messageEvent)</span></span>&#123;</span><br><span class="line">       tvEventbusContent.setText(messageEvent.getContent());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Demo2-粘性事件发布-接收"><a href="#Demo2-粘性事件发布-接收" class="headerlink" title="Demo2 粘性事件发布/接收"></a>Demo2 粘性事件发布/接收</h3><p>粘性事件发布：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 发送粘性事件</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      btnEventbusSendSticky.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//发布粘性事件</span></span><br><span class="line">              EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"我是一条粘性的消息..."</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>粘性事件的接收：</p><p>与上面注册/注销代码相同，这里不再展示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING,sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetMessage</span><span class="params">(MessageEvent messageEvent)</span></span>&#123;</span><br><span class="line">    tvEventbusStickyContent.setText(messageEvent.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode"><a href="#ThreadMode" class="headerlink" title="ThreadMode"></a>ThreadMode</h3><p><strong>ThreadMode</strong>枚举的几种方式：</p><ul><li>POSTING——发布者在哪个线程  订阅者就与发布者在同一个线程</li><li>MAIN——发布者不管在哪个线程 订阅者都在主线程</li><li>MAIN_ORDERED——与MAIN一样，不同之处是采用了队列（queue）会有顺序</li><li>BACKGROUND——发布者如果在主线程订阅者开辟新线程接收，发布者在子线程订阅者及在发布者所在线程（等同于POSTING）</li><li>ASYNC——发布者不管在哪个线程，订阅者都开辟新线程订阅</li></ul><h3 id="EventBus的实例创建"><a href="#EventBus的实例创建" class="headerlink" title="EventBus的实例创建"></a>EventBus的实例创建</h3><h4 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//典型的单例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用new EventBus()来创建的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了this（EvnetBus）传入了DEFAULT_BUILDER，先来看一下this（DEFAULT_BUILDER）方法细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        logger = builder.getLogger();</span><br><span class="line">        subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">        mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">        backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">        asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">        indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">        subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">        eventInheritance = builder.eventInheritance;</span><br><span class="line">        executorService = builder.executorService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和其他很多的框架一样，使用Builder来给EventBus相关属性进行赋值。</p><p><strong>DEFAULT_BUILDER</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line">EventBusBuilder() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面方法我们发现直接使用的EventBusBuilder的默认设置。</p><h4 id="拓展EvnetBus的几种实例创建方式"><a href="#拓展EvnetBus的几种实例创建方式" class="headerlink" title="拓展EvnetBus的几种实例创建方式"></a>拓展EvnetBus的几种实例创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局只有一个当前的EventBus实例 </span></span><br><span class="line">EventBus.getDefault();</span><br><span class="line"><span class="comment">//可以new 出来多个实例</span></span><br><span class="line"><span class="keyword">new</span> EventBus();</span><br><span class="line"><span class="comment">//典型的建造者模式，可以不断的持续构建</span></span><br><span class="line">EventBus.builder().build();</span><br></pre></td></tr></table></figure><h3 id="EventBus的register"><a href="#EventBus的register" class="headerlink" title="EventBus的register"></a>EventBus的register</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);<span class="comment">//这里的this就是当前activity的实例,被EventBus作为订阅者传入到EventBus中</span></span><br></pre></td></tr></table></figure><p>如下 register方法的详细代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers the given subscriber to receive events. Subscribers must call &#123;<span class="doctag">@link</span> #unregister(Object)&#125; once they</span></span><br><span class="line"><span class="comment"> * are no longer interested in receiving events.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * Subscribers have event handling methods that must be annotated by &#123;<span class="doctag">@link</span> Subscribe&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> Subscribe&#125; annotation also allows configuration like &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * ThreadMode&#125; and priority.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到入口参数的类型</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">//通过上面的类型subscriberClass找到其中的订阅方法进一步封装成SubscriberMethod对象</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是根据如上Demo1中逻辑，Debug后获取到的subscriberMethods集合细节</p><p><img src="/2020/03/21/eventbussource1/C:%5CUsers%5Czhangyue%5CDesktop%5C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5Cimgs%5CQQ%E6%88%AA%E5%9B%BE20200228135132.png" alt></p><p>我们发现在EventBusDemoActivity中我们实现了一个带@Subsribe注解的方法，然后subscriberMethods集合中出现了1个对象就是我们代码的对应方法。</p><h4 id="findSubscriberMethods"><a href="#findSubscriberMethods" class="headerlink" title="findSubscriberMethods"></a>findSubscriberMethods</h4><p>SubscriberMethodFinder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//从缓存中获取key为subscriberClass的对应value（ List&lt;SubscriberMethod&gt;），METHOD_CACHE的属性定义如下</span></span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="comment">//如果subscriberMethods不为空直接返回该对象</span></span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果缓存中没有对应的value就继续向下执行</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//我们使用getDefault单例创建的EventBus实例从而就使用的ignoreGeneratedIndex的默认值也就false 参见：EventBusBuilder -&gt; boolean ignoreGeneratedIndex;</span></span><br><span class="line">       <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">           subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//使用反射来获取subscriberMethods</span></span><br><span class="line">           subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果subscriberMethods是empty的则直接抛异常</span></span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                   + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//存入缓存中然后返回对应的subscriberMethods结果</span></span><br><span class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如下是<strong>METHOD_CACHE</strong>的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h5 id="findUsingInfo"><a href="#findUsingInfo" class="headerlink" title="findUsingInfo"></a>findUsingInfo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建或者从缓存数组中获取FindState对象，参见下方代码</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        <span class="comment">//将订阅者（Demo1 - activity）赋值给findState属性</span></span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        <span class="comment">//initForSubscriber方法核心逻辑如下代码</span></span><br><span class="line">        <span class="comment">//this.subscriberClass = clazz = subscriberClass;</span></span><br><span class="line">        <span class="comment">//clazz就一点不为空</span></span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取定义者的信息：逻辑如果自己没有订阅者信息就查找父类 直到找到为止</span></span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            <span class="comment">//第一次一定为空</span></span><br><span class="line">            <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//找到subscriberInfo的订阅方法数组</span></span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                <span class="comment">//迭代数组</span></span><br><span class="line">                <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//使用反射获取并构建SubscriberMethod的相关信息</span></span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进一步查找分析父类</span></span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//从findState实体中获取subscriberMethods 赋值给新的ArrayList对象返回 并释放findState（对象的所有属性清空）达到对象池的效果</span></span><br><span class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="prepareFindState"><a href="#prepareFindState" class="headerlink" title="prepareFindState"></a>prepareFindState</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//FindState缓存数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FindState[] FIND_STATE_POOL = <span class="keyword">new</span> FindState[POOL_SIZE]; </span><br><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">            <span class="comment">//如果数组中有该对象就直接复用并清空对应数组下标位置对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                FindState state = FIND_STATE_POOL[i];</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中没有就new创建FindSate对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="findUsingReflectionInSingleClass"><a href="#findUsingReflectionInSingleClass" class="headerlink" title="findUsingReflectionInSingleClass"></a>findUsingReflectionInSingleClass</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">       Method[] methods;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">           <span class="comment">//获取订阅者的所有方法（当前的就是Demo1的activity）</span></span><br><span class="line">           methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">           <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">           methods = findState.clazz.getMethods();</span><br><span class="line">           findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历得到的方法数组</span></span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">           <span class="comment">//获取到方法的访问修饰符</span></span><br><span class="line">           <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">           <span class="comment">//判断方法必须为public并且不能使用为如下情况</span></span><br><span class="line">           <span class="comment">//private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</span></span><br><span class="line">           <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//获取到方法的所有参数类型</span></span><br><span class="line">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">               <span class="comment">//如果方法参数个数是1 进入if&#123;&#125;逻辑</span></span><br><span class="line">               <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">//获取有Subscribe注解修饰的方法</span></span><br><span class="line">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                   <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//使用第一个参数作为事件类型使用</span></span><br><span class="line">                       Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                       <span class="comment">//该方法参见下面分析 传入的是当前Method还有第一个参数类型（eventType）</span></span><br><span class="line">                       <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                           <span class="comment">//从我们自定义的订阅方法注解中获取thradMode</span></span><br><span class="line">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                           <span class="comment">//创建一个SubscriberMethod对象（将订阅方法的所有细节都设置到SubscriberMethod中去），赋值给findState中ArrayList（subscriberMethods）</span></span><br><span class="line">                           findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">//如果参数个数不为1直接抛异常</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                   String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                           <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">//如果方法不是public或者使用了static abstract 则抛出异常</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">               String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                       <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="checkAdd"><a href="#checkAdd" class="headerlink" title="checkAdd"></a>checkAdd</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></span><br><span class="line">           <span class="comment">// Usually a subscriber doesn't have methods listening to the same event type.</span></span><br><span class="line">    <span class="comment">//向Map中 存储key - eventType（MessageEvent） Value - method（onGetMessage方法）</span></span><br><span class="line">           Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="comment">//判断返回的value是否为null 当前put返回的value(existing)为空 所以直接返回了 </span></span><br><span class="line">           <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//判断values是否是Method的实例 如上代码一定是</span></span><br><span class="line">               <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                       <span class="comment">// Paranoia check</span></span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">                   anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h4><p>截取如上的引用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~register 方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                <span class="comment">//调用subscribe方法并传入 subscriber -&gt; 当前activity对象 subscriberMethod -&gt;当前遍历的subscriberMethod</span></span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>EventBus下三个数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//key为EventType  value为Subscription集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">//key为订阅者 value所有的事件集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="comment">//key为EventType的类型，value为EventType的实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br></pre></td></tr></table></figure><p>三个数据结构创建是在EventBus的getDefault中：</p><img src="/2020/03/21/eventbussource1/2020-03-21-22-26-18.png "><p><strong><em>subscribe</em></strong>代码如下（对如上3个数据结构进行赋值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line"><span class="comment">//订阅方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取subscriberMethod的事件类型</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">//通过订阅者和订阅方法来构建Subscription实例</span></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">//从subscriptionsByEventType map中获取subscriptions集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="comment">//获取到的集合为空 创建并添加到subscriptionsByEventType map中</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不为空</span></span><br><span class="line">        <span class="comment">//判断subscriptions中是否已经存在了newSubscription 如果存在直接抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取subscriptions大小</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="comment">//判断subscriberMethod优先级处理</span></span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从typesBySubscriber map中获取事件类型S</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="comment">//等于null 初始化ArrayList 并存入typesBySubscriber Map中</span></span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//subscribedEvents添加当前eventType</span></span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//粘性事件的处理</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从stickyEvents map中获取stickyEvent</span></span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">//检查stickyEvent是否为空，不为空发送事件并携带Subscription</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">            <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">            <span class="comment">//参见Post讲解</span></span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="EventBus的unregister"><a href="#EventBus的unregister" class="headerlink" title="EventBus的unregister"></a>EventBus的unregister</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>unregister放到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//从typesBySubscriber map中根据传入订阅者获取对应的事件类型集合</span></span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="comment">//如果不等于null</span></span><br><span class="line">       <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//迭代该集合</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">               <span class="comment">//从subscriptionsByEventType map中移除key是eventtype的数据</span></span><br><span class="line">               unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从typesBySubscriber中移除掉key是subscriber数据</span></span><br><span class="line">           typesBySubscriber.remove(subscriber);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果为空记录warning级别log</span></span><br><span class="line">           logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>unsubscribeByEventType代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">       List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">               Subscription subscription = subscriptions.get(i);</span><br><span class="line">               <span class="comment">//判断subscription的订阅者等于入口传入进来的订阅者</span></span><br><span class="line">               <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                   subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                   subscriptions.remove(i);</span><br><span class="line">                   i--;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="isRegistered"><a href="#isRegistered" class="headerlink" title="isRegistered"></a>isRegistered</h4><p>该方法是用于判断是否注册</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从typesBySubscriber里判断是否包括key为subscriber的数据</span></span><br><span class="line">    <span class="keyword">return</span> typesBySubscriber.containsKey(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventBus的post"><a href="#EventBus的post" class="headerlink" title="EventBus的post"></a>EventBus的post</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//从currentPostingThreadState （从当前线程的ThreadLocal中）获取postingState</span></span><br><span class="line">      PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">      <span class="comment">//从postingState中获取eventQueue 其实eventQueue是一个ArrayList</span></span><br><span class="line">      List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">      <span class="comment">//将外面传入的自定义事件实体加入到集合中</span></span><br><span class="line">      eventQueue.add(event);</span><br><span class="line"><span class="comment">//如果事件没有被发送</span></span><br><span class="line">      <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">          <span class="comment">//是否是主线程</span></span><br><span class="line">          postingState.isMainThread = isMainThread();</span><br><span class="line">          <span class="comment">//设置isPosting等true 默认是false</span></span><br><span class="line">          postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//判断是否已经取消如果已经取消直接抛出异常</span></span><br><span class="line">          <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//迭代事件队列</span></span><br><span class="line">              <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                  <span class="comment">//执行如下方法，第一个参数eventQueue.remove(0) 相当于取出索引为0的数据并删除</span></span><br><span class="line">                  postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">              postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="postSingleEvent"><a href="#postSingleEvent" class="headerlink" title="postSingleEvent"></a>postSingleEvent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    <span class="comment">//获取事件的类型</span></span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">                logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="postSingleEventForEventType"><a href="#postSingleEventForEventType" class="headerlink" title="postSingleEventForEventType"></a>postSingleEventForEventType</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//更加当前的事件类型从subscriptionsByEventType map中获取subscriptions</span></span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断subscriptions是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123; <span class="comment">//不为空</span></span><br><span class="line">            <span class="comment">//迭代集合</span></span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                <span class="comment">//将传入的event实例赋值给postingState的event属性</span></span><br><span class="line">                postingState.event = event;</span><br><span class="line">                <span class="comment">//将当前的subscription赋值给postingState.subscription</span></span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="comment">//设置退出标记默认为false</span></span><br><span class="line">                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用如下方式传入subscription 事件实体 postingState 是否主线程的boolean值</span></span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    <span class="comment">//根据postingState.canceled;设置退出标记</span></span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果退出标记为true直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="postToSubscription"><a href="#postToSubscription" class="headerlink" title="postToSubscription"></a>postToSubscription</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是哪一种线程模型</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">//如果是主线程直接调用invokeSubscriber</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是子线程 使用mainThreadPoster（mainThreadPoster是HandlerPoster实例），其实enqueue操作就是使用Handler来进行线程的切换 （子线程中sendMessage 其实就是发送到 Handler handleMessage中，然后调用了eventBus.invokeSubscriber(pendingPost);）</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">//如是主线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                <span class="comment">//使用backgroundPoster（backgroundPoster其实实现了Runnable接口）在run方法中执行了eventBus.invokeSubscriber(pendingPost);</span></span><br><span class="line">                <span class="comment">//其实线程都是通过线程池来启动的eventBus.getExecutorService().execute(this);</span></span><br><span class="line">                <span class="comment">//eventBus中的ExecutorService默认的其实是Executors.newCachedThreadPool();当然你也可以自己定义通过EvnetBus的Builder（）</span></span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//因为当前执行这段代码的线程是子线程所以invokeSubscriber就在子线程执行</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">//使用asyncPoster（asyncPoster其实实现Runnable接口），在run方法中执行eventBus.getExecutorService().execute(this);</span></span><br><span class="line">            <span class="comment">//其实线程都是通过线程池来启动的eventBus.getExecutorService().execute(this);</span></span><br><span class="line">            <span class="comment">//eventBus中的ExecutorService默认的其实是Executors.newCachedThreadPool();当然你也可以自己定义通过EvnetBus的Builder（）</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invokeSubscriber"><a href="#invokeSubscriber" class="headerlink" title="invokeSubscriber"></a>invokeSubscriber</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//此处就是利用了反射来执行我们Demo中标注为Subscribe的具体方法并传入相关参数</span></span><br><span class="line">           subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上即分析完了我们使用的EventBus发送事件的详细逻辑及代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus原理及源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Handler原理及源码分析（上）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/handlersource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/handlersource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:03:35.635Z</updated>
    
    <content type="html"><![CDATA[<p>Handler原理及源码分析（上）</p><a id="more"></a><h3 id="Handler原理及源码分析（上）"><a href="#Handler原理及源码分析（上）" class="headerlink" title="Handler原理及源码分析（上）"></a>Handler原理及源码分析（上）</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>如下是演示Demo，后续我将使用这个Demo来对Handler进行原理分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">btnHandlerDemoDo.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//启动了子线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//模拟耗时操作 睡了2s</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建Message对象</span></span><br><span class="line">Message message=Message.obtain();<span class="comment">//new Message();</span></span><br><span class="line">message.what=DemoFlag1;</span><br><span class="line">message.arg1=<span class="number">11</span>;</span><br><span class="line">message.arg2=<span class="number">22</span>;</span><br><span class="line">message.obj=<span class="keyword">new</span> Object();<span class="comment">// message.sendToTarget();</span></span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"threadname: "</span>+Thread.currentThread().getName());</span><br><span class="line"><span class="comment">//使用Handler发送Message</span></span><br><span class="line">mHandler.sendMessage(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DemoFlag1=<span class="number">1</span>;<span class="keyword">private</span> Handler mHandler=<span class="keyword">new</span> Handler()&#123;</span><br><span class="line"><span class="comment">//处理发送过来Message</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"><span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line"><span class="keyword">case</span> DemoFlag1:</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"handleMessage: [DemoFlag1]"</span>);</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"hm thread name: "</span>+Thread.currentThread().getName());</span><br><span class="line">tvHandlerDemoContent.setText(<span class="string">"handleMessage: [DemoFlag1]"</span>);</span><br><span class="line"><span class="comment">//tvHandlerDemoContent.setVisibility(View.VISIBLE);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><p>如上Demo代码演示了一个Handler很经典的使用场景，子线程发请求响应结果来更新UI。<br>然后下面我们先来关注两个问题：</p><h4 id="子线程中能否创建Handler？"><a href="#子线程中能否创建Handler？" class="headerlink" title="子线程中能否创建Handler？"></a>子线程中能否创建Handler？</h4><p>答案是肯定的，一定可以创建不过需要一个先决条件-&gt;指定Looper，下面示例代码演示了具体实现过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该位置我们指定了LooperLooper.prepare();Handler handler=new Handler()&#123;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"><span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Log.d(<span class="string">"123"</span>, <span class="string">"handleMessage: 00000"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line">handler.sendEmptyMessage(<span class="number">0</span>);Looper.loop();</span><br></pre></td></tr></table></figure><h4 id="主线程Handler为什么不用Looper-prepare"><a href="#主线程Handler为什么不用Looper-prepare" class="headerlink" title="主线程Handler为什么不用Looper.prepare()?"></a>主线程Handler为什么不用Looper.prepare()?</h4><p>这个问题我们就要分析一下Android源码，其中大家都知道ActivityThread（后面简称AT）是我们的“主线程”，其实AT并不是一个真实的线程，它只是一个final的class并没有继承或者实现任何与线程相关的类或接口。<br>之所以称它为主线程可能是因为这个类似android中唯一使用main函数加载启动并且是zygote fock完进程之后就直接加载的类。<br>下面我们来看一下具体的main函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">.........</span><br><span class="line"><span class="comment">//出现了Looper.prepare</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line"><span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line"><span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line"><span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">startSeq = Long.parseLong(</span><br><span class="line">args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"><span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">sMainThreadHandler = thread.getHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//Looper.loop</span></span><br><span class="line">Looper.loop();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可见我们在ActivityThread的main函数中发现了Looper已经关联好了，具体见如上注释部分。</p><p>我们都知道Handler一般是由4部分组成：<br>1 Message<br>2 MessageQueue<br>3 Looper<br>4 Handler</p><h4 id="首先我们来看看Message"><a href="#首先我们来看看Message" class="headerlink" title="首先我们来看看Message"></a>首先我们来看看Message</h4><p>如下是Message类的定义 很简单 final 实现 Parcelable序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* User-defined message code so that the recipient can identify</span></span><br><span class="line"><span class="comment">* what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment">* for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment">* with other handlers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">* few integer values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">* few integer values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An arbitrary object to send to the recipient. When using</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Messenger&#125; to send the message across processes this can only</span></span><br><span class="line"><span class="comment">* be non-null if it contains a Parcelable of a framework class (not one</span></span><br><span class="line"><span class="comment">* implemented by the application). For other data transfer use</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that Parcelable objects here are not supported prior to</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#FROYO&#125; release.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br></pre></td></tr></table></figure><p>如上这几个属性是我们使用Message时比较常用的，很简单这边就不再解释。<br><img src="/2020/03/21/handlersource1/2020-03-21-22-01-31.png"><br>如上我们看到的是Message的obtain方法各种重载。下面来看看obtain（）方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">Message m = sPool;</span><br><span class="line">sPool = m.next;</span><br><span class="line">m.next = <span class="keyword">null</span>;</span><br><span class="line">m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法可以看出obtain是对Message的一个复用，即先看sPool中是否存在如果存在则复用，否则new一个Message实例返回。<br>其他的方法重载就是一些属性赋值操作这里不再阐述。</p><h5 id="下面来看看Message的target属性同时关注一些message的sendToTarget（）方法"><a href="#下面来看看Message的target属性同时关注一些message的sendToTarget（）方法" class="headerlink" title="下面来看看Message的target属性同时关注一些message的sendToTarget（）方法"></a>下面来看看Message的target属性同时关注一些message的sendToTarget（）方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br></pre></td></tr></table></figure><p>如上市target的定义，我们发现其实target是一个Handler，这个Handler可以通过如下方法进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;</span><br><span class="line">Message m = obtain();</span><br><span class="line">...</span><br><span class="line">m.target = orig.target;</span><br><span class="line">m.callback = orig.callback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line"><span class="comment">//以及obtain的其他方法重载，具体可以参加源码部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看message的sendToTarget方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span></span><br><span class="line"><span class="comment">* Throws a null pointer exception if this field has not been set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">target.sendMessage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最终调用的还是Handler的sendMessage方法（因为target就是Hander对象）。</p><h5 id="Message中还有data与callback属性"><a href="#Message中还有data与callback属性" class="headerlink" title="Message中还有data与callback属性"></a>Message中还有data与callback属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> Bundle data;<span class="comment">/*package*/</span> Runnable callback;</span><br></pre></td></tr></table></figure><p>我们发现data是Bundle类型，其中可以putXX数据。<br>callback在Message中进行了赋值也就是“setCallback”。</p><h5 id="下面我们来看看Message的复用是怎么处理的"><a href="#下面我们来看看Message的复用是怎么处理的" class="headerlink" title="下面我们来看看Message的复用是怎么处理的"></a>下面我们来看看Message的复用是怎么处理的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//提供给我们同步关键字使用的锁对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//缓存对象池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="comment">//当前对象池中的计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对象池最大缓存大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>如上属性是对Message的复用做设置的，具体使用我们来看一下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="comment">//首先判断sPool是否为空</span></span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//不为空将sPool赋值给m</span></span><br><span class="line">Message m = sPool;</span><br><span class="line"><span class="comment">//将m（也就是之前的sPool）的next对象给sPool</span></span><br><span class="line">sPool = m.next;</span><br><span class="line"><span class="comment">//将next清空</span></span><br><span class="line">m.next = <span class="keyword">null</span>;</span><br><span class="line">m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line"><span class="comment">//计数器减1</span></span><br><span class="line">sPoolSize--;</span><br><span class="line"><span class="comment">//返回复用的对象</span></span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果sPool为空则创建新Message对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现上面的sPool与next，但它们是在哪里赋值的呢？<br>我们可以参见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a Message instance to the global pool.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* You MUST NOT touch the Message after calling this function because it has</span></span><br><span class="line"><span class="comment">* effectively been freed. It is an error to recycle a message that is currently</span></span><br><span class="line"><span class="comment">* enqueued or that is in the process of being delivered to a Handler.</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment">* Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line"><span class="comment">// Clear out all other details.</span></span><br><span class="line"><span class="comment">//如下代码对Message的属性进行了还原即释放</span></span><br><span class="line">flags = FLAG_IN_USE;</span><br><span class="line">what = <span class="number">0</span>;</span><br><span class="line">arg1 = <span class="number">0</span>;</span><br><span class="line">arg2 = <span class="number">0</span>;</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">replyTo = <span class="keyword">null</span>;</span><br><span class="line">sendingUid = -<span class="number">1</span>;</span><br><span class="line">when = <span class="number">0</span>;</span><br><span class="line">target = <span class="keyword">null</span>;</span><br><span class="line">callback = <span class="keyword">null</span>;</span><br><span class="line">data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="comment">//判断当前计数器值是否大于限定的MAX_POOL_SIZE（也就是上面代码定义的50）</span></span><br><span class="line"><span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line"><span class="comment">//将sPool赋值给next</span></span><br><span class="line">next = sPool;</span><br><span class="line"><span class="comment">//将当前Message对象赋值给sPool</span></span><br><span class="line">sPool = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//计数器累加1</span></span><br><span class="line">sPoolSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现recycle（该方法调用时机我们后续再看）也就是释放方法中调用了recycleUnchecked方法，该方法对sPool sPoolSize next进行了处理，具体参见注释信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler原理及源码分析（上）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Handler原理及源码分析（下）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/handlersource2/"/>
    <id>http://www.zydeveloper.com/2020/03/21/handlersource2/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:14:27.344Z</updated>
    
    <content type="html"><![CDATA[<p>Handler原理及源码分析（下）</p><a id="more"></a><h1 id="Handler原理及源码分析（下）"><a href="#Handler原理及源码分析（下）" class="headerlink" title="Handler原理及源码分析（下）"></a>Handler原理及源码分析（下）</h1><h2 id="接下来跟踪mHandler-sendMessage-message"><a href="#接下来跟踪mHandler-sendMessage-message" class="headerlink" title="接下来跟踪mHandler.sendMessage(message);"></a>接下来跟踪mHandler.sendMessage(message);</h2><p><strong>sendMessage</strong> 就是Handler中发送消息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes a message onto the end of the message queue after all pending messages</span></span><br><span class="line"><span class="comment">     * before the current time. It will be received in &#123;<span class="doctag">@link</span> #handleMessage&#125;,</span></span><br><span class="line"><span class="comment">     * in the thread attached to this handler.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">     *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">     *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//调用如下方法 延时发送  注意一些延时毫秒数是0</span></span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment">     * before (current time + delayMillis). You will receive it in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">     *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">     *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment">     *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment">     *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment">     *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//判断如果传递进来的延时发送的long值小于0 就直接更改为0</span></span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//SystemClock.uptimeMillis() + delayMillis 系统时间加上延时毫秒数</span></span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * Time spent in deep sleep will add an additional delay to execution.</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关注mQueue（消息队列）赋值</span></span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mQueue在Handler中如何被赋值的"><a href="#mQueue在Handler中如何被赋值的" class="headerlink" title="mQueue在Handler中如何被赋值的"></a>mQueue在Handler中如何被赋值的</h3><p>我们在Demo中使用的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler=<span class="keyword">new</span> Handler()&#123;...&#125;</span><br></pre></td></tr></table></figure><p>来创建的主线程Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//我们发现mLooper是来源于Looper.myLooper();</span></span><br><span class="line">        <span class="comment">//myLooper其实就是我们ActivityThread main函数中  Looper.prepareMainLooper();</span></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mQueue 其实就是主线程的消息队列</span></span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="下面来分析一下Looper的获取与存入"><a href="#下面来分析一下Looper的获取与存入" class="headerlink" title="下面来分析一下Looper的获取与存入"></a>下面来分析一下Looper的获取与存入</h4><h5 id="mLooper-Looper-myLooper"><a href="#mLooper-Looper-myLooper" class="headerlink" title="mLooper = Looper.myLooper();"></a>mLooper = Looper.myLooper();</h5><p><strong>Looper.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从ThreadLocalMap中获取存入的Looper对象</span></span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sThreadLocal 是ThreadLocal其中value（T）类型是Looper</span></span><br><span class="line"><span class="comment">//关于ThreadLocal可以参见《ThreadLocal分析（全）》</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>如上代码分析了Looper.myLooper();最终获取到的是ThreadLocalMap中存入的Looper对象。</p><h5 id="那么Looper是什么时候被存入ThreadLocalMap的呢？"><a href="#那么Looper是什么时候被存入ThreadLocalMap的呢？" class="headerlink" title="那么Looper是什么时候被存入ThreadLocalMap的呢？"></a>那么Looper是什么时候被存入ThreadLocalMap的呢？</h5><p>我们知道在子线程或者主线程中都要使用<strong>Looper.prepare()/prepareMainLooper()</strong>,那么prepare究竟做了什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prepare(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果ThreadLocal.get()不等于null直接抛异常</span></span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//一个线程中只能有一个looper</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果为空，创建一个Looper的实例作为value存入ThreadLocalMap中。</span></span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程的Looper处理过程 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用的如上方法</span></span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="comment">//判断如果sMainLooper也就是主线程的Looper不为null直接抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将looper赋值给sMainLooper属性</span></span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="下面来分析一下mQueue-mLooper-mQueue"><a href="#下面来分析一下mQueue-mLooper-mQueue" class="headerlink" title="下面来分析一下mQueue = mLooper.mQueue;"></a>下面来分析一下mQueue = mLooper.mQueue;</h4><p>如上代码比较简单，直接是将Looper中的mQueue属性赋值给了Handler的mQueue属性。</p><p>下面我们来分析一下Looper中的mQueue是什么时候被创建的？</p><p>如上我们分析Looper.prepare()方法时，我们发现了创建Looper的代码，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果为空，创建一个Looper的实例作为value存入ThreadLocalMap中。</span></span><br><span class="line">sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br></pre></td></tr></table></figure><p>如上代码创建了Looper并执行了Looper（boolean quitAllowed）的构造方法，下面我们来看一下这个构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化了消息队列</span></span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    <span class="comment">//设置了Looper的mThread属性为当前线程</span></span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现消息队列是在<strong><em>Looper</em></strong>中初始化的，下面来看看MessageQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="comment">//处理消息队列中的消息，没有消息则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数比较简单</span></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是MessageQueue中的一些本地方法及构造函数</p><p>如下是MessageQueue的两个重要方法：</p><p>//向消息队列（实际是<strong>单向链表</strong>）中存入消息，调用位置：<strong><em>sendMessageAtTime</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">//存入数据</span></span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//取出并删除消息，调用位置：<strong><em>Looper.loop()</em></strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有消息则取出 没有则堵塞</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想next方法其实开启了死循环一直执行，其中的nativePollOnce方法是本地方法用于获取消息队列中的消息，没有消息则堵塞，这也是为什么Handler机制不耗性能及不会卡顿的关键（底层使用了pipe命名管道 及epoll I/O模型详细可以参见：<a href="https://www.jianshu.com/p/97e6e6c981b6" target="_blank" rel="noopener">Android 消息处理以及epoll机制</a>）</p><h4 id="下面来分析一下Looper-loop"><a href="#下面来分析一下Looper-loop" class="headerlink" title="下面来分析一下Looper.loop()"></a>下面来分析一下Looper.loop()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取线程上的Looper对象</span></span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="comment">//如果Looper对象me 为空则抛出异常信息，原因：没有调用Looper.prepare()</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从Looper上获取消息队列赋值给局部变量queue</span></span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启死循环提取消息</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//使用MessageQueue对象的next方法读取消息，详见如上对next的源码分析</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line"> <span class="comment">//分发的开始时间戳</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//分发的结束时间戳</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//分发消息</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="分析一下msg-target-dispatchMessage-msg"><a href="#分析一下msg-target-dispatchMessage-msg" class="headerlink" title="分析一下msg.target.dispatchMessage(msg);"></a>分析一下msg.target.dispatchMessage(msg);</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle system messages here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果msg对象的callback不为空，直接使用handleCallback(msg)</span></span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果handler的mCallback不为空的情况</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将消息msg交给mCallback处理，如果返回true直接return，如果返回了false继续向下执行也就是会执行到如下的Handler自己的handleMessage（msg）；方法</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Handler本身对分发过来的msg处理</span></span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果msg对象的callback不为空的情况，会执行如下方法，很简单：message的callback是Runnable，所以执行run方法就ok了 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>mCallback不为空的Demo代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler=<span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如下是Handler接口Callback的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上handleMesssage就是由我们开发人员自己实现的消息处理逻辑了。</p><p>上面所述就是Handler机制的核心原理及核心源码部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler原理及源码分析（下）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的原理及源码分析（上）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:39:51.340Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp的原理及源码分析（上）</p><a id="more"></a><p>注：我们的OkHttp源码分析是在3.12.0版本</p><p>如下是OkHttp的流程图（来源于网络）<br><img src="okhttpsource1/2020-03-21-21-35-41.png"></p><p>如下是我们经常使用的OkHttp的使用场景或者方法，下面我们用一个简单Get请求连进一步分析Okhttp的原理以及源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建OkHttpClient的实体对象  </span></span><br><span class="line"><span class="comment">//OkHttp给我提供两种创建OkHttpClient对象的方法</span></span><br><span class="line"><span class="comment">//一种是使用Builder.build（）典型建造者方式，可以不断的构建及丰富自己</span></span><br><span class="line"><span class="comment">//一种是直接new来创建，但是它是可以创建一个实例但是只能使用源码中的默认配置</span></span><br><span class="line">HttpLoggingInterceptor httpLoggingInterceptor=<span class="keyword">new</span> HttpLoggingInterceptor();</span><br><span class="line">        <span class="comment">//创建了一个http请求的日志拦截器</span></span><br><span class="line">        httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">        client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(httpLoggingInterceptor)</span><br><span class="line">                <span class="comment">//超时设置</span></span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//        client=new OkHttpClient();</span></span><br></pre></td></tr></table></figure><p>如下代码演示了一个Get请求使用同步方式获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//                                            Post请求时创建的RequestBody -&gt; FormBody   MultipartBody ContentTypeOverridingRequestBody（这是一个private）</span></span><br><span class="line"><span class="comment">//                        RequestBody requestBody=new FormBody.Builder()</span></span><br><span class="line"><span class="comment">//                                .add("","")</span></span><br><span class="line"><span class="comment">//                                .build();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                                         使用建造者模式来构建一个Request对象</span></span><br><span class="line">                        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                                .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">                                .get()</span><br><span class="line"><span class="comment">//                                .post(requestBody)</span></span><br><span class="line">                                .build();</span><br><span class="line"><span class="comment">//                        如下同步请求</span></span><br><span class="line"><span class="comment">//                        try &#123;</span></span><br><span class="line"><span class="comment">//                            Response response = client.newCall(request).execute();</span></span><br><span class="line"><span class="comment">//                            Log.d("123", "initData: "+response.body().string());</span></span><br><span class="line"><span class="comment">//                        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                                          如下异步请求</span></span><br><span class="line">                        client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                                Log.e(<span class="string">"123"</span>, <span class="string">"onFailure: "</span>+e.getLocalizedMessage() );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, <span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                                <span class="keyword">final</span> String msg=response.body().string();</span><br><span class="line">                                Log.d(<span class="string">"123"</span>, <span class="string">"initData: "</span>+msg);</span><br><span class="line">                                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        tvOkhttpContent.setText(msg);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br></pre></td></tr></table></figure><p>首先分享OkHttpClient的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(httpLoggingInterceptor)</span><br><span class="line">                <span class="comment">//超时设置</span></span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>Builder（）中代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分发器初始化</span></span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">  <span class="comment">//协议部分 </span></span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">  authenticator = Authenticator.NONE;</span><br><span class="line">  <span class="comment">//初始化了连接池</span></span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">  followRedirects = <span class="keyword">true</span>;</span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//超时设置</span></span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder（）中属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .readTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">  .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure><p>.build（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建了OkhttpClient对象并把Builder传递进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将Builder中设置属性直接给OkHttpClient对象赋值了 this-&gt;Builder实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们来分析Request的构建过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                                .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">                                .get()</span><br><span class="line">                                .build();</span><br></pre></td></tr></table></figure><p>Request.Builder() 设置了默认就是GET请求，所以上面.get（）可以不写。初始化了Headers.Builder().</p><img src="okhttpsource1/2020-03-21-21-37-20.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是将我们传递的String类型的Url转换为HttpUrl 并赋值</span></span><br><span class="line">.url(<span class="string">"https://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给method-&gt;"GET" requestBody进行了赋值 其中还包括对method的null 与 “”的判断  还有对requestBody的校验</span></span><br><span class="line">.get()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验url不可以为空 然后new 了Request对象并把Builder（）对象传递进去 Request中就是将Builder里面设置的属性赋值给Request中对应的属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是对Post请求的一些代码跟踪<br><img src="okhttpsource1/2020-03-21-21-38-01.png"></p><p>如下是requestBody的创建，同样这些核心的对象都是通过建造者模式创建的。<br><img src="okhttpsource1/2020-03-21-21-38-15.png"></p><p>RequestBody有如下三个子类：<br><img src="okhttpsource1/2020-03-21-21-38-30.png"><br>FormBody一般就是表单提交方式的Post<br>MultipartBody 一般文件上传/提交<br>…</p><p>FormBody.Builder()的源码如下：<br><img src="okhttpsource1/2020-03-21-21-38-51.png"><br>大家能看到Builder（）内部调用了一个构造重载函数，入口参数设置了null 该入口参数是字段字符编码。</p><p>接下来add方法，源码如下：<br><img src="okhttpsource1/2020-03-21-21-39-07.png"></p><p>这里值得我们注意的是 names  values 是两个ArrayList数据结构（不像我们平时经常使用的Map）。</p><p>如下是build（）的源码：<br><img src="okhttpsource1/2020-03-21-21-39-22.png"><br>我们发现创建了FormBody然后把上面的names values传递进去，然后给FormBody的对应属性赋值。<br>如上就是FormBody的构建构成。</p><p>接下来.post(requestBody)<br><img src="okhttpsource1/2020-03-21-21-39-40.png"><br>我们发现与GET请求调用了一样的方法 method（xx,xx）<br>入口参数 method 传递的是“POST”<br>第二个参数就是我们刚刚构建的FormBody实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp的原理及源码分析（上）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource3/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource3/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:58:05.709Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor</p><a id="more"></a><h3 id="ConnectInterceptor-链接拦截器"><a href="#ConnectInterceptor-链接拦截器" class="headerlink" title="ConnectInterceptor 链接拦截器"></a>ConnectInterceptor 链接拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="comment">//读取了StreamAllocation </span></span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//获取到我们使用的HttpCodec的实例 使用http 1.1版本协议 获取到的应该是Http1Codec实例</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//获取到RealConnection对象实例</span></span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line">    <span class="comment">//将获取到的这些业务实体对象传递给下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取并设置这些超时时间</span></span><br><span class="line">  <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">  <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">  <span class="comment">//是否开启链接失败后的重试逻辑</span></span><br><span class="line">  <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//从ConnectionPool获取一个健康的链接 findHealthyConnection 调用了findConnection 最终调用了ConnectionPool里面的get方法</span></span><br><span class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//根据我们获取到的链接创建了HttpCodec实例</span></span><br><span class="line">    HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      codec = resultCodec;</span><br><span class="line">      <span class="keyword">return</span> resultCodec;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CallServerInterceptor 链接拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">  RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">  realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">  <span class="comment">//发起请求</span></span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line">  realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">    <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">    <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      <span class="comment">//获取响应</span></span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">      realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">      <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">          <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">      realChain.eventListener()</span><br><span class="line">          .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">      <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">      <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">      <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">    <span class="comment">// try again to read the actual response</span></span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line">  realChain.eventListener()</span><br><span class="line">          .responseHeadersEnd(realChain.call(), response);</span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">      || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">        <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终获取响应数据</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于OkHttp的连接池及连接创建过程可以参见：<br><a href="https://sq.163yun.com/blog/article/188729834576564224" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/188729834576564224</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp源码分析（拓展）ConnectInterceptor CallServerInterceptor&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的原理及源码分析（下）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/okhttpsource2/"/>
    <id>http://www.zydeveloper.com/2020/03/21/okhttpsource2/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T13:55:11.354Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp的原理及源码分析（下）</p><a id="more"></a><p>接下来我们来分析OkHttp的真正的网络请求是如何发送的？</p><img src="okhttpsource2/2020-03-21-21-41-55.png"><p>client.newCall(request) 的源码分析如下：</p><img src="okhttpsource2/2020-03-21-21-42-21.png"><p>newCall实际是调用了RealCall.newRealCall 然后 把okhttpclient（this） 还有构建的get请求的Request对象  还有一个forWebSocket 传递进去。</p><img src="okhttpsource2/2020-03-21-21-42-45.png"><p>我们发现newRealCall方法里面首创建了一个RealCall的实例，然后设置了一下eventListener。</p><img src="okhttpsource2/2020-03-21-21-43-06.png"><p>如果是RealCall的构造函数，其中很容易发现对入口参数传递过来的值给予RealCall对应属性。重试拦截器的创建就超时处理，超时是在timeout.timeout设置的，其实也就是通过我们OkHttpClient的Builder来进行设置的，如：</p><img src="okhttpsource2/2020-03-21-21-43-37.png"><p>然后，如果超时就调用了timedOut方法，最后执行了cancel（）；方法，如下是cancel方法的源码</p><img src="okhttpsource2/2020-03-21-21-44-06.png"><p>其实就是调用了重试拦截器的cancel方法。<br>如上就是client.newCall(request)代码的执行逻辑。</p><hr><p>拓展内容：<br>分析RealCall 实现了 Call  Call 继承了 Cloneable<br>我们发现Call中使用了原型模式，目的是创建新Call对象。<br>对应我们的最终实现类是RealCall，所以如果我们要创建一个新的RealCall实例 就可以通过clone方法。<br>整个设计思路我们可以理解为使用了原型设计模式来进行的处理。</p><p>接下来我们将分析enqueue方法，注意入口参数Callback<br><img src="okhttpsource2/2020-03-21-21-45-54.png"><br>实际是调用了RealCall的enqueue方法，源码如下：<br><img src="okhttpsource2/2020-03-21-21-46-21.png"><br>判断是否当前任务已经在执行，直接就抛一个异常。<br>设置了一下eventListener的callStart 传入了RealCall实例。<br>使用client的分发器（dispatcher，它是在OkHttpClient的 Builder（）中初始化）的enqueue方法，该方法传递了一个AsyncCall对象实例，AsyncCall中有传递了responseCallback（它就是我们在代码中调用enqueue时传递的Callback对象）。</p><p>下面我们来看AsyncCall，源码如下：<br>构造函数如下，很简单就是把外面的responseCallback进行复制给它的对应属性。<br><img src="okhttpsource2/2020-03-21-21-47-13.png"><br>下面来看一下AsyncCall它的继承关系。<br><img src="okhttpsource2/2020-03-21-21-47-34.png"><br>我们发现继承了NamedRunnable，如下是NamedRunnable的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了Runnable接口 并且实现了Runnable的run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行子类中需要实现的execute（）方法</span></span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//该类需要子类必须实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来继续分享 client.dispather().enqueue(…)方法。</p><p>Dispather.java 类中enqueue方法如下：<br><img src="okhttpsource2/2020-03-21-21-50-07.png"><br>首先将传递过来的call加入到readyAsyncCalls队列中，如下是readyAsyncCalls的初始化代码：<br><img src="okhttpsource2/2020-03-21-21-50-32.png"><br>下面是promoteAndExecute代码的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">//初始化了一个任务执行计划</span></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//迭代readAsyncCalls队列</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="comment">//获取到请求任务</span></span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line">      <span class="comment">//runningAsyncCalls.size 如果大于 maxRequests(64) 直接跳出循环</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">//判断请求数量大于了已经设置的host的处理任务阀值（maxRequestRerHost=5）跳出当前循环</span></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">      <span class="comment">//readyAsyncCalls 中对于 AsyncCall 移除掉</span></span><br><span class="line">      i.remove();</span><br><span class="line">      <span class="comment">//然后把asyncCall加入到executableCalls集合中</span></span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      <span class="comment">//然后又把asyncCall加入到runningAsyncCalls队列里面来</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">//从上面局部定义请求集合中取出将要执行的任务</span></span><br><span class="line">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">    <span class="comment">//执行任务 传递了一个入口参数 使用的方法executorService（）（该方法目的是获取线程池）</span></span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executorService（）创建并获取线程池，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">  <span class="comment">//success 是否成功标记</span></span><br><span class="line">  <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用外面传入进来的线程池，调用线程池execute方法（该方法入口参数是this -&gt; AsyncCall）</span></span><br><span class="line">    <span class="comment">//为什么传入this给线程池就可以运行？因为AsyncCall继承了NamedRunnable，NamedRunnable实现了Runnable接口</span></span><br><span class="line">    executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//标记设置true</span></span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    <span class="comment">//自定义了IO异常</span></span><br><span class="line">    InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">    ioException.initCause(e);</span><br><span class="line">    <span class="comment">//回调给EventListener</span></span><br><span class="line">    eventListener.callFailed(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    <span class="comment">//回调给我们编写代码时传入的Callback</span></span><br><span class="line">    responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//执行成功走如下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会走到下面的execute（）？<br>原因是因为执行 executorService.execute(this);<br>this=AsyncCall的实例，AsyncCall继承NamedRunnable，NamedRunnable的run方法里面执行了execute（）方法，这个方法是必须由子类来实现的一个方法，也就AsyncCall的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">  timeout.enter();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//下面这行代码很重要了，从拦截器链中获取执行的响应结果数据</span></span><br><span class="line">    Response response = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e = timeoutExit(e);</span><br><span class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是责任链处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始真正的执行网络请求</span></span><br><span class="line">  <span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">// 责任链</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//在配置okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//负责处理失败后的重试与重定向</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息</span></span><br><span class="line">    <span class="comment">//从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">    <span class="comment">//设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">    <span class="comment">//可配置用户自己设置的缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//配置okhttpClient 时设置的networkInterceptors</span></span><br><span class="line">      <span class="comment">//返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">    <span class="comment">//进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">//创建责任链</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    <span class="comment">//执行责任链</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如下是责任链的执行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">    RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">//创建新的拦截链，链中的拦截器集合index+1</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">      connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">      writeTimeout);</span><br><span class="line"><span class="comment">//执行当前的拦截器-如果在配置okhttpClient，时没有设置intercept默认是先执行：retryAndFollowUpInterceptor 拦截器</span></span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line"><span class="comment">//执行拦截器</span></span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">        + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中说明了新建了一个RealInterceptorChain 责任链 并且 index+1获取到下一个拦截器，然后 执行interceptors.get(index); 获取当前的拦截器返回最终的Response响应结果数据。</p><p>这样设计的一个优点是，责任链中每个拦截器都会执行chain.proceed()方法之前的代码，等责任链最后一个拦截器执行完毕后会返回最终的响应数据。</p><p>如上源码中我们发现具体的拦截器以及顺序如下：<br>  自定义的拦截器<br>RetryAndFollowUpInterceptor<br>BridgeInterceptor<br>CacheInterceptor<br>ConnectIntercetot<br>CallServerInterceptor<br>下面分别来看一下具体的拦截器作用都有哪些（如下内容部分来源网络）？</p><p>自定义拦截器：</p><p>这个是开发人员自己实现具体要按实际业务分析</p><p>RetryAndFollowUpInterceptor：</p><p>请求失败后进行重试<br>服务器返回请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接</p><p>BridgeInterceptor：</p><p>设置内容长度，内容编码<br>设置gzip压缩，并在接收到内容后进行解压<br>添加cookie<br>设置其他报头，如User-Agent,Host,Keep-alive等，其中Keep-Alive是实现多路复用的必要步骤</p><p>CacheInterceptor</p><p>职责很明确，就是负责Cache的管理</p><p>当网络请求有符合要求的Cache时直接返回Cache<br>当服务器返回内容有改变时更新当前cache<br>如果当前cache失效，删除</p><p>ConnectInterceptor：</p><p>为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p><p>CallServerInterceptor：</p><p>负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回</p><p>StreamAllocation的作用是什么？</p><p>       StreamAllocation负责统筹管理Connection、Stream、Call三个实体类，具体就是为一个Call（Realcall），寻找（ findConnection() ）一个Connection（RealConnection），获取一个Stream（HttpCode）。</p><p>最后释放资源</p><p>最后无论是execute（）同步请求还是enqueue（）异步请求都会调用如下代码来善终。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果是异步请求就是AsyncCall</span></span><br><span class="line"><span class="comment">/** Used by &#123;<span class="doctag">@code</span> AsyncCall#run&#125; to signal completion. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是同步请求就是RealCall</span></span><br><span class="line"><span class="comment">/** Used by &#123;<span class="doctag">@code</span> Call#execute&#125; to signal completion. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">  finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//将请求对象call从对应的队列里面移除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">    <span class="comment">//给idleCallback赋值</span></span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否还有任务再执行</span></span><br><span class="line">  <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">  <span class="comment">//如果没有任务在执行了并且还有人注册了idleCallback 然后就回调idleCallback的run方法</span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp的原理及源码分析（下）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析（全）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/threadlocalsource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/threadlocalsource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:29:32.760Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal分析（全）</p><a id="more"></a><h1 id="ThreadLocal分析（全）"><a href="#ThreadLocal分析（全）" class="headerlink" title="ThreadLocal分析（全）"></a>ThreadLocal分析（全）</h1><h2 id="一个Demo来演示一下ThreadLocal"><a href="#一个Demo来演示一下ThreadLocal" class="headerlink" title="一个Demo来演示一下ThreadLocal"></a>一个Demo来演示一下ThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; count2=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Thread thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"123"</span>, <span class="string">"threadName - &gt;"</span>+Thread.currentThread().getName());</span><br><span class="line">                count2.set(<span class="number">123</span>);</span><br><span class="line">                Integer result = count2.get();</span><br><span class="line">                Log.d(<span class="string">"123"</span>, <span class="string">"result - &gt; "</span>+<span class="string">"thread "</span>+Thread.currentThread().getName()+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"MyThread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"123"</span>, <span class="string">"threadName - &gt;"</span>+Thread.currentThread().getName());</span><br><span class="line">                count2.set(<span class="number">456</span>);</span><br><span class="line">                Integer result = count2.get();</span><br><span class="line">                Log.d(<span class="string">"123"</span>, <span class="string">"result - &gt; "</span>+<span class="string">"thread "</span>+Thread.currentThread().getName()+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"MyThread2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br></pre></td></tr></table></figure><p>如上是对ThreadLocal的一个演示小Demo。</p><p>ThreadLocal有个泛型T，所以这块ThreadLocal可以放置任意类型。</p><p>我们发现在如上两个线程中使用时，ThreadLocal的get与set相对于Thread感觉像是“私有的”。</p><p>保证了多线程环境下的并发问题，也就是线程安全的。</p><h2 id="下面我们来详细分析一下ThreadLocal原理"><a href="#下面我们来详细分析一下ThreadLocal原理" class="headerlink" title="下面我们来详细分析一下ThreadLocal原理"></a>下面我们来详细分析一下ThreadLocal原理</h2><h3 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h3><p>如下是ThreadLocal的类结构图：</p><img src="/2020/03/21/threadlocalsource1/2020-03-21-22-28-35.png"><ul><li>ThreadLocalMap</li><li>get()</li><li>set(T)</li><li>createMap(Thread,T):void</li></ul><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span></span><br></pre></td></tr></table></figure><p>ThreadLocalMap是ThreadLocal的一个静态的内部类</p><p>下面我们来看看ThreadLocalMap中的一些重要属性及方法</p><p>首先看一下其中的静态内部类Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了弱引用并指定了泛型ThreadLocal</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    <span class="comment">//这里就是value属性</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造如下，key 类型 ThreadLocal  value是Object</span></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如下是ThreadLocalMap的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//table用于存储Entry的数组</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">//初始化容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//当前map的size</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">//初始化上的Entry数组</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//通过key的hashcode计算出int值作为存储的数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一个新Entry存储到“i”的数组下标位置</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            <span class="comment">//当前map的size设置1</span></span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//设置扩容因子</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如下还有一些常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Entry数组 - table 赋值给tab</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="comment">//取出数组大小</span></span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//通过key的hashcode按位与数组大小-1 计算结果就是数组下标位置</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="分析ThreadLocal的set方法"><a href="#分析ThreadLocal的set方法" class="headerlink" title="分析ThreadLocal的set方法"></a>分析ThreadLocal的set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//调用getMap方法 第一取一定是null</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果不等于null 直接设置map中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空调用createMap</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="getMap方法分析"><a href="#getMap方法分析" class="headerlink" title="getMap方法分析"></a>getMap方法分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取t-&gt;Thread的threadLocals属性</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Thread类中的threadLocals的定义如下：</span><br><span class="line"></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h5 id="createMap方法分析"><a href="#createMap方法分析" class="headerlink" title="createMap方法分析"></a>createMap方法分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//给thread的threadLocals赋值，new ThreadLocalMap（参见如上分析） 如下的this参数是ThreadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="分析ThreadLocal的get方法"><a href="#分析ThreadLocal的get方法" class="headerlink" title="分析ThreadLocal的get方法"></a>分析ThreadLocal的get方法</h4><p>如下在回忆一下之前get的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">                Integer result = count2.get();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"MyThread1"</span>);</span><br></pre></td></tr></table></figure><p>我们发现get（）方法没有任何的参数，但是它是允许在子线程（MyThread1）中的。</p><h5 id="get-方法分析"><a href="#get-方法分析" class="headerlink" title="get()方法分析"></a>get()方法分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取了当前的线程，所有这也是get不需要参数的原因 这里获取到的线程（MyThread1）</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">//从线程中获取ThreadLocalMap对象 也就是Thread中threadLocals</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//不为空直接从map中获取Entry进一步获取value</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从map中使用this（threadlocal对象）获取Entry</span></span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//如果Entry对象不为空从而获取value</span></span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="comment">//返回value结果</span></span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果map等于null 执行如下方法</span></span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="setInitialValue-方法分析"><a href="#setInitialValue-方法分析" class="headerlink" title="setInitialValue()方法分析"></a>setInitialValue()方法分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取初始化值</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//通过线程获取ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//map不为空 直接将this（ThreadLocal） value-上面获取到的初始化值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果map为空就执行createMap - 逻辑参见如上对createMap方法的分析</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="comment">//返回value</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="initialValue-方法分析"><a href="#initialValue-方法分析" class="headerlink" title="initialValue()方法分析"></a>initialValue()方法分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法是ThreadLocal类中的，保护类型也就是可以通过外部开发人员自己实现，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; count2=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">       <span class="meta">@Nullable</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//设置了初始化值为 0</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h3 id="Thread-ThreadLocal-ThreadLocalMap三者直接的关系以及调用逻辑"><a href="#Thread-ThreadLocal-ThreadLocalMap三者直接的关系以及调用逻辑" class="headerlink" title="Thread  ThreadLocal ThreadLocalMap三者直接的关系以及调用逻辑"></a>Thread  ThreadLocal ThreadLocalMap三者直接的关系以及调用逻辑</h3><img src="/2020/03/21/threadlocalsource1/2020-03-21-22-29-17.png"><p>我们发现虽然ThreadLocalMap是ThreadLocal的内部类，但是ThreadLocalMap其实是放到了Thread类中<strong>threadLocals</strong>属性里面,ThreadLocal被作为ThreadLocalMap中的内部类<strong>Entry</strong>的*[key]*来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal分析（全）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android View绘制原理（前篇）</title>
    <link href="http://www.zydeveloper.com/2020/03/21/viewsource1/"/>
    <id>http://www.zydeveloper.com/2020/03/21/viewsource1/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:19:24.822Z</updated>
    
    <content type="html"><![CDATA[<p>Android View绘制原理（前篇）</p><a id="more"></a><h1 id="Android-View绘制原理（前篇）"><a href="#Android-View绘制原理（前篇）" class="headerlink" title="Android View绘制原理（前篇）"></a>Android View绘制原理（前篇）</h1><p><strong><em>PhoneWindow WindowManager WindowManagerImpl WindowMangerGlobal ViewRootImpl解析</em></strong></p><h3 id="PhoneWindow初始化"><a href="#PhoneWindow初始化" class="headerlink" title="PhoneWindow初始化"></a>PhoneWindow初始化</h3><p><font color="red"><strong>Activity的attach</strong></font></p><p>PhoneWindow在<strong>Activity</strong>中的<em>attach</em>方法被创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">          Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">          Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">          NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">          Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">      attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">      mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化PhoneWindow</span></span><br><span class="line">      mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);</span><br><span class="line">     </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置并初始化WindowManager</span></span><br><span class="line">      mWindow.setWindowManager(</span><br><span class="line">              (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">              mToken, mComponent.flattenToString(),</span><br><span class="line">              (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mWindow.setContainer(mParent.getWindow());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取WindowManager</span></span><br><span class="line">      mWindowManager = mWindow.getWindowManager();</span><br><span class="line">      mCurrentConfig = config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="DecorView初始化"><a href="#DecorView初始化" class="headerlink" title="DecorView初始化"></a>DecorView初始化</h3><p><font color="red"><strong>Activity的onCreate中</strong></font></p><p>DecorView初始化我们从Activity的setContentView方法进行分析，一般setContentView都是在Activity的onCreate生命周期中设置的，我们来看一下Activity的setContentView源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the activity content from a layout resource.  The resource will be</span></span><br><span class="line"><span class="comment">    * inflated, adding all top-level views to the activity.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setContentView(android.view.View)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">       getWindow().setContentView(layoutResID);</span><br><span class="line">       initWindowDecorActionBar();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上我们发现setContentView中使用getWindow（）[其实getWindow获取到的就是我们attach中new 的PhoneWindow实例]，所以调用就是phoneWindow的setContentView方法,具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">     <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">     <span class="comment">// before this happens.</span></span><br><span class="line">     <span class="comment">//mContentParent就是id等于content的ViewGroup控件</span></span><br><span class="line">     <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//见如下分析</span></span><br><span class="line">         installDecor();</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">         mContentParent.removeAllViews();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">         <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                 getContext());</span><br><span class="line">         transitionTo(newScene);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//为mContentParent添加子视图</span></span><br><span class="line">         <span class="comment">//也就是给Activity中设置视图文件</span></span><br><span class="line">         mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">     &#125;</span><br><span class="line">     mContentParent.requestApplyInsets();</span><br><span class="line">     <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">     <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">         cb.onContentChanged();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor"></a>installDecor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到id等于content的ViewGroup</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="generateDecor"><a href="#generateDecor" class="headerlink" title="generateDecor"></a>generateDecor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现了创建并初始化DecorView的位置。</p><h4 id="generateLayout"><a href="#generateLayout" class="headerlink" title="generateLayout"></a>generateLayout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Apply data from current theme.</span></span><br><span class="line">       <span class="comment">//从主题里获取style样式</span></span><br><span class="line">       TypedArray a = getWindowStyle();</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="comment">//decorview开始更改</span></span><br><span class="line">       mDecor.startChanging();</span><br><span class="line"><span class="comment">//加载了layoutResource</span></span><br><span class="line">       View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//Decor中添加子控件</span></span><br><span class="line">       decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">       mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处获取到的就是id 为 content的FrameLayout的子类</span></span><br><span class="line">       ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">       <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//decorview完成更改</span></span><br><span class="line">       mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> contentParent;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现方法返回的就是我们activity自己实现布局的parent，也就是id等于content的ViewGroup。</p><p><strong>总结：</strong></p><p>​    <strong><em>Activity中onCreate生命周期中调用setContentView方法来设置content视图，调用了PhoneWindow的setContentView方法，进而调用installDecor，继续调用generateDecor 该方法new 出了DecorView 然后返回。</em></strong></p><h3 id="WindowManager初始化"><a href="#WindowManager初始化" class="headerlink" title="WindowManager初始化"></a>WindowManager初始化</h3><p>Window.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the window manager for use by this Window to, for example,</span></span><br><span class="line"><span class="comment">     * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the</span></span><br><span class="line"><span class="comment">     * Window itself -- that must be done by the client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wm The window manager for adding new windows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123;</span><br><span class="line">        mAppToken = appToken;</span><br><span class="line">        mAppName = appName;</span><br><span class="line">        mHardwareAccelerated = hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>WindowManagerImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(mDisplay, parentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现如上代码中的mWindow.setWindowManager其实是使用的就是WindowManagerImpl的实例。</p><h3 id="WindowManagerImpl与WindowManager-关系"><a href="#WindowManagerImpl与WindowManager-关系" class="headerlink" title="WindowManagerImpl与WindowManager 关系"></a>WindowManagerImpl与WindowManager 关系</h3><img src="/2020/03/21/viewsource1/2020-03-21-22-17-46.png"><p>我们发现WindowManagerImpl实现了WindowManager接口。</p><h3 id="WindowManager与ViewManager关系"><a href="#WindowManager与ViewManager关系" class="headerlink" title="WindowManager与ViewManager关系"></a>WindowManager与ViewManager关系</h3><img src="/2020/03/21/viewsource1/2020-03-21-22-18-25.png"><p>我们发现WindowManager继承了ViewManager接口。</p><p><strong>所以WindowManagerImpl实现了WindowManager接口，WindowManager继承了ViewManager接口。</strong></p><h3 id="WindowMangerGlobal类"><a href="#WindowMangerGlobal类" class="headerlink" title="WindowMangerGlobal类"></a>WindowMangerGlobal类</h3><p>我们再看看WindowManagerImpl类的具体实现，其实WindowManagerGlobal这个位置是一个典型的代理模式</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//WindowManagerGlobal实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Display mDisplay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mDefaultToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowManagerImpl</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(display, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WindowManagerImpl</span><span class="params">(Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mParentWindow = parentWindow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(mDisplay, parentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WindowManagerImpl <span class="title">createPresentationWindowManager</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(display, mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the window token to assign when none is specified by the client or</span></span><br><span class="line"><span class="comment">     * available from the parent window.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token The default token to assign.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultToken</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">        mDefaultToken = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDefaultToken</span><span class="params">(@NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Only use the default token if we don't have a parent window.</span></span><br><span class="line">        <span class="keyword">if</span> (mDefaultToken != <span class="keyword">null</span> &amp;&amp; mParentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Only use the default token if we don't already have a token.</span></span><br><span class="line">            <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">            <span class="keyword">if</span> (wparams.token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                wparams.token = mDefaultToken;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeViewImmediate</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Display <span class="title">getDefaultDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDisplay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码我们不难看出WindowManagerImpl只是WindowManagerGlobal的代理类，最终实现都在WindowManagerGlobal中。</p><h3 id="再看-wm-addView-decor-l"><a href="#再看-wm-addView-decor-l" class="headerlink" title="再看 wm.addView(decor, l);"></a>再看 wm.addView(decor, l);</h3><p><font color="red"><strong>Activity的Resume</strong></font></p><p>ActivityThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">                    <span class="comment">//将decor添加到vm中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">           ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面分析中我们发现wm其实就是WindowManagerImpl但最终干活的是WindowManagerGlobal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerImpl.java</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        <span class="comment">//最终调用的WindowManagerGlobal addView方法</span></span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来看一下WindowManagerGlobal的addView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">            <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">            <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">            ...</span><br><span class="line"><span class="comment">//初始化了ViewRootImpl  整个View的绘制就开始于ViewRootImpl</span></span><br><span class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"><span class="comment">//将DecorView ViewRootImpl LayoutParams存储到如下对应位置</span></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如下会分析此处</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下是对mViews mRoots  mParams的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">          <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br></pre></td></tr></table></figure><p>上面代码中我们发现了ViewRootImpl的初始化，这也是我们View绘制的真正起点。</p><h3 id="ViewRootImpl分析"><a href="#ViewRootImpl分析" class="headerlink" title="ViewRootImpl分析"></a>ViewRootImpl分析</h3><p>构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用远程的WMS服务获取Session 但是改会话是单向的只能用于ViewRootImpl发送给WMS</span></span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//此处作用参见如下分析</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line">        mViewVisibility = View.GONE;</span><br><span class="line">        mTransparentRegion = <span class="keyword">new</span> Region();</span><br><span class="line">        mPreviousTransparentRegion = <span class="keyword">new</span> Region();</span><br><span class="line">        mFirst = <span class="keyword">true</span>; <span class="comment">// true for the first time the view is added</span></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">        mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现了mWindowSession及mWindow</p><p>先来看看mWindowSession即WindowManagerGlobal.getWindowSession()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title">getWindowManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sWindowManagerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过Binder获取远程的WMS （WindowManagerService）服务</span></span><br><span class="line">                sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"window"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sWindowManagerService = getWindowManagerService();</span><br><span class="line">                    ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"Failed to get WindowManagerService, cannot set animator scale"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                    <span class="comment">//此处获取WMS的实例 参见上面的方法</span></span><br><span class="line">                    IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                    sWindowSession = windowManager.openSession(</span><br><span class="line">                            <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                    ValueAnimator.setDurationScale(scale);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            imm.getClient(), imm.getInputContext());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"Failed to open window session"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sWindowSession;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上代码我们发现getWindowManagerService()通过Binder机制获取远程WindowManagerService，然后使用openSession获取WMS的WindowSession。</p><p><strong><em>ViewRootImpl通过使用WindowSession与WMS进行通信（该通信是单向的）。</em></strong></p><p><strong>那么如果WMS想与ViewRootImpl通信怎么办呢？</strong></p><p>我们看看如上代码中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里的W就是WMS与ViewRootImpl通信的桥梁，那么WMS是如何使用W与ViewRootImpl产生联系的呢？</p><p>还记得上面代码中WindowManagerGlobal的addView吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>root也就是ViewRootImpl实例，我们来看看setView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里面mWindowSession.addToDisplay方法中的第一个参数mWindow就是W实例了。</p><p>mWindowSession之前我们分析过了就是通过windowManager.openSession获取到的WindowSession实例。</p><p>下面用一张图来说明W、ViewRootImpl、WindowSession、WindowManagerService之间的关系：</p><img src="/2020/03/21/viewsource1/2020-03-21-22-19-10.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android View绘制原理（前篇）&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android View的绘制流程分析</title>
    <link href="http://www.zydeveloper.com/2020/03/21/viewsource2/"/>
    <id>http://www.zydeveloper.com/2020/03/21/viewsource2/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T14:23:28.649Z</updated>
    
    <content type="html"><![CDATA[<p>Android View的绘制流程分析</p><a id="more"></a><h1 id="Android-View的绘制流程分析"><a href="#Android-View的绘制流程分析" class="headerlink" title="Android View的绘制流程分析"></a>Android View的绘制流程分析</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><img src="/2020/03/21/viewsource2/2020-03-21-22-21-11.png"><p>​                                                                                <strong>页面效果图</strong></p><p>如下是“蓝色原型”自定义控件的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defaultWidth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defaultHeight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyOnClickListener onClickListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"ResourceType"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        initPaint();</span><br><span class="line">        TypedArray typedArray = context.getResources().obtainAttributes(attrs, R.styleable.MyView);</span><br><span class="line">        mRadius = typedArray.getFloat(R.styleable.MyView_mRadius, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        defaultWidth=<span class="number">2</span>*(<span class="keyword">int</span>)mRadius;</span><br><span class="line">        defaultHeight=<span class="number">2</span>*(<span class="keyword">int</span>)mRadius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint=<span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        mPaint.setDither(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"ResourceType"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modeWidth==MeasureSpec.AT_MOST&amp;&amp;modeHeight==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(defaultWidth,defaultHeight);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (modeWidth==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(defaultWidth,sizeHeight);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (modeHeight==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">            setMeasuredDimension(sizeWidth,defaultHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="keyword">float</span> cx=getMeasuredWidth()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> cy=getMeasuredHeight()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(cx,cy,mRadius-paddingTop,mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                doStyle(Color.RED);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span>!=onClickListener)&#123;</span><br><span class="line">                    onClickListener.onClick(<span class="string">"result"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                doStyle(Color.BLUE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                doStyle(Color.BLUE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//super.onTouchEvent(event);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyOnClickListener</span><span class="params">(MyOnClickListener my)</span></span>&#123;</span><br><span class="line">        onClickListener=my;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStyle</span><span class="params">(<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">        mPaint.setColor(color);</span><br><span class="line">        <span class="keyword">if</span> (Looper.getMainLooper().getThread()==Thread.currentThread())&#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyOnClickListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object... params)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下是布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.zy.news.MyView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/myview"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:mRadius</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.zy.news.MyView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下是activity中的调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      myview.setMyOnClickListener(<span class="keyword">new</span> MyView.MyOnClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line">              Toast.makeText(CustomViewActivity.<span class="keyword">this</span>,<span class="string">"conent:"</span>+params[<span class="number">0</span>],Toast.LENGTH_SHORT).show();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      myview = (MyView) findViewById(R.id.myview);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="调用时序图"><a href="#调用时序图" class="headerlink" title="调用时序图"></a>调用时序图</h2><p>先上一张分析的调用结构图</p><img src="/2020/03/21/viewsource2/2020-03-21-22-22-13.png"><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><p>使用AS IDE中Tools菜单下的【Layout Inspector】工具</p><p>如下是对当前activity的页面结果分析：</p><img src="/2020/03/21/viewsource2/2020-03-21-22-22-46.png"><p>如上结果图分析：</p><ul><li><p>根节点是PhoneWindow DecorView</p></li><li><p>接下来是由LinearLayout及状态栏（statusBarBackground）组成</p></li><li><p>LinearLayout中FrameLayout</p></li><li><p>FrameLayout中包含了action_bar_root(FitWindowsLinearLayout)</p></li><li><p>FrameLayout中包含了ActionBar及<strong>content</strong> (ContentFrameLayout)</p></li><li><p>conent中包含了我们自己实现的ui布局</p><p>content也就是我们在Activity中onCreate进行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_custom_view);</span><br></pre></td></tr></table></figure></li></ul><h2 id="ActivityThread中handleResumeActivity方法"><a href="#ActivityThread中handleResumeActivity方法" class="headerlink" title="ActivityThread中handleResumeActivity方法"></a>ActivityThread中handleResumeActivity方法</h2><p>从Activity的启动流程中我们了解过handleResumeActivity方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">     <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从r中获取activity</span></span><br><span class="line">           <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//从activity中获取getWindow</span></span><br><span class="line">               r.window = r.activity.getWindow();</span><br><span class="line">               View decor = r.window.getDecorView();</span><br><span class="line">               decor.setVisibility(View.INVISIBLE);</span><br><span class="line">               <span class="comment">//getWindowManager 其实是WindowManagerImpl的实例  WindowManagerImpl 实现了 WindowManager接口  WM 实现 ViewManager接口     </span></span><br><span class="line">               ViewManager wm = a.getWindowManager();</span><br><span class="line">               WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">               a.mDecor = decor;</span><br><span class="line">               l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">               l.softInputMode |= forwardBit;</span><br><span class="line">               <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                   a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">//将decor添加到vm中</span></span><br><span class="line">                   wm.addView(decor, l);</span><br><span class="line">               &#125;</span><br><span class="line">               ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中我们发现了一下类型 如：PhoneWindow WindowManager WindowManagerImpl WindowMangerGlobal ViewRootImpl。</p><p>下面我们来看看他们的关系：</p><p>参见<a href>《Android View绘制原理（前篇》</a></p><h3 id="wm-addView-decor-l"><a href="#wm-addView-decor-l" class="headerlink" title="wm.addView(decor, l);"></a>wm.addView(decor, l);</h3><p>通过<a href>《Android View绘制原理（前篇》</a>中我们发现wm其实就是就是WindowManagerImpl的实例并且最终干活的是WindowMangerGlobal </p><p>wm.addView(decor,l);其实最终调用的就是WindowManagerGlobal的addView方法，然后最终调用的是addView方法中的ViewRootImpl的setView方法</p><p>ViewRootImpl的seView方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We have one child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">                <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">                <span class="comment">// any other events from the system.</span></span><br><span class="line">                <span class="comment">//开始布局</span></span><br><span class="line">                requestLayout();</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">             ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">          checkThread();</span><br><span class="line">          mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//计划遍历</span></span><br><span class="line">          scheduleTraversals();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="scheduleTraversals"><a href="#scheduleTraversals" class="headerlink" title="scheduleTraversals"></a>scheduleTraversals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="blue">mTraversalRunnable</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//开始遍历</span></span><br><span class="line">           doTraversal();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure><h4 id="doTraversal"><a href="#doTraversal" class="headerlink" title="doTraversal"></a>doTraversal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">           mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">               Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//执行遍历</span></span><br><span class="line">           performTraversals();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">               Debug.stopMethodTracing();</span><br><span class="line">               mProfile = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="performTraversals"><a href="#performTraversals" class="headerlink" title="performTraversals"></a>performTraversals</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"> ...</span><br><span class="line">    performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"> ...</span><br><span class="line">    performDraw();</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals开始了measure  layout  draw 三个android View中特别重要的步骤。</p><h4 id="performMeasure"><a href="#performMeasure" class="headerlink" title="performMeasure"></a>performMeasure</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//mView即DecorView</span></span><br><span class="line">          mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用了View的meause方法: <font color="red">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</font></p><h5 id="View-measure方法"><a href="#View-measure方法" class="headerlink" title="View measure方法"></a>View measure方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This is called to find out how big a view should be. The parent</span></span><br><span class="line"><span class="comment">     * supplies constraint information in the width and height parameters.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The actual measurement work of a view is performed in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</span></span><br><span class="line"><span class="comment">     *        parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</span></span><br><span class="line"><span class="comment">     *        parent</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #onMeasure(int, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现View中的measure方法最终会调用onMeasure来完成控件的测量工作，onMeasure方法是可以由View的子类来复写实现，当然View也有一个默认实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比如如上代码中的mView是DecorView的实例，DecorView继承了FrameLayout我们来看一下FrameLayout的onMeasure方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">FrameLayout.java</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//获取子控件的个数</span></span><br><span class="line">     <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="comment">//遍历所有子控件</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">         <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">             <span class="comment">//测量子控件带有margin的情况</span></span><br><span class="line">             measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">             <span class="comment">//获取了子控件的布局参数</span></span><br><span class="line">             <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">             <span class="comment">//将当前子控件的width与布局参数中左右margin值相加与maxWidth比较取最大值</span></span><br><span class="line">             maxWidth = Math.max(maxWidth,</span><br><span class="line">                     child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">             <span class="comment">//将当前子控件的height与布局参数中上下margin值相加与maxWidth比较取最大值</span></span><br><span class="line">             maxHeight = Math.max(maxHeight,</span><br><span class="line">                     child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">             childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">             <span class="comment">//将child 布局参数中的widht与height 是MATCH_PARENT放到一个集合中</span></span><br><span class="line">             <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                         lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                     mMatchParentChildren.add(child);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//padding也考虑进来</span></span><br><span class="line">     <span class="comment">// Account for padding too</span></span><br><span class="line">     maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">     maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">     maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">     maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">     <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">     <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">         maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">         maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//开始测量自己FrameLayout</span></span><br><span class="line">     setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">             resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                     childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取子控件布局参数中的widht与height 是MATCH_PARENT的控件</span></span><br><span class="line">     count = mMatchParentChildren.size();</span><br><span class="line">     <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">//遍历</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">             <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">             <span class="comment">//width为LayoutParams.MATCH_PARENT的情况处理</span></span><br><span class="line">             <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                         - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                         - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                 childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                         width, MeasureSpec.EXACTLY);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                         getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                         lp.leftMargin + lp.rightMargin,</span><br><span class="line">                         lp.width);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">             <span class="comment">//height为LayoutParams.MATCH_PARENT的情况处理</span></span><br><span class="line">             <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                         - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                         - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                 childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                         height, MeasureSpec.EXACTLY);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                         getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                         lp.topMargin + lp.bottomMargin,</span><br><span class="line">                         lp.height);</span><br><span class="line">             &#125;</span><br><span class="line"><span class="comment">//子控件重新测量</span></span><br><span class="line">             child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"><span class="comment">//host DecorView</span></span><br><span class="line">       <span class="keyword">final</span> View host = mView;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上代码我们发现host就是DecorView的实例，然后调用layout方法其实最终调用的是View的layout方法，View的layout方法中调用onLayout方法，该方法一般由子类来具体实现View中就是一个空方法。</p><h5 id="View的layout方法"><a href="#View的layout方法" class="headerlink" title="View的layout方法"></a>View的layout方法</h5><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看host（DecorView）的onLayout发现调用了super.onLayout，这里的super指的就是FrameLayout，所有我们来关注一下FrameLayout的onLayout方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//布局子视图</span></span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取子实体个数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取parent ltrb</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line">        <span class="comment">//遍历子视图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//获取子视图</span></span><br><span class="line">            <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">            <span class="comment">//子视图没有GONE的</span></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="comment">//获取子视图的布局参数</span></span><br><span class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取子视图测量后的宽高</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> childLeft;</span><br><span class="line">                <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//省略的代码为处理子视图的Gravity </span></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                <span class="comment">//布局子视图</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们用FrameLayout为例来演示layout，最终child.layout又是调用View中的layout然后调用child的onLayout逐步遍历直到所有视图布局完成。</p><h4 id="performDraw"><a href="#performDraw" class="headerlink" title="performDraw"></a>performDraw</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绘制方法</span></span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="drawSoftware"><a href="#drawSoftware" class="headerlink" title="drawSoftware"></a>drawSoftware</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with software renderer.</span></span><br><span class="line">        <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">            canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">//mView DecorView 调用draw方法并传入canvas</span></span><br><span class="line">                mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>mView的draw方法与上面measure及layout一样，都是在View.java中实现的</p><h5 id="View的draw方法"><a href="#View的draw方法" class="headerlink" title="View的draw方法"></a>View的draw方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">       <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">           drawBackground(canvas);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">           <span class="comment">// Step 3, draw the content</span></span><br><span class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Step 4, draw the children</span></span><br><span class="line">           dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">           onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// we're done...</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现draw方法中涉及6步（2,5是基础的不分析了），具体可以理解为4步：</p><ul><li>第一步  绘制背景</li><li>第二步 调用各实现View的onDraw来绘制自己</li><li>第三步 绘制Child</li><li>第四步 绘制前景及滚动条</li></ul><h5 id="dispatchDraw"><a href="#dispatchDraw" class="headerlink" title="dispatchDraw"></a>dispatchDraw</h5><p>关于如上的第三步绘制Child我们再来关注一下</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现View中的dispatchDraw方法是一个空方法并没有任何实现，所以我们还是已DecorView为例来跟踪代码发现在ViewGroup类中进行了具体实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">           </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现还是遍历所有的子View调用drawChild方法，下面继续看drawChild</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上我们发现还是调用的View的draw这样就很容易看出了View的不断遍历绘制方式了。</p><p><font color="red">上面的调用时序图是对如上代码分析的总结结合参考。</font></p><p><font color="blue">如上！咱们的View绘制流程已经分析完成 ， DONE！</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android View的绘制流程分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://www.zydeveloper.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.zydeveloper.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 三、音乐APP（添加Module并添加FFmpeg动态库）</title>
    <link href="http://www.zydeveloper.com/2019/09/05/ffmpeg-demo1-module/"/>
    <id>http://www.zydeveloper.com/2019/09/05/ffmpeg-demo1-module/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2019-09-05T03:56:27.850Z</updated>
    
    <content type="html"><![CDATA[<p>基于之前的工程来添加Module工程。</p><a id="more"></a><h2 id="创建Module工程"><a href="#创建Module工程" class="headerlink" title="创建Module工程"></a>创建Module工程</h2><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-04-20-08-12.png"><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-04-20-09-07.png">将新建的Module工程添加到APP工程中。<img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-25-30.png"><h2 id="Module添加C-支持"><a href="#Module添加C-支持" class="headerlink" title="Module添加C++支持"></a>Module添加C++支持</h2><h3 id="将app-gradle中的配置移植到module-gradle中"><a href="#将app-gradle中的配置移植到module-gradle中" class="headerlink" title="将app gradle中的配置移植到module gradle中"></a>将app gradle中的配置移植到module gradle中</h3><p>将app gradle中的如下配置移植到module gradle中。<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-29-46.png"><br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-30-55.png"></p><h3 id="将app中的CMakeLists-txt移植到module中"><a href="#将app中的CMakeLists-txt移植到module中" class="headerlink" title="将app中的CMakeLists.txt移植到module中"></a>将app中的CMakeLists.txt移植到module中</h3><p>注意我们要移植到module工程的根目录中，如：</p><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-51-06.png"><h3 id="module工程中创建类文件添加native方法"><a href="#module工程中创建类文件添加native方法" class="headerlink" title="module工程中创建类文件添加native方法"></a>module工程中创建类文件添加native方法</h3><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-39-00.png">有报红的是因为我们移植过来的cpp文件jni 方法包名不对引起的。修正为：<img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-41-55.png"><h3 id="修改app的MainActivity代码用于测试验证结果"><a href="#修改app的MainActivity代码用于测试验证结果" class="headerlink" title="修改app的MainActivity代码用于测试验证结果"></a>修改app的MainActivity代码用于测试验证结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.music.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">        tv.setText(<span class="keyword">new</span> Demo().stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-08-49-29.png"><p>我们看到上面已经正常输出了c++的运算结果。</p><h2 id="添加FFmpeg动态库"><a href="#添加FFmpeg动态库" class="headerlink" title="添加FFmpeg动态库"></a>添加FFmpeg动态库</h2><p>这里面提到的资源如果给位没有，请参考：</p><p><a href="http://www.zydeveloper.com/2019/09/04/ffmpeg-build/">FFmpeg系列 一、编译FFmpeg</a></p><h4 id="module-cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件"><a href="#module-cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件" class="headerlink" title="module cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件"></a>module cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件</h4><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-43-29.png"><h4 id="module-main文件夹中创建jniLibs-复制arm-和-x86的-so库到jinLibs中"><a href="#module-main文件夹中创建jniLibs-复制arm-和-x86的-so库到jinLibs中" class="headerlink" title="module main文件夹中创建jniLibs,复制arm 和 x86的.so库到jinLibs中"></a>module main文件夹中创建jniLibs,复制arm 和 x86的.so库到jinLibs中</h4><p>创建jniLibs目录<br>将arm和x86动态库拷贝到jinLibs目录下。<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-09-02-58.png"></p><h4 id="配置module-gradle文件"><a href="#配置module-gradle文件" class="headerlink" title="配置module gradle文件"></a>配置module gradle文件</h4><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-41-31.png"><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-42-19.png"><h4 id="cmakelists-txt-配置FFmpeg"><a href="#cmakelists-txt-配置FFmpeg" class="headerlink" title="cmakelists.txt 配置FFmpeg"></a>cmakelists.txt 配置FFmpeg</h4><h5 id="导入include路径"><a href="#导入include路径" class="headerlink" title="导入include路径"></a>导入include路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导入头文件路径</span><br><span class="line">include_directories(src/main/cpp/include)</span><br></pre></td></tr></table></figure><h5 id="添加动态库"><a href="#添加动态库" class="headerlink" title="添加动态库"></a>添加动态库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导入动态库</span><br><span class="line">add_library(avcodec-57 SHARED IMPORTED)</span><br></pre></td></tr></table></figure><h5 id="设置动态库路径"><a href="#设置动态库路径" class="headerlink" title="设置动态库路径"></a>设置动态库路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so)</span><br></pre></td></tr></table></figure><h5 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       avcodec-57</span><br><span class="line"></span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><h4 id="最终CMake"><a href="#最终CMake" class="headerlink" title="最终CMake"></a>最终CMake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#导入头文件路径</span><br><span class="line">include_directories(include)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avcodec-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avdevice-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avdevice-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavdevice-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avfilter-6 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avfilter-6 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavfilter-6.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avformat-57 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avformat-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavformat-57.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(avutil-55 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(avutil-55 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavutil-55.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(postproc-54 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(postproc-54 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libpostproc-54.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(swresample-2 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(swresample-2 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswresample-2.so)</span><br><span class="line"></span><br><span class="line">#导入动态库</span><br><span class="line">add_library(swscale-4 SHARED IMPORTED)</span><br><span class="line"></span><br><span class="line">#设置动态库路径</span><br><span class="line">set_target_properties(swscale-4 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswscale-4.so)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library(native-lib</span><br><span class="line">            SHARED</span><br><span class="line">            native-lib.cpp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_library(log-lib</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_link_libraries(native-lib</span><br><span class="line">        $&#123;log-lib&#125;</span><br><span class="line"></span><br><span class="line">                       avcodec-57</span><br><span class="line">                        avdevice-57</span><br><span class="line">                        avfilter-6</span><br><span class="line">                        avformat-57</span><br><span class="line">                        avutil-55</span><br><span class="line">                        postproc-54</span><br><span class="line">                        swresample-2</span><br><span class="line">                        swscale-4</span><br><span class="line"></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><p><strong>注意：CMakeLists.txt文件需要放到项目跟目录，否则会出现路径不对引发的错误。</strong></p><h2 id="Demo验证FFmpeg是否集成成功"><a href="#Demo验证FFmpeg是否集成成功" class="headerlink" title="Demo验证FFmpeg是否集成成功"></a>Demo验证FFmpeg是否集成成功</h2><p>在module 工程 Demo中导入动态库并加入native方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.music.mplayer;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    // Used to load the &apos;native-lib&apos; library on application startup.</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;native-lib&quot;);</span><br><span class="line"></span><br><span class="line">        System.loadLibrary(&quot;avcodec-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avdevice-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avfilter-6&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avformat-57&quot;);</span><br><span class="line">        System.loadLibrary(&quot;avutil-55&quot;);</span><br><span class="line">        System.loadLibrary(&quot;postproc-54&quot;);</span><br><span class="line">        System.loadLibrary(&quot;swresample-2&quot;);</span><br><span class="line">        System.loadLibrary(&quot;swscale-4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A native method that is implemented by the &apos;native-lib&apos; native library,</span><br><span class="line">     * which is packaged with this application.</span><br><span class="line">     */</span><br><span class="line">    public native String stringFromJNI();</span><br><span class="line"></span><br><span class="line">    public native void testFFmpeg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报红的部分 alt+enter 搞定。</p><p>native-lib.cpp代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,<span class="meta-string">"zhangyue"</span>,FORMAT,##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring</span><br><span class="line">JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Welcome to"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_testFFmpeg(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    AVCodec *c_temp = av_codec_next(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (c_temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c_temp-&gt;type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                LOGI(<span class="string">"[Video]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                LOGI(<span class="string">"[Audio]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                LOGI(<span class="string">"[Other]:%s"</span>, c_temp-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c_temp = c_temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.music.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ****;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Demo().testFFmpeg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，logcat输出如下log：<br><img src="/2019/09/05/ffmpeg-demo1-module/2019-09-05-11-48-24.png"></p><p>打印了ffmpeg支持的视频格式，说明我们已经集成成功了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于之前的工程来添加Module工程。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 番外篇 Android C++ 子线程 及 生产者消费者模型</title>
    <link href="http://www.zydeveloper.com/2019/09/05/ffmpeg-other1-thread/"/>
    <id>http://www.zydeveloper.com/2019/09/05/ffmpeg-other1-thread/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2019-09-05T07:10:54.083Z</updated>
    
    <content type="html"><![CDATA[<p>这篇来讲讲Android C++ 子线程 及 生产者消费者模型</p><a id="more"></a><p>Android 中的C++ 线程，我们要使用 POSIX 编写多线程 C++ 程序。</p><p>重要有三个方法：</p><p>pthread_t —— 声明线程<br>pthread_create —— 创建线程<br>pthread_exit  —— 终止线程</p><p>一个Demo来演示线程使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> native  <span class="keyword">void</span> <span class="title">normalThread</span><span class="params">()</span></span>;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">normalCallback</span><span class="params">(<span class="keyword">void</span> *data)</span></span>&#123;</span><br><span class="line">    LOGI(<span class="string">"create normal thread from c++"</span>);</span><br><span class="line">    pthread_exit(&amp;thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_music_mplayer_Demo_normalThread(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    pthread_create(&amp;thread,<span class="literal">NULL</span>,normalCallback,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来相对简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇来讲讲Android C++ 子线程 及 生产者消费者模型&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 一、编译FFmpeg</title>
    <link href="http://www.zydeveloper.com/2019/09/04/ffmpeg-build/"/>
    <id>http://www.zydeveloper.com/2019/09/04/ffmpeg-build/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-09-04T08:58:51.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h2><p>在Ubuntu中编译Android平台的FFmpeg（arm和x86）</p><a id="more"></a><p>环境准备：</p><p>-下载FFmpeg源码（v3.3.9）<br>-下载NDK（r14b）<br>-编写Android编译脚本</p><h3 id="下载FFmpeg源码（v3-3-9）"><a href="#下载FFmpeg源码（v3-3-9）" class="headerlink" title="下载FFmpeg源码（v3.3.9）"></a>下载FFmpeg源码（v3.3.9）</h3><p><a href="http://www.ffmpeg.org/download.html#releases" target="_blank" rel="noopener">V3.3.9下载地址</a></p><img src="/2019/09/04/ffmpeg-build/2019-09-04-09-26-57.png"><h3 id="下载NDK（r14b）"><a href="#下载NDK（r14b）" class="headerlink" title="下载NDK（r14b）"></a>下载NDK（r14b）</h3><p><a href="https://developer.android.google.cn/ndk/downloads/older_releases.html" target="_blank" rel="noopener">NDK r14b 下载</a></p><p>因为在Ubuntu下编译，便于我们方便连接操作，我这里使用XShell与XFTP工具。</p><h3 id="使用FTP上传下载文件到Ubuntu中"><a href="#使用FTP上传下载文件到Ubuntu中" class="headerlink" title="使用FTP上传下载文件到Ubuntu中"></a>使用FTP上传下载文件到Ubuntu中</h3><img src="/2019/09/04/ffmpeg-build/2019-09-04-10-13-07.png"><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><h4 id="解压FFmpeg"><a href="#解压FFmpeg" class="headerlink" title="解压FFmpeg"></a>解压FFmpeg</h4><p>tar -zxvf ffmpeg-3.3.9.tar.gz</p><h4 id="解压NDK"><a href="#解压NDK" class="headerlink" title="解压NDK"></a>解压NDK</h4><p>unzip android-ndk-r14b-linux-x86_64.zip</p><h3 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h3><h4 id="修改FFmpeg的configure文件"><a href="#修改FFmpeg的configure文件" class="headerlink" title="修改FFmpeg的configure文件"></a>修改FFmpeg的configure文件</h4><p><strong><em>因为android只能加载.so的动态库，不能识别如</em>.so.57结尾的*</strong></p><p>将虚拟机中的configure文件使用FTP下载到本地进行如下修改：</p><p>进行如图修改：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-12-01-10.png"></p><p>修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;</span><br><span class="line">#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;</span><br><span class="line">#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;</span><br><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</span><br></pre></td></tr></table></figure><p>修改后更新到Ubuntu中。</p><p>设置configure权限并执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 configure</span><br><span class="line"></span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><img src="/2019/09/04/ffmpeg-build/2019-09-04-14-31-36.png"><h4 id="编写Android编译脚本"><a href="#编写Android编译脚本" class="headerlink" title="编写Android编译脚本"></a>编写Android编译脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>NDK路径 此次要改成你真实环境ndk所在目录</span><br><span class="line">export NDK_HOME=/home/**/ffmpeg/android-ndk-r14b  </span><br><span class="line"><span class="meta">#</span>android 平台版本</span><br><span class="line">export PLATFORM_VERSION=android-9</span><br><span class="line"><span class="meta">#</span>定义build函数</span><br><span class="line">function build</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#</span>输出编译的哪个平台</span><br><span class="line">echo "start build ffmpeg for $ARCH"</span><br><span class="line"><span class="meta">#</span>传入参数——目标平台linux</span><br><span class="line">./configure --target-os=linux \</span><br><span class="line"><span class="meta">#</span>输出路径</span><br><span class="line">--prefix=$PREFIX --arch=$ARCH \</span><br><span class="line"><span class="meta">#</span>排除 doc</span><br><span class="line">--disable-doc \</span><br><span class="line">--enable-shared \</span><br><span class="line"><span class="meta">#</span>去掉静态库</span><br><span class="line">--disable-static \</span><br><span class="line"><span class="meta">#</span>去掉汇编</span><br><span class="line">--disable-yasm \</span><br><span class="line">--disable-asm \</span><br><span class="line">--disable-symver \</span><br><span class="line">--enable-gpl \</span><br><span class="line"><span class="meta">#</span>去掉。。。</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--disable-ffplay \</span><br><span class="line">--disable-ffprobe \</span><br><span class="line">--disable-ffserver \</span><br><span class="line"><span class="meta">#</span>配置交叉编译环境</span><br><span class="line">--cross-prefix=$CROSS_COMPILE \</span><br><span class="line"><span class="meta">#</span>启用交叉编译环境</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line"><span class="meta">#</span>开启最小编译</span><br><span class="line">--enable-small \</span><br><span class="line">--extra-cflags="-Os -fpic $ADDI_CFLAGS" \</span><br><span class="line">--extra-ldflags="$ADDI_LDFLAGS" \</span><br><span class="line"><span class="meta">$</span>ADDITIONAL_CONFIGURE_FLAG</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">echo "build ffmpeg for $ARCH finished"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>arm</span><br><span class="line">ARCH=arm</span><br><span class="line">CPU=arm</span><br><span class="line"><span class="meta">#</span>输出路径为当前目录下的android下的架构 动态库及头文件会放到这里</span><br><span class="line">PREFIX=$(pwd)/android/$ARCH</span><br><span class="line"><span class="meta">#</span>配置编译工具</span><br><span class="line">TOOLCHAIN=$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span>交叉编译目录</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line">ADDI_CFLAGS="-marm"</span><br><span class="line"><span class="meta">#</span>系统平台目录</span><br><span class="line">SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>x86</span><br><span class="line">ARCH=x86</span><br><span class="line">CPU=x86</span><br><span class="line">PREFIX=$(pwd)/android/$ARCH</span><br><span class="line">TOOLCHAIN=$NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android-</span><br><span class="line">ADDI_CFLAGS="-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32"</span><br><span class="line">SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>（使用时要将上面中文注释都去掉，否则有坑哈<del>~</del>）</p><p>执行android编译脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 build_android.sh</span><br><span class="line"></span><br><span class="line">./build_android.sh</span><br></pre></td></tr></table></figure><p>其中可能遇到一些问题，解决方法可以参见下方说明。<br>编译中：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-15-35-12.png"></p><p>大概编译10分钟左右，我是虚拟机编译可能比较慢，各位可以使用真机编译会快一点。<br>最终编译完成后如下：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-04-46.png"><br>取出我们使用的文件：<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-03-45.png"><br>include头文件使用arm或者x86的都可以。<br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-06-34.png"><br><img src="/2019/09/04/ffmpeg-build/2019-09-04-16-07-07.png"></p><p>如上就是ffmpeg的编译过程。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc is unable to create an executable file.</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure><h3 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yasm/nasm not found or too old. Use --disable-yasm for a crippled build.</span><br></pre></td></tr></table></figure><p>原因：<br>yasm是汇编编译器，ffmpeg为了提高效率使用了汇编指令，如MMX和SSE等。所以系统中未安装yasm时，就会报上面错误。</p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install yasm</span><br></pre></td></tr></table></figure><h3 id="问题3："><a href="#问题3：" class="headerlink" title="问题3："></a>问题3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mark command not found</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译FFmpeg&quot;&gt;&lt;a href=&quot;#编译FFmpeg&quot; class=&quot;headerlink&quot; title=&quot;编译FFmpeg&quot;&gt;&lt;/a&gt;编译FFmpeg&lt;/h2&gt;&lt;p&gt;在Ubuntu中编译Android平台的FFmpeg（arm和x86）&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg系列 二、音乐APP（创建工程）</title>
    <link href="http://www.zydeveloper.com/2019/09/04/ffmpeg-demo/"/>
    <id>http://www.zydeveloper.com/2019/09/04/ffmpeg-demo/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-09-04T11:58:30.047Z</updated>
    
    <content type="html"><![CDATA[<p>通过实现一个音乐APP来演示ffmpeg的使用。</p><a id="more"></a><p>使用AndroidStudio创建项目：</p><img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-34-51.png">下一步<img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-37-22.png">下一步<img src="/2019/09/04/ffmpeg-demo/2019-09-04-16-38-13.png"><p>Finish</p><p>如有报错，要检查是否配置了NDK，如：<br><img src="/2019/09/04/ffmpeg-demo/2019-09-04-19-26-12.png"></p><p>下面来聊聊 CMakeLists.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#cmake的版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#添加一个library 名称为native-lib</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             native-lib.cpp )</span><br><span class="line"></span><br><span class="line">#动态库 log-lib —— 别名  log —— 实际动态库</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">#连接上面的动态库 native-lib 及 log动态库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>在来看看app gradle文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    。。。</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">//编译时加入的动态库</span></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          。。。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build文件路径</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"src/main/cpp/CMakeLists.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看MainActivity加入了哪些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入动态库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = findViewById(R.id.sample_text);</span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要c/c++实现的native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看看native-lib.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//使用C编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="comment">//导出方法 类型jsstring</span></span><br><span class="line">JNIEXPORT jstring</span><br><span class="line"><span class="comment">//JNI调用</span></span><br><span class="line">JNICALL</span><br><span class="line"><span class="comment">//命名为Java_开头 然后是包名.用_替换+类名+native方法名</span></span><br><span class="line">Java_com_music_app_MainActivity_stringFromJNI(</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行验证一下。</p><p>如果cmake没有按照，则需要安装如下：<br><img src="/2019/09/04/ffmpeg-demo/2019-09-04-19-58-13.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过实现一个音乐APP来演示ffmpeg的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://www.zydeveloper.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>三次握手与四次挥手及Http协议</title>
    <link href="http://www.zydeveloper.com/2019/08/16/networkprotocol/"/>
    <id>http://www.zydeveloper.com/2019/08/16/networkprotocol/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-16T08:20:39.977Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下内容摘录自《Android进阶之光》——刘望舒</strong></p><h3 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h3><p>为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-03-06.png"></p><a id="more"></a><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP三次握手的过程如下。</p><p>• 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq） 为x； 接下来客户端进入SYN_SENT状态， 等待服务端的确认。</p><p>• 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置AcknowledgmentNumber（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将SYN设置为1、 seq为y。 服务端将上述所有信息放到SYN+ACK报文段中， 一并发送给客户端， 此时服务端进入SYN_RCVD状态。</p><p>• 第三次握手： 客户端收到服务端的SYN+ACK报文段； 然后将ACK设置为y+1， 向服务端发送ACK报文段， 这个报文段发送完毕后， 客户端和服务端都进入ESTABLISHED （TCP连接成功）状态， 完成TCP的三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务端通过三次握手建立了TCP连接以后， 当数据传送完毕， 断开连接时就需要进行TCP的四次挥手。 其四次挥手如下所示。</p><p>• 第一次挥手： 客户端设置seq和ACK， 向服务端发送一个FIN报文段。 此时， 客户端进入FIN_WAIT_1状态， 表示客户端没有数据要发送给服务端了。</p><p>• 第二次挥手： 服务端收到了客户端发送的FIN报文段， 向客户端回了一个ACK报文段。</p><p>• 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进LAST_ACK状态。</p><p>• 第四次挥手： 客户端收到服务端发送的FIN报文段， 向服务端发送ACK报文段， 然后客户端进入TIME_WAIT状态。 服务端收到客户端的ACK报文段以后， 就关闭连接。 此时， 客户端等待2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-05-25.png"><br>如果有大量的连接， 每次在连接、 关闭时都要经历三次握手、 四次挥手， 这很显然会造成性能低下。<br>因此， HTTP有一种叫作keepalive connections的机制， 它可以在传输数据后仍然保持连接， 当客户端需要再次获取数据时， 直接使用刚刚空闲下来的连接而无须再次握手.<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-06-28.png"></p><h3 id="HTTP协议原理"><a href="#HTTP协议原理" class="headerlink" title="HTTP协议原理"></a>HTTP协议原理</h3><p>作为移动开发者， 开发的应用不免会对网络进行访问。 虽然现在已经有很多开源库帮助我们可以轻而易举地访问网络， 但是我们仍需要去了解网络访问的原理， 这也是一个优秀开发人员所必备的知识点。 </p><h4 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h4><p>HTTP 是一个属于应用层的面向对象的协议， 由于其简捷、 快速的方式， 适用于分布式超媒体信息系统。 它于1990年被提出， 经过几年的使用与发展， 得到不断的完善和扩展。</p><h5 id="1-HTTP的历史版本"><a href="#1-HTTP的历史版本" class="headerlink" title="1.HTTP的历史版本"></a>1.HTTP的历史版本</h5><p>• HTTP 0.9： 1991年发布的第一个版本， 只有一个命令GET， 服务器只能回应HTML格式的字符串。<br>• HTTP 1.0： 1996年发布的版本， 内容量大大增加。 除了GET命令外， 还引入了POST命令和HEAD命令。 HTTP请求和回应的格式除了数据部分， 每次通信都必须包括头信息， 用来描述一些元数据。<br>• HTTP 1.1： 1997发布的版本， 进一步完善了HTTP协议， 直到现在还是最流行的版本。<br>• SPDY协议： 2009年谷歌为了解决 HTTP 1.1效率不高的问题而自行研发的协议。<br>• HTTP 2： 2015年新发布的版本， SPDY 协议的主要特性也在此版本中。</p><h5 id="2-HTTP协议的主要特点"><a href="#2-HTTP协议的主要特点" class="headerlink" title="2.HTTP协议的主要特点"></a>2.HTTP协议的主要特点</h5><p>HTTP协议的主要特点如下。<br>• 支持C/S（客户/服务器） 模式。<br>• 简单快速： 客户向服务器请求服务时， 只需传送请求方法和路径。 请求方法常用的有GET、 HEAD、POST， 每种方法规定了客户与服务器联系的类型不同。 由于 HTTP 协议简单，使得HTTP服务器的程序规模小， 因而通信速度很快。<br>• 灵活： HTTP允许传输任意类型的数据对象。 正在传输的类型由Content-Type加以标记。 • 无连接： 无连接的含义是限制每次连接只处理一个请求。 服务器处理完客户的请求， 并收到客户的应答后， 即断开连接。 采用这种方式可以节省传输时间。<br>• 无状态： HTTP协议是无状态协议， 无状态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据量增大； 而另一方面， 在服务器不需要先前信息时它的应答速度就较快。</p><p>HTTP URL的格式如下所示：</p><p><a href="http://host[＂:＂port][abs_path]" target="_blank" rel="noopener">http://host[＂:＂port][abs_path]</a></p><p>http表示要通过HTTP协议来定位网络资源； host表示合法的Internet主机域名或者IP地址； port指定一个端口号， 为空则使用默认端口80； abs_path指定请求资源的URI（Web上任意的可用资源） 。 HTTP有两种报文， 分别是请求报文和响应报文， 下面先来查看请求报文。</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>HTTP 报文是面向文本的， 报文中的每一个字段都是一些ASCII码串， 各个字段的长度是不确定的。 一般一个HTTP请求报文由请求行、 请求报头、 空行和请求数据4个部分组成<br><img src="/2019/08/16/networkprotocol/2019-08-16-16-09-23.png"></p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h5><p>请求行由请求方法、 URL字段和HTTP协议的版本组成， 格式如下：</p><p>Method Request-URI HTTP-Version CRLF</p><p>其中 Method表示请求方法； Request-URI是一个统一资源标识符； HTTP-Version表示请求的HTTP协议版本； CRLF表示回车和换行（除了作为结尾的CRLF外， 不允许出现单独的CR或LF字符） 。</p><p>HTTP请求方法有8种， 分别是GET、 POST、 HEAD、 PUT、 DELETE、 TRACE、CONNECT、OPTIONS。</p><p> 对于移动开发最常用的就是GET和POST了。</p><p>• GET： 请求获取Request-URI所标识的资源。<br>• POST： 在Request-URI所标识的资源后附加新的数据。<br>• HEAD： 请求获取由Request-URI所标识的资源的响应消息报头。<br>• PUT： 请求服务器存储一个资源， 并用Request-URI作为其标识。<br>• DELETE： 请求服务器删除Request-URI所标识的资源。<br>• TRACE： 请求服务器回送收到的请求信息， 主要用于测试或诊断。<br>• CONNECT： HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>• OPTIONS： 请求查询服务器的性能， 或者查询与资源相关的选项和需求。</p><p>例如， 访问我的CSDN博客地址的请求行：<br>GET <a href="http://zydeveloper.com" target="_blank" rel="noopener">http://zydeveloper.com</a></p><h5 id="2-请求报头"><a href="#2-请求报头" class="headerlink" title="2.请求报头"></a>2.请求报头</h5><p>在请求行之后会有0个或者多个请求报头， 每个请求报头都包含一个名字和一个值， 它们之间用英文冒号“： ”分割。 关于请求报头， 我们会在后面做统一解释。</p><h5 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h5><p>请求数据不在GET方法中使用， 而在POST方法中使用。 POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求报头是Content-Type和Content-Length。</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><img src="/2019/08/16/networkprotocol/2019-08-16-16-11-37.png">HTTP 的响应报文由状态行、 响应报头、 空行、 响应正文组成。 关于响应报头， 我们会在后面做统一解释。 响应正文是服务器返回的资源的内容。 我们先来看看状态行。状态行格式如下所示：<p>HTTP-Version Status-Code Reason-Phrase CRLF</p><p>其中， HTTP-Version表示服务器HTTP协议的版本； Status-Code表示服务器发回的响应状态码； ReasonPhrase表示状态码的文本描述。 状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。</p><p>• 100～199： 指示信息， 收到请求， 需要请求者继续执行操作。<br>• 200～299： 请求成功， 请求已被成功接收并处理。<br>• 300～399： 重定向， 要完成请求必须进行更进一步的操作。<br>• 400～499： 客户端错误， 请求有语法错误或请求无法实现。<br>• 500～599： 服务器错误， 服务器不能实现合法的请求。</p><p>常见的状态码如下。<br>• 200 OK： 客户端请求成功。<br>• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。<br>• 401 Unauthorized： 请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。<br>• 403 Forbidden： 服务器收到请求， 但是拒绝提供服务。<br>• 500 Internal Server Error： 服务器内部错误， 无法完成请求。<br>• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。</p><p>例如， 访问我的CSDN博客地址， 响应的状态行如下所示：</p><p>HTTP/1.1 200 OK</p><h4 id="HTTP的消息报头"><a href="#HTTP的消息报头" class="headerlink" title="HTTP的消息报头"></a>HTTP的消息报头</h4><p>消息报头分为通用报头、 请求报头、 响应报头、 实体报头等。 消息报头由键值对组成， 每行一对， 关键字和值用英文冒号“： ”分隔。</p><h5 id="1-通用报头"><a href="#1-通用报头" class="headerlink" title="1.通用报头"></a>1.通用报头</h5><p>它既可以出现在请求报头， 也可以出现在响应报头中， 如下所示。<br>• Date： 表示消息产生的日期和时间。<br>• Connection： 允许发送指定连接的选项。 例如指定连接是连续的； 或者指定“close”选项， 通知服务器， 在响应完成后， 关闭连接。<br>• Cache-Control： 用于指定缓存指令， 缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现） ， 且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 。</p><h5 id="2-请求报头-1"><a href="#2-请求报头-1" class="headerlink" title="2.请求报头"></a>2.请求报头</h5><p>请求报头通知服务器关于客户端请求的信息。 典型的请求报头如下所示。<br>• Host： 请求的主机名， 允许多个域名同处一个IP地址， 即虚拟主机。<br>• User-Agent： 发送请求的浏览器类型、 操作系统等信息。<br>• Accept： 客户端可识别的内容类型列表， 用于指定客户端接收哪些类型的信息。<br>• Accept-Encoding： 客户端可识别的数据编码。<br>• Accept-Language： 表示浏览器所支持的语言类型。<br>• Connection： 允许客户端和服务器指定与请求/响应连接有关的选项。 例如， 这时为Keep-Alive则表示保持连接。<br>• Transfer-Encoding： 告知接收端为了保证报文的可靠传输， 对报文采用了什么编码方式。</p><h5 id="3-响应报头"><a href="#3-响应报头" class="headerlink" title="3.响应报头"></a>3.响应报头</h5><p>用于服务器传递自身信息的响应。 常见的响应报头如下所示。<br>• Location： 用于重定向接收者到一个新的位置， 常用在更换域名的时候。<br>• Server： 包含服务器用来处理请求的系统信息， 与User-Agent请求报头是相对应的。</p><h5 id="4-实体报头"><a href="#4-实体报头" class="headerlink" title="4.实体报头"></a>4.实体报头</h5><p>实体报头用来定义被传送资源的信息， 其既可用于请求也可用于响应。 请求和响应消息都可以传送一个实体。 常见的实体报头如下所示。<br>• Content-Type： 发送给接收者的实体正文的媒体类型。<br>• Content-Lenght： 实体正文的长度。<br>• Content-Language： 描述资源所用的自然语言。<br>• Content-Encoding： 实体报头被用作媒体类型的修饰符。 它的值指示了已经被应用到实体正文的附加内容的编码， 因而要获得Content-Type报头域中所引用的媒体类型， 必须采用相应的解码机制。<br>• Last-Modified： 实体报头用于指示资源的最后修改日期和时间。<br>• Expires： 实体报头给出响应过期的日期和时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下内容摘录自《Android进阶之光》——刘望舒&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#TCP的三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;/a&gt;TCP的三次握手与四次挥手&lt;/h3&gt;&lt;p&gt;为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。&lt;br&gt;&lt;img src=&quot;/2019/08/16/networkprotocol/2019-08-16-16-03-06.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://www.zydeveloper.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="其他" scheme="http://www.zydeveloper.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动流程</title>
    <link href="http://www.zydeveloper.com/2019/08/15/activitystart/"/>
    <id>http://www.zydeveloper.com/2019/08/15/activitystart/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-27T11:01:30.312Z</updated>
    
    <content type="html"><![CDATA[<p>这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。</p><a id="more"></a><img src="/2019/08/15/activitystart/2019-08-16-16-34-09.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。&lt;/p&gt;
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.zydeveloper.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="启动流程" scheme="http://www.zydeveloper.com/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android 多渠道打包</title>
    <link href="http://www.zydeveloper.com/2019/08/09/ReleaseApp/"/>
    <id>http://www.zydeveloper.com/2019/08/09/ReleaseApp/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-13T02:36:07.086Z</updated>
    
    <content type="html"><![CDATA[<p>我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。<br>这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。</p><a id="more"></a><p>下面我们来介绍如何使用Gradle进行多渠道打包。</p><p>使用Gradle多渠道打包主要使用<strong>ProductFlavors</strong>。</p><h3 id="ProductFlavors"><a href="#ProductFlavors" class="headerlink" title="ProductFlavors"></a>ProductFlavors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">    productFlavors&#123;</span><br><span class="line">        <span class="comment">//小米</span></span><br><span class="line">        xiaomi&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//豌豆荚</span></span><br><span class="line">        wandoujia&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用宝</span></span><br><span class="line">        yingyongbao&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现有3个渠道xiaomi wandoujia yingyongbao。<br>还有flavorDimensions,这个是干嘛用的呢？<br>如果不加就会报：</p><p>Error:All flavors must now belong to a named flavor dimension.Learn more at <a href="https://d.android.com/r/tools/flavorDimensions-missing-error-message.html" target="_blank" rel="noopener">https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</a> </p><p>大概意思是所有的flavors都要属于同一个规格。<br>点击链接地址后（要翻墙）：<br>Plugin 3.0.0 includes a new dependency mechanism that automatically matches variants when consuming a library. This means an app’s debug variant automatically consumes a library’s debug variant, and so on. It also works when using flavors—an app’s redDebug variant will consume a library’s redDebug variant. To make this work, the plugin now requires that all flavors belong to a named flavor dimension —even if you intend to use only a single dimension. Otherwise, you will get the following build error:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:All flavors must now belong to a named flavor dimension.</span><br><span class="line">The flavor <span class="string">'flavor_name'</span> is not assigned to a flavor dimension.</span><br></pre></td></tr></table></figure><p>To resolve this error, assign each flavor to a named dimension, as shown in the sample below. Because dependency matching is now taken care of by the plugin, you should name your flavor dimensions carefully. For example, if all your app and library modules use the foo dimension, you’ll have less control over which flavors are matched by the plugin.</p><p>我们可以参考友盟的渠道包方式在清单文件中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"MY_CHANNEL"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"$&#123;CHANNEL_VALUE&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>同时修改上面的Gradle为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"xiaomi"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"yingyongbao"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后到工程的跟目录下执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemble</span><br></pre></td></tr></table></figure><p>打包成功后：<br><img src="/2019/08/09/ReleaseApp/2019-08-11-18-31-11.png"><br>在app下的output下就可以看看我们刚刚打的渠道包了。<br><img src="/2019/08/09/ReleaseApp/2019-08-11-18-32-50.png"><br>我们看到已经打包好了不同渠道的debug与release版本的APK。</p><p>当然也可以指定打包：</p><p><strong>只打release版本包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assembleRelease</span><br></pre></td></tr></table></figure><p><strong>只打debug版本包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assembleDebug</span><br></pre></td></tr></table></figure><p><strong>只打小米渠道包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemblexiaomi</span><br></pre></td></tr></table></figure><p><strong>只打小米渠道Release包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemblexiaomiRelease</span><br></pre></td></tr></table></figure><p>多渠道打包时我们可能还会加入一些其他设置如：</p><p><strong>加入不同的APPID及版本号</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyyMMdd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.xiaomi.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"xiaomi"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.wandoujia.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        applicationId <span class="string">"com.channel.yingyongbao.application"</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0."</span>+getTime()</span><br><span class="line">        manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"yingyongbao"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包后发现我们的applicationid与版本信息都定制化了。</p><p><strong>manifestPlaceholders中也可以加入多个配置，如加入第三方的APPKEY</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifestPlaceholders = [CHANNEL_VALUE:<span class="string">"wandoujia"</span>,BaiduMapAPPKEY:<span class="string">"s9s87d7f9s6df6s78sd"</span>]</span><br></pre></td></tr></table></figure><p><strong>还可以不同的渠道引入不同的jar包</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">'com.github.leifzhang:IjkLib:0.4.3'</span></span><br><span class="line">    xiaomiImplementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.1.1'</span></span><br><span class="line">    xiaomiImplementation <span class="string">'io.reactivex.rxjava2:rxjava:2.2.11'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用BuildConfig传递配置一些参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">"channelpackage"</span></span><br><span class="line">productFlavors&#123;</span><br><span class="line">    <span class="comment">//小米</span></span><br><span class="line">    xiaomi&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"xiaomi\""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//豌豆荚</span></span><br><span class="line">    wandoujia&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"wandoujia\""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应用宝</span></span><br><span class="line">    yingyongbao&#123;</span><br><span class="line">        ...</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"buildparam"</span>,<span class="string">"\"yingyongbao\""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中获取：</span><br><span class="line"><span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"xiaomi"</span>))&#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"wandoujia"</span>))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (BuildConfig.buildparam.equals(<span class="string">"yingyongbao"</span>))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BuildConfig也有一些默认的配置属性：<br><img src="/2019/08/09/ReleaseApp/2019-08-13-10-35-45.png"></p><p><strong>甚至还可以各渠道包使用不同的资源</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">      main &#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line">      xiaomi&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      wandoujia&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      yingyongbao&#123;</span><br><span class="line">          java.srcDir <span class="string">"src/main/java"</span></span><br><span class="line">          res.srcDir <span class="string">"src/main/res"</span></span><br><span class="line">          jniLibs.srcDir <span class="string">"src/main/jniLibs"</span></span><br><span class="line">          manifest.srcFile <span class="string">"src/main/AndroidManifest.xml"</span></span><br><span class="line">          assets.srcDir <span class="string">"src/main/assets"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题？"><a href="#可能遇到的问题？" class="headerlink" title="可能遇到的问题？"></a>可能遇到的问题？</h3><p>问题1：<br>Android studio Error occurred during initialization of VM 问题解决</p><img src="/2019/08/09/ReleaseApp/2019-08-11-18-08-52.png"><p>问题2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':app:compileWandoujiaDebugJavaWithJavac'</span>.</span><br><span class="line">&gt; Could not find tools.jar. Please check that C:\<span class="function">Program <span class="title">Files</span> <span class="params">(x86)</span>\Java\jre1.8.0_211 contains a valid JDK installation.</span></span><br></pre></td></tr></table></figure><p>环境变量中配置JAVA_HOME 指向jdk所在目录，path中加入%JAVA_HOME%\bin </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。&lt;br&gt;这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。&lt;/p&gt;
    
    </summary>
    
      <category term="打包" scheme="http://www.zydeveloper.com/categories/%E6%89%93%E5%8C%85/"/>
    
    
      <category term="多渠道打包" scheme="http://www.zydeveloper.com/tags/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>帧动画和补间动画</title>
    <link href="http://www.zydeveloper.com/2019/08/08/Animation1/"/>
    <id>http://www.zydeveloper.com/2019/08/08/Animation1/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-09-04T01:18:57.145Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="动画" scheme="http://www.zydeveloper.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>属性动画</title>
    <link href="http://www.zydeveloper.com/2019/08/08/Animation2/"/>
    <id>http://www.zydeveloper.com/2019/08/08/Animation2/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:45:32.038Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="动画" scheme="http://www.zydeveloper.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>自定义View使用</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomView1/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomView1/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:47:51.204Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="自定义View" scheme="http://www.zydeveloper.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>组合View和自定义属性</title>
    <link href="http://www.zydeveloper.com/2019/08/08/CustomView2/"/>
    <id>http://www.zydeveloper.com/2019/08/08/CustomView2/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T09:48:59.484Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android基础" scheme="http://www.zydeveloper.com/tags/Android%E5%9F%BA%E7%A1%80/"/>
    
      <category term="自定义View" scheme="http://www.zydeveloper.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
</feed>

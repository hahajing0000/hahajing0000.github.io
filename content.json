{"meta":{"title":"哈哈镜的技术博客","subtitle":null,"description":null,"author":"Zhangyue","url":"http://www.zydeveloper.com","root":"/"},"pages":[{"title":"分类数据","date":"2019-07-01T03:32:35.000Z","updated":"2019-07-01T08:37:30.100Z","comments":true,"path":"categories/index.html","permalink":"http://www.zydeveloper.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android插件化——动态资源加载","slug":"ResourceDynamicLoad","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-24T03:00:43.487Z","comments":true,"path":"2019/07/24/ResourceDynamicLoad/","link":"","permalink":"http://www.zydeveloper.com/2019/07/24/ResourceDynamicLoad/","excerpt":"之前我们聊了一下Android插件化中的热修复，参考：（Android 热修复），现在我们聊聊资源的动态加载。","text":"之前我们聊了一下Android插件化中的热修复，参考：（Android 热修复），现在我们聊聊资源的动态加载。 顾名思义我们之前的热更新只是解决了代码的加载，对于外部资源我们还不能直接使用。我们工程的资源最终打包后都会放到R.java文件中，然后我们可以获取Resources然后通过类似resources.getDrawable(id);方式通过id来获取我们具体的资源。但对于外部资源也就是不在我们工程中没有被放到R.java文件中的资源我们如果使用呢？","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"}]},{"title":"Dagger2使用","slug":"Dagger2","date":"2019-07-21T16:00:00.000Z","updated":"2019-07-26T02:04:33.995Z","comments":true,"path":"2019/07/22/Dagger2/","link":"","permalink":"http://www.zydeveloper.com/2019/07/22/Dagger2/","excerpt":"Dagger官网地址 Dagger是一个完全静态的、编译时依赖 注入框架 ，适用于Java和Android。它是Square创建的早期版本的一个改编版本，现在由谷歌维护。","text":"Dagger官网地址 Dagger是一个完全静态的、编译时依赖 注入框架 ，适用于Java和Android。它是Square创建的早期版本的一个改编版本，现在由谷歌维护。 说说什么是依赖注入？依赖注入对于刚接触到这个概念的同学可能不太清楚什么意思，说起来也比较简单甚至我们每天都在编写这样的代码。 123456public class A&#123; private B b; public A(B _b)&#123; this.b = _b; &#125;&#125; 上面的代码是不是很常见，我们发现业务类A依赖了业务类B。这就是一个典型的依赖注入。那我们来想想如果A被很多的其他业务类依赖如果A做了修改是不是要修改很多的地方呢？这样我们的Dagger就应该登场了，Dagger就为了解决此类问题而生的。 简单使用：导依赖build.gradle中导入依赖如： 123456dependencies &#123; implementation 'com.google.dagger:dagger-android:2.17' annotationProcessor\"com.google.dagger:dagger-compiler:2.17\" implementation 'com.google.dagger:dagger-android-support:2.17' // if you use the support libraries annotationProcessor 'com.google.dagger:dagger-android-processor:2.17'&#125; 业务类ClassA1234567891011121314package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ClassA &#123; @Inject public ClassA()&#123; &#125; public int Add(int a,int b)&#123; return a+b; &#125;&#125; 业务类ClassB1234567891011121314151617package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ClassB &#123; @Inject public ClassB()&#123; &#125; @Inject ClassA classA; public int Add(int a,int b)&#123; return classA.Add(a,b); &#125;&#125; MainActivityComponent12345678910package com.baweigame.daggerdemoapplication;import android.app.Activity;import dagger.Component;@Componentpublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.baweigame.daggerdemoapplication;import android.app.Activity;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.Toast;import javax.inject.Inject;import dagger.Component;public class MainActivity extends AppCompatActivity &#123; private TextView tvTest; @Inject ClassB classB; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); DaggerMainActivityComponent.create().inject(this); &#125; private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+classB.Add(2,3), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void initView() &#123; tvTest = (TextView) findViewById(R.id.tv_test); &#125;&#125; 我们看上面的例子，比较简单，首先业务类B依赖了业务类A，MainActivity依赖了业务类B，我们发现用Dagger实现起来是不是很清爽。如果我们不用Dagger我的代码大概应该是下面的样子： 1234567--一段伪代码ClassA classA=new ClassA();ClassB classB=new ClassB();classB.set(classA);classB.Add(2,3); 使用Dagger2 1234@InjectClassB classB;classB.Add(2,3); 感觉是不是很简洁。上面的例子中出现了一些新的“东西”，我们发现大多出现的是注解。 下面是Dagger的常用注解。 Componet 注解 1234567@Retention(value=RUNTIME)@Target(value=TYPE)@Documentedpublic @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Component.html 注释接口或抽象类，为其从一组模块生成注入依赖关系的实现。生成的类的类型名称将带有@Component注释，前缀为Dagger。例如，@Component interface MyComponent{…}将生成一个名为DaggerMyComponent的实现。 Subcomponent 注解 123456@Retention(value=RUNTIME)@Target(value=TYPE)@Documentedpublic @interface Subcomponent &#123; Class&lt;?&gt;[] modules() default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Subcomponent.html 从父组件或子组件继承绑定的子组件。 Module 注解 1234567@Documented@Retention(value=RUNTIME)@Target(value=TYPE)public @interface Module&#123; Class&lt;?&gt;[] includes() default &#123;&#125;; Class&lt;?&gt;[] subcomponents default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Module.html Provides 注解 1234@Documented@Target(value=METHOD)@Retention(value=RUNTIME)public @interface Provides&#123;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Provides.html 注释模块的方法，以创建提供程序方法绑定。方法的返回类型绑定到其返回值。组件实现将依赖项作为参数传递给方法。 MapKey 注解 123456@Documented@Target(value=ANNOTATION_TYPE)@Retention(value=RUNTIME)public @interface MapKey&#123; boolean unwrapValue() default true;&#125; 参考链接：https://dagger.dev/api/latest/dagger/MapKey.html 标识用于将Key与方法返回的值关联以组成映射的注释类型。每个使用@ provide和@IntoMap注释的提供程序方法都必须有一个注释来标识映射条目的键。该注释的类型必须使用@MapKey进行注释。通常，键注释只有一个成员，其值用作映射键。 Dagger 2中用到的定义在 JSR-330的其他注解 12345678public @interface Inject &#123;&#125; public @interface Scope &#123;&#125; public @interface Qualifier &#123;&#125; 上面的例子中我们接触到了@Inject和@Component两个注解，下面来说说这两个注解是做什么用的？如果想使用Dagger来实现依赖注入就至少要使用这两个注解：@Inject用于标记需要注入的依赖，或者标记用于提供依赖的方法。依赖注入中最重要的注解，JSR-330标准中的一部分在javax.inject包中。 Dagger 2中有3种方式提供依赖： 1、构造函数注入，如我们上面例子中的 123456ClassA:@Injectpublic ClassA()&#123;&#125; 注：如果存在多个构造函数，我们只能标注一个，不能同时标注多个。 2、属性注入注：被标注的属性不能使用private修饰。 12@InjectClassB b; 3、方法注入 1234@Injectpublic void setClassB(ClassB _b) &#123; this.b = _b;&#125; 方法注入与属性注入基本上没区别，Dagger2会在构造执行完立即调用这个方法，也就是说如果我们需要使用this的时候，使用方法注入是安全的。 @Component用来完成注入，在上面的例子中目标MainActivity就是使用Component完成注入。@Component是Dagger2中最重要的一个注解，Dagger2是使用它来完成依赖注入的。 1234@Componentpublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; 上面是我们上面例子中的接口，使用Component的使用方式，命名一般用 类名+Component 方式，我们rebuild工程后，Dagger2会生成一个Dagger+XXX（如：DaggerMainActivityComponent）的类。 Component中一般使用两种方式定义方法。 void inject(目标类 obj);Dagger2会从目标类开始查找@Inject注解，自动生成依赖注入的代码，调用inject可完成依赖的注入。 Object getObj(); 如：ClassB getClassB();Dagger2会到ClassB类中找被@Inject注解标注的构造器，自动生成提供ClassB依赖的代码，这种方式一般为其他Component提供依赖。 Dagger2以@Component中定义的方法作为起点，到目标类中寻找@Inject标注，生成一系列提供依赖的Factory类和注入依赖的Injector类。而Component则是联系Factory和Injector，最终完成依赖的注入。 我们来看看Dagger2生成的类，我们发现ClassA_Factory ClassB_Factory 这两个类分别对应我们的ClassA ClassB构造函数上的@Inject注解。 Factory类 12345678910111213/** * An &#123;@linkplain Scope unscoped&#125; &#123;@link Provider&#125;. While a &#123;@link Provider&#125; &lt;i&gt;may&lt;/i&gt; apply * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise * the binding logic (&#123;@link Inject&#125; constructors, &#123;@link Provides&#125; methods) upon each call to * &#123;@link #get&#125;. * * &lt;p&gt;Note that while subsequent calls to &#123;@link #get&#125; will create new instances for bindings such * as those created by &#123;@link Inject&#125; constructors, a new instance is not guaranteed by all * bindings. For example, &#123;@link Provides&#125; methods may be implemented in ways that return the same * instance for each call. */public interface Factory&lt;T&gt; extends Provider&lt;T&gt; &#123;&#125; 我们看ClassA_Factory这个工厂类： 12345678910111213141516171819202122232425// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;public final class ClassA_Factory implements Factory&lt;ClassA&gt; &#123; private static final ClassA_Factory INSTANCE = new ClassA_Factory(); @Override public ClassA get() &#123; return provideInstance(); &#125; public static ClassA provideInstance() &#123; return new ClassA(); &#125; public static ClassA_Factory create() &#123; return INSTANCE; &#125; public static ClassA newClassA() &#123; return new ClassA(); &#125;&#125; 这个工厂类使用单例模式给我们提供了实例化ClassA的方法。再看看ClassB_Factory：ClassB依赖了ClassA，所有将ClassA Provider直接传入。 1234567891011121314151617181920212223242526272829303132// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;import javax.inject.Provider;public final class ClassB_Factory implements Factory&lt;ClassB&gt; &#123; private final Provider&lt;ClassA&gt; classAProvider; public ClassB_Factory(Provider&lt;ClassA&gt; classAProvider) &#123; this.classAProvider = classAProvider; &#125; @Override public ClassB get() &#123; return provideInstance(classAProvider); &#125; public static ClassB provideInstance(Provider&lt;ClassA&gt; classAProvider) &#123; ClassB instance = new ClassB(); ClassB_MembersInjector.injectClassA(instance, classAProvider.get()); return instance; &#125; public static ClassB_Factory create(Provider&lt;ClassA&gt; classAProvider) &#123; return new ClassB_Factory(classAProvider); &#125; public static ClassB newClassB() &#123; return new ClassB(); &#125;&#125; MainActivity上的@Inject直接对应MainActivity_MembersInjector,依赖了ClassB，所以ClassB Provider作为参数不直接传递。实现了MembersInjector接口 123456789101112131415161718192021222324252627282930313233343536373839404142/* * Copyright (C) 2012 The Dagger Authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package dagger;/** * Injects dependencies into the fields and methods on instances of type &#123;@code T&#125;. Ignores the * presence or absence of an injectable constructor. * * @param &lt;T&gt; type to inject members of * * @since 2.0 (since 1.0 without the provision that &#123;@link #injectMembers&#125; cannot accept * &#123;@code null&#125;) */public interface MembersInjector&lt;T&gt; &#123; /** * Injects dependencies into the fields and methods of &#123;@code instance&#125;. Ignores the presence or * absence of an injectable constructor. * * &lt;p&gt;Whenever a &#123;@link Component&#125; creates an instance, it performs this injection automatically * (after first performing constructor injection), so if you're able to let the component create * all your objects for you, you'll never need to use this method. * * @param instance into which members are to be injected * @throws NullPointerException if &#123;@code instance&#125; is &#123;@code null&#125; */ void injectMembers(T instance);&#125; 1234567891011121314151617181920212223242526// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.MembersInjector;import javax.inject.Provider;public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123; private final Provider&lt;ClassB&gt; classBProvider; public MainActivity_MembersInjector(Provider&lt;ClassB&gt; classBProvider) &#123; this.classBProvider = classBProvider; &#125; public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;ClassB&gt; classBProvider) &#123; return new MainActivity_MembersInjector(classBProvider); &#125; @Override public void injectMembers(MainActivity instance) &#123; injectClassB(instance, classBProvider.get()); &#125; public static void injectClassB(MainActivity instance, ClassB classB) &#123; instance.classB = classB; &#125;&#125; 最后来看看我们的@Component -&gt; DaggerMainActivityComponent 它将Factory和MainActivity两个类联系到一起。 1234567891011121314151617181920212223242526272829303132333435363738394041// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;public final class DaggerMainActivityComponent implements MainActivityComponent &#123; private DaggerMainActivityComponent(Builder builder) &#123;&#125; public static Builder builder() &#123; return new Builder(); &#125; public static MainActivityComponent create() &#123; return new Builder().build(); &#125; private ClassB getClassB() &#123; return injectClassB(ClassB_Factory.newClassB()); &#125; @Override public void inject(MainActivity activity) &#123; injectMainActivity(activity); &#125; private ClassB injectClassB(ClassB instance) &#123; ClassB_MembersInjector.injectClassA(instance, new ClassA()); return instance; &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectClassB(instance, getClassB()); return instance; &#125; public static final class Builder &#123; private Builder() &#123;&#125; public MainActivityComponent build() &#123; return new DaggerMainActivityComponent(this); &#125; &#125;&#125; @Module和@Provides这两个注解主要弥补@Inject的不足，因为在一些场景下无法使用@Inject，比如：第三方库或者抽象类中。 123456789101112package com.baweigame.daggerdemoapplication;/** * 人类 */public abstract class Person &#123; /** * 说话 * @return */ public abstract String speak();&#125; 12345678910111213package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ChinaPerson extends Person &#123; @Inject ChinaPerson()&#123;&#125; @Override public String speak() &#123; return \"中国人说话\"; &#125;&#125; 12345678910111213package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class AmericaPerson extends Person &#123; @Inject AmericaPerson()&#123;&#125; @Override public String speak() &#123; return \"美国人说话\"; &#125;&#125; 123456789101112131415package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 我们在MainActivity中加入如下代码： 123456789@InjectPersonManager person; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; person.speak(); &#125; &#125;); 重新build运行我们的工程，我们发现出现了错误。因为Person是个抽象类无法实例化。怎么解决类似这样的问题呢？ 我们可以使用@Module @Provides这两个注解来解决，注意这两个注解是成对出现使用的，@Module修饰在 类 上，@Provides修饰在 方法 上。我们把刚才的例子重新修改一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 人类 */public abstract class Person &#123; /** * 说话 * @return */ public abstract String speak();&#125;public class ChinaPerson extends Person &#123; @Override public String speak() &#123; return \"中国人说话\"; &#125;&#125;public class AmericaPerson extends Person &#123; @Override public String speak() &#123; return \"美国人说话\"; &#125;&#125;public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125;@Modulepublic class PersonModule &#123; @Provides Person getChinaPerson()&#123; return new ChinaPerson(); &#125;&#125;@Component(modules=PersonModule.class)public interface MainActivityComponent&#123; void inject(MainActivity activity);&#125;MainActivity中@InjectPersonManager personManager;private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 我们发现原来的两个实现类去掉了构造函数的@Inject，而且加入了PersonModule类，并在MainActivityComponent类的@Component注解中指定了我们的Module &gt;&gt;&gt;&gt; modules=PersonModule.class。我们来看看这个Module是干什么用的 12345678910111213141516171819202122232425262728293031// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;import dagger.internal.Preconditions;public final class PersonModule_GetChinaPersonFactory implements Factory&lt;Person&gt; &#123; private final PersonModule module; public PersonModule_GetChinaPersonFactory(PersonModule module) &#123; this.module = module; &#125; @Override public Person get() &#123; return provideInstance(module); &#125; public static Person provideInstance(PersonModule module) &#123; return proxyGetChinaPerson(module); &#125; public static PersonModule_GetChinaPersonFactory create(PersonModule module) &#123; return new PersonModule_GetChinaPersonFactory(module); &#125; public static Person proxyGetChinaPerson(PersonModule instance) &#123; return Preconditions.checkNotNull( instance.getChinaPerson(), \"Cannot return null from a non-@Nullable @Provides method\"); &#125;&#125; 我们发现这个Module也是一个Factory类。 Module是告诉Component，可以从这里寻找依赖对象。Component就会去找@Provide标注的方法，相当于构造器的@Inject，来提供依赖。 注： @Component可以指定多个@Module Component也可以依赖其它Component @Qualifier和@Named@Qualifier是限定符，而@Named则是基于String的限定符。如上面的例子 12345678910111213@Modulepublic class PersonModule &#123; @Provides Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125; Module中有多个实现之类，这时我们可以通过限定符对其区分 123456789101112131415@Modulepublic class PersonModule &#123; @Provides @Named(\"china\") Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @Named(\"america\") Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125; 在依赖时，如： 1234567891011public class PersonManager &#123; Person person; @Inject public PersonManager(@Named(\"america\") Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 最终我们使用的是“AmericaPerson”实例。@Qualifier注解与@Named注解作用完全一样，但我们发现@Named注解有个弊端就是我们要手写字符串名称，这样很容易出错。@Qualifier注解可以解决这个问题，但该注解是修饰在注解上的，所以我们要这样使用，如： 1234567891011121314151617181920212223242526272829303132333435@Modulepublic class PersonModule &#123; @Provides @ChinaPersonAnn Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @AmericaPersonAnn Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125;@Qualifier@Retention(RetentionPolicy.RUNTIME)@interface ChinaPersonAnn &#123;&#125;@Qualifier@Retention(RetentionPolicy.RUNTIME)@interface AmericaPersonAnn &#123;&#125;public class PersonManager &#123; Person person; @Inject public PersonManager(@ChinaPersonAnn Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; @Component的dependence和@SubComponent上面我们说过Component可以依赖Component还是上面的例子我们新建PersonComponent 12345678@Component(modules = PersonModule.class)public interface PersonComponent &#123; @ChinaPersonAnn Person getChinaPerson(); @AmericaPersonAnn Person getAmericaPerson();&#125; 把我们的PersonManager修改一下去掉注解如: 1234567891011public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 新建PersonManagerModule 1234567@Modulepublic class PersonManagerModule &#123; @Provides PersonManager providePersonManager(@ChinaPersonAnn Person _persion)&#123; return new PersonManager(_persion); &#125;&#125; 新建PersonManagerComponent 1234@Component(modules = PersonManagerModule.class,dependencies = PersonComponent.class)public interface PersonManagerComponent &#123; PersonManager getManager();&#125; MainActivityComponent修改为： 1234@Component(dependencies=PersonManagerComponent.class)public interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; MainActivity修改为： 123456789101112131415161718192021DaggerMainActivityComponent.builder() .personManagerComponent( DaggerPersonManagerComponent.builder() .personComponent( DaggerPersonComponent.create() ).build() ).build() .inject(this);@InjectPersonManager personManager;private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 这就是Component的dependencies的用法，Component依赖了其他Component。如果换成Subcomponent，可以把它理解为继承的关系，则修改Component部分就可以： 1234567891011121314151617181920212223242526272829@Component(modules = PersonModule.class)public interface PersonComponent2 &#123; PersonManagerComponent2 personManagerComponent();&#125;@Subcomponent(modules = PersonManagerModule.class)public interface PersonManagerComponent2 &#123; MainActivityComponent2 mainActivityComponent();&#125;@Subcomponentpublic interface MainActivityComponent2 &#123; void Inject(MainActivity activity);&#125;MainActivity修改为：@InjectPersonManager personManager;DaggerPersonComponent2.create().personManagerComponent().mainActivityComponent().Inject(this);tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 上面代码开起来有些不合常理，PersonComponent2管理了PersonManagerComponent2和MainActivityComponent2。Dagger2生成的代码中，Subcomponent标记的类是Componpent的内部类。即MainActivityComponent2是PersonManagerComponent2的内部类，PersonManagerComponent2又是MainActivityComponent2的内部类。 比较适合使用Subcomponent的几个场景：很多工具类都需要使用到Application的Context对象，此时就可以用一个Component负责提供，我们可以命名为AppComponent。需要用到的context对象的SharePreferenceComponent，ToastComponent就可以它作为Subcomponent存在了。 而且在AppComponent中，我们可以很清晰的看到有哪些子Component，因为在里面我们定义了很多XxxComponent (Module… modules) 每个ActivityComponent也是可以作为AppComponent的Subcomponent，这样可以更方便的进行依赖注入，减少重复代码。 Set注入 Map注入 @MapKeySet注入之前的注入都是单个对象，Set注入即可以将多个对象注入到Set中。我们使用PersonModule加入@IntoSet加入到Set中。 123456789101112131415161718192021222324252627282930@Modulepublic class PersonModule &#123; @Provides @IntoSet Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @IntoSet Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125;MainActivity 中：@InjectSet&lt;Person&gt; personSet;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (Person person: personSet) &#123; Toast.makeText(MainActivity.this, \"\"+person.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); 我们也可以使用如下方式同时向Set注入多个对象：PersonModule.java 12345678@Provides@ElementsIntoSetpublic Set&lt;Person&gt; getPlayers()&#123; HashSet set = new HashSet&lt;&gt;(); set.add(new ChinaPerson()); set.add(new AmericaPerson()); return set;&#125; 使用@ElementsIntoSet 并且返回Set对象 Map注入Map注入与Set注入的区别是Map注入需要Key，如： 123456789101112131415161718192021222324252627@Provides@IntoMap@StringKey(\"china\")Person getChinaPerson()&#123; return new ChinaPerson();&#125;@Provides@IntoMap@StringKey(\"America\")Person getAmericaPerson()&#123; return new AmericaPerson();&#125;MainActivity 中：@InjectMap&lt;String,Person&gt; personMap;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (Map.Entry&lt;String,Person&gt; person: personMap.entrySet()) &#123; Toast.makeText(MainActivity.this, \"\"+person.getKey()+\" \"+person.getValue().speak(), Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); dagger还提供了一些内置的key类型，包裹classKey,IntKey等，android辅助包中也提供了ActivityKey等。 我们看看StringKey的源码,是被MapKey修饰的，下面我们来聊聊Mapkey。 1234567@Documented@Target(METHOD)@Retention(RUNTIME)@MapKeypublic @interface StringKey &#123; String value();&#125; @MapKeyMapKey支持的类型有：基本数据类型StringClass枚举类型注解类型以上数据类型的数组Enum如： 12345678910111213141516171819202122232425262728enum MyEnum &#123; ABC, DEF;&#125;@MapKey@interface MyEnumKey &#123; MyEnum value();&#125;@MapKey@interface MyNumberClassKey &#123; Class&lt;? extends Number&gt; value();&#125;@Moduleclass MyModule &#123; @Provides @IntoMap @MyEnumKey(MyEnum.ABC) static String provideABCValue() &#123; return \"value for ABC\"; &#125; @Provides @IntoMap @MyNumberClassKey(BigDecimal.class) static String provideBigDecimalValue() &#123; return \"value for BigDecimal\"; &#125;&#125; 复合Key，如： 123456789101112131415161718192021@MapKey(unwrapValue = false)@Retention(value=RUNTIME)public @interface GameInfo &#123; String name(); float price();&#125;@Modulepublic class GameModule &#123; @Provides @IntoMap @GameInfo(name = \"game\",price = 100f) public String getGameInfo()&#123; return \"gameinfo\"; &#125;&#125;MainActivity 中：@InjectMap&lt;GameInfo,String&gt; mGameInfoStringMap; 如上如果编译失败，要加入如下依赖：implementation ‘com.google.auto.value:auto-value:1.5.1’provided ‘javax.annotation:jsr250-api:1.0’ Lazy 和 ProviderDagger2还支持Lazy模式，通过Lazy或者Provider模拟提供的实例，在@Inject的时候并不初始化，而是等到你要使用的时候，主动调用其.get方法来获取实例。 如： 123456789101112@InjectLazy&lt;PersonManager&gt; personManager;@InjectProvider&lt;PersonManager&gt; personManager;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.get().speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); Lazy和Provider的区别在于： Lazy每次get都是同一实例Provider每次get都是新实例 @Scope和@SingletonOne reason to break your application’s component up into Subcomponents is to use scopes. With normal, unscoped bindings, each user of an injected type may get a new, separate instance. But if the binding is scoped, then all users of that binding within the scope’s lifetime get the same instance of the bound type. 上面是google给的解释。简单理解为在不使用@Scope的情况下，可能每次注入的对象都会是一个新的不同的对象，而@Scope能限制被注入的对象，在同一个@Scope的生命周期(lifetime)中都只存在一个且仅有一个对象，是不是很像单例。 @Scope是标志一个注入器/对象的使用范围也可以说是用来管理依赖的生命周期（也可以理解为作用域）的。它也是用来修饰注解的，而@Singleton则是@Scope的实现。 123456789/** * Identifies a type that the injector only instantiates once. Not inherited. * * @see javax.inject.Scope @Scope */@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 顾名思义@Scope用来管理生命周期，所以我们的命名要尽量规范详细，如：ActivityScopeFragmentScopeApplicationScope。。。 @Scope所描述的注解用于两个地方： @Component类@Module中@Provides方法 如下内容引用：》》》Dagger2 知识梳理(4) - @Scope 注解的使用 如有侵权请告知！！！ 在单个Component情况下来使用Scope 1234567891011121314151617181920212223242526272829@Documented@Retention(RUNTIME)@Scopepublic @interface TestScope &#123;&#125;PersonModule 中@Provides@Named(\"China\")@TestScopePerson getChinaPerson()&#123; return new ChinaPerson();&#125;@Provides@Named(\"America\")Person getAmericaPerson()&#123; return new AmericaPerson();&#125;MainActivityComponent 中@Component(modules=PersonModule.class)@TestScopepublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; 如果在Module的@Provides方法上加上了@Scope声明，那么在与他关联的Component上也必须加上相同的@Scope声明在Component实例的生命周期内，只会创建一个由@Provides方法返回的实例，可以理解为局部单例。 在多个Component情况下来使用Scope 在依赖或者继承的组织方式中，如果其中一个Component声明了@Scope，那么其它的Component也需要声明。在依赖关系中，被依赖的Component和需要依赖的Component的@Scope不能相同 在依赖关系中，需要依赖的Component的@Scope不可以为@Singleton。 在组织关系中，子Component的@Scope不可以和父Component的@Scope相同： 在组织关系中，如果父Component的@Scope不为@Singleton，那么子Component的@Scope可以为@Singleton。 这些限制是由Dagger2在编译时去检查的，其目的是保证使用者不要对@Scope产生滥用的现象，因为@Scope的目的是 在特定作用域内控制被注入实例的复用 示例：(1) ScopeApp对应于我们平时的Application类，并提供了全局的ScopeAppData类，在其ScopeAppComponent上有@Singleton注解。 123456789101112131415@Singleton@Component(modules = &#123;ScopeAppModule.class&#125;)public interface ScopeAppComponent &#123; public ScopeAppData getScopeAppData(); //如果它被其它的Component依赖，那么需要声明getXXX方法。&#125;@Modulepublic class ScopeAppModule &#123; @Provides @Singleton public ScopeAppData provideScopeAppData() &#123; return new ScopeAppData(); &#125;&#125; (2) ScopeActivity对应于一个主页面，其内部包含了ScopeActivitySharedData和ScopeActivityNormalData，前者在ScopeActivityComponent的生命周期内保持唯一性，并带有PerScopeActivity注解。 123456789101112131415161718192021@Component(dependencies = &#123;ScopeAppComponent.class&#125;, modules = &#123;ScopeActivityModule.class&#125;)@PerScopeActivitypublic interface ScopeActivityComponent &#123; public void inject(ScopeActivity scopeActivity); ScopeFragmentComponent scopeFragmentComponent();&#125;@Modulepublic class ScopeActivityModule &#123; @Provides @PerScopeActivity public ScopeActivitySharedData provideScopeActivityData() &#123; return new ScopeActivitySharedData(); &#125; @Provides public ScopeActivityNormalData provideScopeActivityNormalData() &#123; return new ScopeActivityNormalData(); &#125;&#125; (3) ScopeFragment对于于Activity下的一个子界面，它和ScopeActivityComponent是继承关系，并带有@PerScopeFragment注解： 123456789101112131415@Subcomponent(modules = &#123;ScopeFragmentModule.class&#125;)@PerScopeFragmentpublic interface ScopeFragmentComponent &#123; public void inject(ScopeFragment scopeFragment);&#125;@Modulepublic class ScopeFragmentModule &#123; @Provides @PerScopeFragment public ScopeFragmentData provideScopeFragmentData() &#123; return new ScopeFragmentData(); &#125;&#125; 以上三个部分的关系为： ScopeActivityComponent依赖于ScopeAppComponent ScopeFragmentComponent继承于ScopeActivityComponent 它们的Module上都有用@Scope描述的注解：@Singleton、@PerScopeActivity，@PerScopeFragment。 验证一下： App 1234567891011121314public class ScopeApp extends Application &#123; private ScopeAppComponent mScopeAppComponent; @Override public void onCreate() &#123; super.onCreate(); mScopeAppComponent = DaggerScopeAppComponent.builder().scopeAppModule(new ScopeAppModule()).build(); &#125; public ScopeAppComponent getAppComponent() &#123; return mScopeAppComponent; &#125;&#125; Activity类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ScopeActivity extends AppCompatActivity &#123; private static final String TAG = ScopeActivity.class.getSimpleName(); private ScopeActivityComponent mScopeActivityComponent; @Inject ScopeAppData mScopeAppData; @Inject ScopeActivitySharedData mScopeActivitySharedData1; @Inject ScopeActivitySharedData mScopeActivitySharedData2; @Inject ScopeActivityNormalData mScopeActivityNormalData1; @Inject ScopeActivityNormalData mScopeActivityNormalData2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scope); getScopeActivityComponent().inject(this); TextView tvData = (TextView) findViewById(R.id.tv_scope_activity); String result = \"[ScopeActivity Space] \\n mScopeAppData=\" + mScopeAppData + \"\\n\\n\" + \"mScopeActivitySharedData1=\" + mScopeActivitySharedData1 + \"\\n\\n\" + \"mScopeActivitySharedData2=\" + mScopeActivitySharedData2 + \"\\n\\n\" + \"mScopeActivityNormalData1=\" + mScopeActivityNormalData1 + \"\\n\\n\" + \"mScopeActivityNormalData2=\" + mScopeActivityNormalData2; tvData.setText(result); &#125; public ScopeActivityComponent getScopeActivityComponent() &#123; if (mScopeActivityComponent == null) &#123; ScopeAppComponent scopeAppComponent = ((ScopeApp) getApplication()).getAppComponent(); mScopeActivityComponent = DaggerScopeActivityComponent.builder().scopeAppComponent(scopeAppComponent).build(); &#125; return mScopeActivityComponent; &#125;&#125; Fragment类 1234567891011121314151617181920212223242526272829303132333435363738394041public class ScopeFragment extends Fragment &#123; private ScopeActivity mScopeActivity; @Inject ScopeAppData mScopeAppData; @Inject ScopeActivitySharedData mScopeActivitySharedData; @Inject ScopeActivityNormalData ScopeActivityNormalData; @Inject ScopeFragmentData mScopeFragmentData; @Override public void onAttach(Context context) &#123; super.onAttach(context); mScopeActivity = (ScopeActivity) context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_scope, container, false); mScopeActivity.getScopeActivityComponent().scopeFragmentComponent().inject(this); TextView tv = (TextView) rootView.findViewById(R.id.tv_scope_fragment); String result = \"[ScopeFragment Space] \\n mScopeAppData=\" + mScopeAppData + \"\\n\\n\" + \"mScopeActivitySharedData1=\" + mScopeActivitySharedData + \"\\n\\n\" + \"ScopeActivityNormalData=\" + ScopeActivityNormalData + \"\\n\\n\" + \"mScopeFragmentData=\" + mScopeFragmentData; tv.setText(result); return rootView; &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 由上面例子中的现象，可以总结出以下几点： ScopeAppData：该数据是由ScopeAppModule提供的，而它加上了@Singleton注解，并且我们调用的是同一个对象，因此在Activity和Fragment中地址相同。 ScopeActivitySharedData：在它的provide方法上，我们加上了@PerScopeActivity注解，因此在Activity和Fragment中，它的地址相同。 ScopeActivityNormalData：虽然在提供它的ScopeActivityModule中加上了@PerScopeActivity注解，但是在provide方法上没有声明，因此无论是在Activity，还是在Fragment中，都是指向不同的地址。 ScopeFragmentData：用于演示如何通过继承的方式，来实现依赖注入。 名词解释： JSR-330JSR即Java Specification Requests，意思是java规范提要。而JSR-330则是 Java依赖注入标准 本文参考文章： Dagger2 最清晰的使用教程 Dagger2 使用（二）","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://www.zydeveloper.com/tags/Dagger2/"}]},{"title":"Android 进程保活（五）JobSheduler进程重生","slug":"processlive5","date":"2019-07-15T16:00:00.000Z","updated":"2019-07-16T08:21:45.779Z","comments":true,"path":"2019/07/16/processlive5/","link":"","permalink":"http://www.zydeveloper.com/2019/07/16/processlive5/","excerpt":"JobSheduler在android 5.0以上版本可用，所以该方案适合5.0以上的系统版本。关于JobService与JobSheduler不清楚的可参考官网API文档： 官网JobService 官网JobScheduler JobScheduler是用于计划基于应用进程的多种类型任务的api接口。当任务执行时，系统会为应用持有WakeLock，所以应用不需要做多余的确保设备唤醒的工作。 JobService继承自Service，是用于处理JobScheduler中规划的异步请求的特殊Service","text":"JobSheduler在android 5.0以上版本可用，所以该方案适合5.0以上的系统版本。关于JobService与JobSheduler不清楚的可参考官网API文档： 官网JobService 官网JobScheduler JobScheduler是用于计划基于应用进程的多种类型任务的api接口。当任务执行时，系统会为应用持有WakeLock，所以应用不需要做多余的确保设备唤醒的工作。 JobService继承自Service，是用于处理JobScheduler中规划的异步请求的特殊Service 使用JobService必须先在AndroidManifest.xml中声明service和权限 1&lt;service android:name=\"MyJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"/ &gt; 我们来实现一个JobService，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.baweigame.mvvmdemoapplication;import android.app.job.JobInfo;import android.app.job.JobParameters;import android.app.job.JobScheduler;import android.app.job.JobService;import android.content.ComponentName;import android.content.Context;import android.os.Build;import android.support.annotation.RequiresApi;import android.util.Log;@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)public class MyJobService extends JobService &#123; @Override public void onCreate() &#123; super.onCreate(); startJob(); &#125; /** * 开启工作 */ private void startJob() &#123; JobInfo.Builder builder = new JobInfo.Builder(1001, new ComponentName(getPackageName(), MyJobService.class.getName())); //500毫秒调用一次 builder.setPeriodic(500); builder.setPersisted(true); JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE); jobScheduler.schedule(builder.build()); &#125; @Override public boolean onStartJob(JobParameters params) &#123; Log.d(\"123\", \"onStartJob: ...\"); return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; Log.d(\"123\", \"onStopJob: ...\"); return false; &#125;&#125; 在Activity启动服务，如: 1startService(new Intent(this,MyJobService.class)); 我们添加了一个JobService并在服务启动及停止时加入了日志输出。使用JobScheduler来调度服务，每500毫秒调用一次。我们启动App来观察服务启动log的打印情况，启动后每500毫秒打印一次。我们手动关闭所有进程，发现服务停止后有复活了，正常输出了log信息。 注意：清单文件中加入相关权限。如： 1&lt;service android:name=\".MyJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"&gt;&lt;/service&gt; Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（四）使用“前台服务”保活","slug":"processlive4","date":"2019-07-15T16:00:00.000Z","updated":"2019-07-16T01:55:49.528Z","comments":true,"path":"2019/07/16/processlive4/","link":"","permalink":"http://www.zydeveloper.com/2019/07/16/processlive4/","excerpt":"前台服务方式保活实际是利用了Android前台服务的一个漏洞。即：android api 在18之前的版本我们调用startForeground来提高应用程序的oom_adj值，在18版本后我们需要使用Service中启动一个InnerService两个服务同时startForeground并且绑定相同的ID，然后stop掉InnerService,这样做是将通知栏上的图标移除。 关于oom_adj可参考： Android 进程保活（一）写在前面","text":"前台服务方式保活实际是利用了Android前台服务的一个漏洞。即：android api 在18之前的版本我们调用startForeground来提高应用程序的oom_adj值，在18版本后我们需要使用Service中启动一个InnerService两个服务同时startForeground并且绑定相同的ID，然后stop掉InnerService,这样做是将通知栏上的图标移除。 关于oom_adj可参考： Android 进程保活（一）写在前面 用Demo来演示一下 首先创建一个Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.baweigame.mvvmdemoapplication;import android.app.Notification;import android.app.NotificationManager;import android.app.Service;import android.content.Intent;import android.os.Build;import android.os.Handler;import android.os.IBinder;import android.support.annotation.RequiresApi;public class MyService extends Service &#123; public static final int NOTIFICATION_ID=0x11; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException(\"Not yet implemented\"); &#125; @Override public void onCreate() &#123; super.onCreate(); //API Version 18以下 if (Build.VERSION.SDK_INT &lt;Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; startForeground(NOTIFICATION_ID, new Notification()); &#125; else &#123; //API Version 18以上 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); startService(new Intent(this, InnerService.class)); &#125; &#125; public static class InnerService extends Service&#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN) @Override public void onCreate() &#123; super.onCreate(); //发送与上面服务中ID相同的Notification，然后将其取消并取消自己的前台显示 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; stopForeground(true); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(NOTIFICATION_ID); stopSelf(); &#125; &#125;,100); &#125; &#125;&#125; 在没有使用这个服务前我们看看oom_adj的值变化，首先直接启动App，我们看一下oom_adj的值，如：我这里面进行了2次操作，分别为打开App 点击了Home键我们发现打开App时我们的oom_adj值为0点击Home键后我们的oom_adj的值为6 下面我们开启上面的服务在来验证一下oom_adj值的变化。 1startService(new Intent(this,MyService.class)); 我们发现刚打开App时我们的oom_adj值是0，点击Home键后我们的oom_adj的值为1 即使用这种方式确实提高了我们App的优先级提高了存活概率。 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 热修复","slug":"hotupdate","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-15T10:19:21.663Z","comments":true,"path":"2019/07/15/hotupdate/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/hotupdate/","excerpt":"","text":"类如何加载？java中我们一般使用ClassLoader进行类的加载。android 中 我们都知道最后的代码文件都会被打包成dex格式的文件；class文件包含在dex文件中。加载dex中class文件我们需要使用DexClassLoader或者PathClassLoader。 类加载器PathClassLoader可以加载Android系统中的dex文件DexClassLoader可以加载任意目录的dex/zip/apk/jar文件 , 但是要指定optimizedDirectory.这两个类加载器都继承BaseDexClassLoader, 并且在构造函数中, DexClassLoader多传入了一个optimizedDirectory。 我们来看看 BaseDexClassLoader 1234567public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)&#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125;&#125; 构造方法中初始化了pathList, 传入三个参数 , 分别为dexPath：目标文件路径（一般是dex文件，也可以是jar/apk/zip文件）所在目录。热修复时用来指定新的dexoptimizedDirectory：dex文件的输出目录（因为在加载jar/apk/zip等压缩格式的程序文件时会解压出其中的dex文件，该目录就是专门用于存放这些被解压出来的dex文件的）。libraryPath：加载程序文件时需要用到的库路径。parent：父加载器 类的加载过程如下方法用于加载dex中的class文件， 拿到初始化完成的 pathList 之后 , 根据类名找出相应的class字节码文件, 如果没有异常直接返回class. 1234567891011121314@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); //从pathList中找到相应类名的class文件 Class c = pathList.findClass(name, suppressedExceptions); //判空, 抛出异常 if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c;&#125; DexPathList构造函数. 我们在BaseDexClassLoader中实例化DexPathList需要用到findClass方法, 在BaseDexClassLoader的findClass中, 本质调用了DexpathList的fndClass方法 1234567891011121314151617public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) &#123; this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); // save dexPath for BaseDexClassLoader this.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); this.nativeLibraryDirectories = splitPaths(libraryPath, false); this.systemNativeLibraryDirectories = splitPaths(System.getProperty(\"java.library.path\"), true); List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories); allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories); this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, null, suppressedExceptions); &#125; 将传入的classLoader保存起来 , 接下来使用makePathElements方法 ,来初始化Element数组 1234567891011121314151617181920212223242526private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123; // 1.创建Element集合 ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); // 2.遍历所有dex文件（也可能是jar、apk或zip文件） for (File file : files) &#123; ZipFile zip = null; DexFile dex = null; String name = file.getName(); ... // 如果是dex文件 if (name.endsWith(DEX_SUFFIX)) &#123; dex = loadDexFile(file, optimizedDirectory); // 如果是apk、jar、zip文件（这部分在不同的Android版本中，处理方式有细微差别） &#125; else &#123; zip = file; dex = loadDexFile(file, optimizedDirectory); &#125; ... // 3.将dex文件或压缩文件包装成Element对象，并添加到Element集合中 if ((zip != null) || (dex != null)) &#123; elements.add(new Element(file, false, zip, dex)); &#125; &#125; // 4.将Element集合转成Element数组返回 return elements.toArray(new Element[elements.size()]);&#125; DexPathList的构造函数是将一个个的目标（可能是dex、apk、jar、zip , 这些类型在一开始时就定义好了）封装成一个个Element对象，最后添加到Element集合中。 Android的类加载器（不管是PathClassLoader，还是DexClassLoader），它们最后只认dex文件，而loadDexFile()是加载dex文件的核心方法，可以从jar、apk、zip中提取出dex findClass 方法123456789101112131415public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null;&#125; 在DexPathList的构造函数中已经初始化了dexElements，所以这个方法就很好理解了，只是对Element数组进行遍历，一旦找到类名与name相同的类时，就直接返回这个class，找不到则返回null。 热修复的实现方法加载class会使用BaseDexClassLoader，在加载时，会遍历文件下的element，并从element中获取dex文件 class文件在dex里面 , 找到dex的方法是遍历数组 , 那么热修复的原理, 就是将改好bug的dex文件放进集合的头部, 这样遍历时会首先遍历修复好的dex并找到修复好的类。 一个Demo演示热修复的应用（代码修复）建立TestClass 类文件内容如下： 123456package com.baweigame.hotupdateapplication;public class TestClass &#123; public int Debug()&#123; return 10/0; &#125;&#125; 除0会报异常。这个类即我们需要热更新修复的类。 在MainActivity中调用如下：即点击 按钮 将发生错误。 下面是热修复核心工具类：FixDexUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.baweigame.hotupdateapplication;import android.content.Context;import android.os.Environment;import android.support.annotation.NonNull;import android.widget.Toast;import java.io.File;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.util.HashSet;import dalvik.system.DexClassLoader;import dalvik.system.PathClassLoader;public class FixDexUtil &#123; private static final String DEX_SUFFIX = \".dex\"; private static final String APK_SUFFIX = \".apk\"; private static final String JAR_SUFFIX = \".jar\"; private static final String ZIP_SUFFIX = \".zip\"; public static final String DEX_DIR = \"odex\"; private static final String OPTIMIZE_DEX_DIR = \"optimize_dex\"; private static HashSet&lt;File&gt; loadedDex = new HashSet&lt;&gt;(); static &#123; loadedDex.clear(); &#125; /** * 加载补丁，使用默认目录：data/data/包名/files/odex * * @param context */ public static void loadFixedDex(Context context) &#123; loadFixedDex(context, null); &#125; /** * 加载补丁 * * @param context 上下文 * @param patchFilesDir 补丁所在目录 */ public static void loadFixedDex(Context context, File patchFilesDir) &#123; // dex合并之前的dex doDexInject(context, loadedDex); &#125; /** * 验证是否需要热修复 */ public static boolean isGoingToFix(@NonNull Context context) &#123; boolean canFix = false; File externalStorageDirectory = null;//Environment.getExternalStorageDirectory(); // 遍历所有的修复dex , 因为可能是多个dex修复包 File fileDir = externalStorageDirectory != null ? externalStorageDirectory : new File(context.getFilesDir(), DEX_DIR);// data/data/包名/files/odex（这个可以任意位置） File[] listFiles = fileDir.listFiles(); if (listFiles==null)&#123; return false; &#125; for (File file : listFiles) &#123; if (file.getName().startsWith(\"classes\") &amp;&amp; (file.getName().endsWith(DEX_SUFFIX) || file.getName().endsWith(APK_SUFFIX) || file.getName().endsWith(JAR_SUFFIX) || file.getName().endsWith(ZIP_SUFFIX))) &#123; loadedDex.add(file);// 存入集合 //有目标dex文件, 需要修复 canFix = true; &#125; &#125; return canFix; &#125; private static void doDexInject(Context appContext, HashSet&lt;File&gt; loadedDex) &#123; String optimizeDir = appContext.getFilesDir().getAbsolutePath() + File.separator + OPTIMIZE_DEX_DIR; // data/data/包名/files/optimize_dex（这个必须是自己程序下的目录） File fopt = new File(optimizeDir); if (!fopt.exists()) &#123; fopt.mkdirs(); &#125; try &#123; // 1.加载应用程序dex的Loader PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader(); for (File dex : loadedDex) &#123; // 2.加载指定的修复的dex文件的Loader DexClassLoader dexLoader = new DexClassLoader( dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录 fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁） null,// 加载dex时需要的库 pathLoader// 父类加载器 ); // 3.开始合并 // 合并的目标是Element[],重新赋值它的值即可 /** * BaseDexClassLoader中有 变量: DexPathList pathList * DexPathList中有 变量 Element[] dexElements * 依次反射即可 */ //3.1 准备好pathList的引用 Object dexPathList = getPathList(dexLoader); Object pathPathList = getPathList(pathLoader); //3.2 从pathList中反射出element集合 Object leftDexElements = getDexElements(dexPathList); Object rightDexElements = getDexElements(pathPathList); //3.3 合并两个dex数组 Object dexElements = combineArray(leftDexElements, rightDexElements); // 重写给PathList里面的Element[] dexElements;赋值 Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错 setField(pathList, pathList.getClass(), \"dexElements\", dexElements); &#125; Toast.makeText(appContext, \"修复完成\", Toast.LENGTH_SHORT).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 反射给对象中的属性重新赋值 */ private static void setField(Object obj, Class&lt;?&gt; cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException &#123; Field declaredField = cl.getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(obj, value); &#125; /** * 反射得到对象中的属性值 */ private static Object getField(Object obj, Class&lt;?&gt; cl, String field) throws NoSuchFieldException, IllegalAccessException &#123; Field localField = cl.getDeclaredField(field); localField.setAccessible(true); return localField.get(obj); &#125; /** * 反射得到类加载器中的pathList对象 */ private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; return getField(baseDexClassLoader, Class.forName(\"dalvik.system.BaseDexClassLoader\"), \"pathList\"); &#125; /** * 反射得到pathList中的dexElements */ private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException &#123; return getField(pathList, pathList.getClass(), \"dexElements\"); &#125; /** * 数组合并 */ private static Object combineArray(Object arrayLhs, Object arrayRhs) &#123; Class&lt;?&gt; clazz = arrayLhs.getClass().getComponentType(); int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组） int j = Array.getLength(arrayRhs);// 得到原dex数组长度 int k = i + j;// 得到总数组长度（补丁数组+原dex数组） Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组 System.arraycopy(arrayLhs, 0, result, 0, i); System.arraycopy(arrayRhs, 0, result, i, j); return result; &#125;&#125; 在MainActivity中调用，如： 123if (FixDexUtil.isGoingToFix(mContext)) &#123; FixDexUtil.loadFixedDex(mContext, Environment.getExternalStorageDirectory());&#125; 生成dex文件用于新版本修复旧版本bug： 修改TestClass,如下： 123456package com.baweigame.hotupdateapplication;public class TestClass &#123; public int Debug()&#123; return 10/2; &#125;&#125; rebuild project 找到class文件，如下：将TestClass.class 文件拷贝出来，注意：拷贝的存放路径要与工程包名目录一致，如：找到dx.bat 并将目录配置到环境变量中。 dx.bat目录 如： C:\\Users\\zhangyue\\AppData\\Local\\Android\\Sdk\\build-tools\\28.0.3 编译dex包命令 dx –dex –output c:\\Users\\zhangyue\\Desktop\\classes.dex C:\\Users\\zhangyue\\Desktop\\dex 生成的classes.dex 即升级修复的新版本dex文件。 将dex文件push到 /data/data/包名/files/odex 目录下，运行程序查看修复结果。 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 双亲委派机制 BootStrapClassLoader：启动类加载器，该ClassLoader是jvm在启动时创建的，用于加载 $JAVA_HOME/jre/lib下面的类库（或者通过参数-Xbootclasspath指定）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不能直接通过引用进行操作。 ExtClassLoader：扩展类加载器，该ClassLoader是在sun.misc.Launcher里作为一个内部类ExtClassLoader定义的（即 sun.misc.Launcher$ExtClassLoader），ExtClassLoader会加载 $JAVA_HOME/jre/lib/ext下的类库（或者通过参数-Djava.ext.dirs指定）。 AppClassLoader：应用程序类加载器，该ClassLoader同样是在sun.misc.Launcher里作为一个内部类AppClassLoader定义的（即 sun.misc.Launcher$AppClassLoader），AppClassLoader会加载java环境变量CLASSPATH所指定的路径下的类库，而CLASSPATH所指定的路径可以通过System.getProperty(“java.class.path”)获取；当然，该变量也可以覆盖，可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的class目录）。 CustomClassLoader：自定义类加载器，该ClassLoader是指我们自定义的ClassLoader，比如tomcat的StandardClassLoader属于这一类；当然，大部分情况下使用AppClassLoader就足够了。 ClassLoader的双亲委派机制是这样的（这里先忽略掉自定义类加载器CustomClassLoader： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"},{"name":"热修复","slug":"热修复","permalink":"http://www.zydeveloper.com/tags/热修复/"}]},{"title":"Android 进程保活（一）写在前面","slug":"processlive1","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-19T06:14:24.353Z","comments":true,"path":"2019/07/15/processlive1/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive1/","excerpt":"进程保活对于作为Android开发的程序猿应该并不陌生，一些App对于进程保活有着很强烈的需求。比如一个IM类App对于信息接收就需要app进程一直存活才可以，否则对方好友发送了信息，如果app已经被干掉从而导致无法收到信息，这样的用户体验是很差的。用户很可能会直接卸载掉你的app，因为这样的app对于用户来说没什么使用价值。","text":"进程保活对于作为Android开发的程序猿应该并不陌生，一些App对于进程保活有着很强烈的需求。比如一个IM类App对于信息接收就需要app进程一直存活才可以，否则对方好友发送了信息，如果app已经被干掉从而导致无法收到信息，这样的用户体验是很差的。用户很可能会直接卸载掉你的app，因为这样的app对于用户来说没什么使用价值。 我们都知道Android的App一般最少存在一个进程，或者多个进程。目前的主流App一般都会使用多进程的方案。多进程起到的作用可以增加进程存活的概率或者隔离危险代码（容易产生Crash）或者可以用来突破方法数65535的限制。 进程划分？Android中的进程通常被划分了5级，我们按重要程度由高到低排列一下： 1、Foreground process——前台进程某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。 2、Visible process——可见进程拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。拥有绑定到可见（或前台）Activity 的 Service 3、Service process——服务进程某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。 4、Background process——后台进程在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onPause方法 5、Empty process——空进程某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处。 什么是内存阀值？我们知道Android的App退到后台时，系统并不会直接结束掉该app。而是将其缓存起来，当打开的app越来越多后导致内存不足，那么系统就开始结束不重要的进程从而释放其内存提供给优先级高的应用使用。这套杀进程释放内存的机制，Android中被叫做Low Memory Killer。那么这个内存不足怎么来规定呢，我们知道不足一定有一个限定值，这个值就是内存阀值。使用cat /sys/module/lowmemorykiller/parameters/minfree可以查看手机的内存阀值。 内存不足时进程进行回收是按上面的重要程度有低到高进行回收。 进程是有优先级的，adj来表示我们的优先级。oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，我们可以通过cat /proc/进程id/oom_adj可以看到当前进程的adj值。我们发现 设置 的进程优先级现在是10，我们现在没有启动 设置。下面我们来打开设置app并查看一下现在的优先级。我们看当前 设置 的进程优先级已经变为了0。优先级有了提高。oom_adj主要由一下几种，注意每个手机厂商可能不一样。 从上面我们发现在系统内存紧张的情况下会优先杀时oom_adj值比较大的应用，反过来说我们将oom_adj的值变小也可以减少系统杀死我们应用的概率。 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（三）1像素方案保活","slug":"processlive3","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-16T01:55:40.136Z","comments":true,"path":"2019/07/15/processlive3/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive3/","excerpt":"1像素保活方案坊间流传是手机QQ的保活的方案。什么意思呢？就是我们在手机锁屏时开启一个Activity，为了不让用户有感知，让这个Activity大小为1像素并设置透明无切换动画。在开启屏幕时把这个Activity关掉。","text":"1像素保活方案坊间流传是手机QQ的保活的方案。什么意思呢？就是我们在手机锁屏时开启一个Activity，为了不让用户有感知，让这个Activity大小为1像素并设置透明无切换动画。在开启屏幕时把这个Activity关掉。 一个Demo来演示一下创建一个Android工程，默认为我们生成一个MainActivity，这是我们程序的入口Activity。我们通过观察oom_adj值来看一下优先级。首先启动App，我们看oom_adj的值我们看oom_adj的值为0，所以当前优先级很高不会被系统杀死。我们点击home键或者back键来观察一下oom_adj。我们发现oom_adj的值已经变为了6，所以退到后台的app在资源紧张的情况下就有可能被杀死了。 关于oom_adj可参考: Android 进程保活（一）写在前面 从而我们可通过提高oom_adj的值可以使我们的app被系统杀死的概率变低。 我们使用的1像素保活方案就是应用了这点。 创建一个1像素的Activity，如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.baweigame.mvvmdemoapplication;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Gravity;import android.view.Window;import android.view.WindowManager;public class OnePXActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_one_px); Log.d(\"123\", \"onCreate: OnePxActivity...\"); createOnePxWindow(); OnePxManager.getInstance().setActivity(this); &#125; /** * 创建1像素窗体 */ private void createOnePxWindow() &#123; Window window = getWindow(); //放在左上角 window.setGravity(Gravity.START | Gravity.TOP); WindowManager.LayoutParams attributes = window.getAttributes(); //宽高为1个像素 attributes.width = 1; attributes.height = 1; attributes.x = 0; attributes.y = 0; window.setAttributes(attributes); &#125;&#125; 同时为了更好的隐藏，可以给这个1像素Activity设置样式如： 123456&lt;style name=\"OnePxStyle\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@null&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;/style&gt; 即设置了背景透明及没有切换效果，这样可以更好的隐藏自己。 123&lt;activity android:name=\".OnePXActivity\" android:theme=\"@style/OnePxStyle\"&gt; &lt;/activity&gt; 创建一个管理类来控制Activity的开启与关闭，如下： 123456789101112131415161718192021222324252627282930313233343536package com.baweigame.mvvmdemoapplication;import android.app.Activity;import android.content.Context;import android.content.Intent;import java.lang.ref.WeakReference;public class OnePxManager &#123; private static OnePxManager instance=new OnePxManager(); public static OnePxManager getInstance()&#123; return instance; &#125; private OnePxManager()&#123;&#125; private WeakReference&lt;Activity&gt; weakReference; public void setActivity(Activity activity)&#123; weakReference=new WeakReference&lt;Activity&gt;(activity); &#125; public void startActivity(Context context)&#123; Intent intent = new Intent(context, OnePXActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; public void finishActivity()&#123; if (weakReference!=null)&#123; if (weakReference.get()!=null)&#123; weakReference.get().finish(); &#125; &#125; &#125;&#125; 我们开启与关闭Activity的时机设计为屏幕锁屏时开启，屏幕解锁时关闭。所以编写如下广播： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.mvvmdemoapplication;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class OnePxReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //开屏 if (intent.getAction().equals(Intent.ACTION_SCREEN_ON))&#123; Log.d(\"123\", \"onReceive: user screen_on\"); closeActivity(); &#125; //锁屏 else if(intent.getAction().equals(Intent.ACTION_SCREEN_OFF))&#123; Log.d(\"123\", \"onReceive: user screen_off\"); openActivity(context); &#125; &#125; /** * 开启1像素Activity * @param context */ private void openActivity(Context context) &#123; OnePxManager.getInstance().startActivity(context); &#125; /** * 关闭Activity */ private void closeActivity() &#123; OnePxManager.getInstance().finishActivity(); &#125;&#125; 由于SCREEN_ON与SCREEN_OFF这两个广播不能使用静态方式注册，所以我们在MainActivity中动态注册广播。 1234567891011121314151617181920212223242526272829package com.baweigame.mvvmdemoapplication;import android.content.Intent;import android.content.IntentFilter;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); registerOnePxReceiver(this); &#125; /** * 注册1像素广播 * @param mainActivity */ private void registerOnePxReceiver(MainActivity mainActivity) &#123; IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(Intent.ACTION_SCREEN_ON); intentFilter.addAction(Intent.ACTION_SCREEN_OFF); registerReceiver(new OnePxReceiver(),intentFilter); &#125;&#125; 我们来运行一下看看效果。 为了让我们的这种方法更加可靠，可以将广播注册过程放到服务中去，并将服务运行在另一个进程如： 12&lt;service android:name=\".OnePxService\" android:process=\":onepx_service\"/&gt; 同时提高存活概率可以使用双进程守护方案来进一步加强，可参考： Android 进程保活（二）双服务进程包活 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（二）双服务进程包活","slug":"processlive2","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-16T01:55:28.762Z","comments":true,"path":"2019/07/15/processlive2/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive2/","excerpt":"1、双进程守护保活方案","text":"1、双进程守护保活方案 创建aidl接口文件用于进程间通信，如下：方法自定义。 创建本地服务及远程服务 LocalService RemoteService 清单配置如下： 本地服务代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.baweigame.processliveapplication;import android.app.Notification;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.RemoteException;import android.util.Log;/*** 本地服务*/public class LocalService extends Service &#123; private IMyAidlInterface remoteService; private MyBinder myBinder; public LocalService() &#123; &#125; ServiceConnection serviceConnection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder binder) &#123; Log.d(\"zzzz\", \"onServiceConnected: localservice is connected...\"); try &#123;// remoteService = (IMyAidlInterface) binder;// remoteService.getData(\"localservice\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(\"zzzz\", \"onServiceDisconnected: localservice is disconnected...\"); startService(new Intent(LocalService.this,RemoteService.class)); bindService(new Intent(LocalService.this,RemoteService.class),serviceConnection, Context.BIND_IMPORTANT); &#125; &#125;; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(\"zzzz\", \"onStartCommand: localservice is onstartcommand...\"); startForeground(1,new Notification()); bindService(new Intent(this,RemoteService.class),serviceConnection, Context.BIND_IMPORTANT); startDo(); return START_STICKY; &#125; private void startDo() &#123; handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; handler.sendEmptyMessage(0); handler.postDelayed(this,2*1000); &#125; &#125;,2*1000); &#125; private Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.d(\"zzzz\", \"handleMessage: ****************************************\"); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; myBinder = new MyBinder(); return myBinder; &#125; private class MyBinder extends IMyAidlInterface.Stub&#123; @Override public String getData(String name) throws RemoteException &#123; return LocalService.class.getSimpleName(); &#125; &#125;&#125; 远程服务代码文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.baweigame.processliveapplication;import android.app.Notification;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;/*** 远程服务*/public class RemoteService extends Service &#123; private MyBinder myBinder; public RemoteService() &#123; &#125; ServiceConnection serviceConnection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(\"zzzz\", \"onServiceConnected: remoteservice is connected...\");// try &#123;// IMyAidlInterface localService= (IMyAidlInterface) service;// localService.getData(RemoteService.class.getSimpleName());// &#125; catch (RemoteException e) &#123;// e.printStackTrace();// &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(\"zzzz\", \"onServiceDisconnected: remoteservice is disconnected...\"); startService(new Intent(RemoteService.this,LocalService.class)); bindService(new Intent(RemoteService.this,LocalService.class),serviceConnection,Context.BIND_IMPORTANT); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; myBinder = new MyBinder(); return myBinder; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(\"zzzz\", \"onStartCommand: remoteservice is onstartcommand...\"); startForeground(1,new Notification()); bindService(new Intent(this,LocalService.class),serviceConnection, Context.BIND_IMPORTANT); return START_STICKY; &#125; private class MyBinder extends IMyAidlInterface.Stub&#123; @Override public String getData(String name) throws RemoteException &#123; return RemoteService.class.getSimpleName(); &#125; &#125;&#125; MainActivity中启动服务使用静态注册广播接收系统重启或者屏幕解锁等系统广播来启动本地服务增加存活概率清单文件：广播文件：使用电源锁保证息屏后服务不被杀清单文件中加入权限： Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"OKHttp使用","slug":"OKHttp","date":"2019-07-12T16:00:00.000Z","updated":"2019-07-15T06:01:16.028Z","comments":true,"path":"2019/07/13/OKHttp/","link":"","permalink":"http://www.zydeveloper.com/2019/07/13/OKHttp/","excerpt":"","text":"","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://www.zydeveloper.com/tags/OKHttp/"}]},{"title":"MVP架构","slug":"MVP","date":"2019-07-09T16:00:00.000Z","updated":"2019-07-10T06:56:46.855Z","comments":true,"path":"2019/07/10/MVP/","link":"","permalink":"http://www.zydeveloper.com/2019/07/10/MVP/","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://www.zydeveloper.com/tags/MVP/"}]},{"title":"Jetpack系列之ViewModel","slug":"jetpack-viewmodel","date":"2019-07-08T16:00:00.000Z","updated":"2019-07-11T06:44:41.640Z","comments":true,"path":"2019/07/09/jetpack-viewmodel/","link":"","permalink":"http://www.zydeveloper.com/2019/07/09/jetpack-viewmodel/","excerpt":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。","text":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。 聊聊ViewModel主要作用？1、应用于MVVM模式将UI层与Model业务层分离。2、可以存储数据（如：fragment之间共享数据）3、为UI提供数据 Android Framwork管理UI控件的生命周期，比如Activity和Fragment。Framwork可能决定销毁或重新创建一个UI控件，以响应某些用户操作或设备事件。如果系统销毁或重新创建一个UI控件，您存储在其中的任何与UI相关的临时数据都将丢失。例如，您的应用程序可能在其中一个活动中包含一个用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。对于简单数据,活动可以使用方法在onCreate()中恢复数据,但这种方法只适用于少量的数据可以序列化反序列化,而不是潜在的大量数据的用户列表或位图。另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁这些调用后对其进行清理，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改重新创建对象的情况下，这是对资源的浪费，因为对象可能不得不重新发出它已经发出的调用。活动和片段等UI控件主要用于显示UI数据、响应用户操作或处理操作系统通信(如权限请求)。要求UI控制器也负责从数据库或网络加载数据，会使类膨胀。将过多的责任分配给UI控制器可能导致一个类试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式将过多的责任分配给UI控制器也会使测试变得更加困难。将视图数据所有权从UI控制器逻辑中分离出来更容易也更有效。 体系结构组件为负责UI准备数据的UI控制器提供ViewModel helper类。在配置更改期间自动保留ViewModel对象，以便它们所持有的数据可以立即用于下一个Activity或Fragment实例。例如，如果您需要在应用程序中显示用户列表，请确保将获取和保存用户列表的责任分配给ViewModel，而不是activity或fragment。 ViewModel对象的作用域是在获取ViewModel时传递给ViewModelProvider的生命周期。视图模型一直保存在内存中，直到它的作用域永久消失:对于Activity，当它结束时，而对于Fragment，当它被分离时。下图说明了一个活动在进行旋转并完成时的各种生命周期状态。图中还显示了关联活动生命周期旁边的ViewModel的生命周期。这个图说明了活动的状态。同样的基本状态也适用于片段的生命周期。 参考：https://developer.android.google.cn/topic/libraries/architecture/viewmodel 基本使用首先导依赖：implementation ‘android.arch.lifecycle:extensions:1.1.1’ ViewModel类 12345678910111213141516171819202122232425package com.baweigame.databindingjavademoapplication;import android.arch.lifecycle.MutableLiveData;import android.arch.lifecycle.ViewModel;public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;PersonBean&gt; personLiveData=new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;PersonBean&gt; getPersonLiveData() &#123; return personLiveData; &#125; public void setPersonLiveData(MutableLiveData&lt;PersonBean&gt; personLiveData) &#123; this.personLiveData = personLiveData; &#125; public void loadPersonData()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; personLiveData.postValue(new PersonBean(\"小明\",20,\"北京市海淀区\")); &#125; &#125;).start(); &#125;&#125; Activity中使用 123456ViewModelProviders.of(this).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); 然后，可在Activity中观察数据变化。 Fragment中共享数据 由于ViewModel的生命周期一直在内存中存在知道被销毁，所以可以在Fragment间传递数据，如：有两个Fragment Fragment1： 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125;&#125;); Fragment2: 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); Activity中更新数据： 1ViewModelProviders.of(this).get(MyViewModel.class).loadPersonData(); 这样就实现了Fragment间的数据共享。 ViewModelProviders 类提供了4个方法 of() 创建新的 ViewModelProvider 对象。 1234ViewModelProviders.of(Fragment)ViewModelProviders.of(FragmentActivity)ViewModelProviders.of(Fragment, Factory)ViewModelProviders.of(FragmentActivity, Factory) 我们发现方法中出现了一个Factory参数 Factory 接口定义创建 ViewModel 的接口 create()。public interface Factory { T create(@NonNull Class modelClass);} Android内置了2个 Factory 实现类，分别是： AndroidViewModelFactory 实现类，可以创建 ViewModel 和 AndroidViewModel 子类对象。NewInstanceFactory 类，只可以创建 ViewModel 子类对象。 假设有种场景我们需要向ViewModel实现子类中传递参数该如何处理呢？ 实现如上需求，如： 原ViewModel实现类中加入有参构造如： 我们可以使用新建Factory之类来进行参数传递，如： 123456789101112131415161718package com.baweigame.databindingjavademoapplication;import android.arch.lifecycle.ViewModel;import android.arch.lifecycle.ViewModelProvider;import android.support.annotation.NonNull;public class MyFactory extends ViewModelProvider.NewInstanceFactory &#123; private String params; public MyFactory(String _params)&#123; params=_params; &#125; @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; return (T) new MyViewModel(params); &#125;&#125; 然后在activity中使用将原有代码修改为如： 123456ViewModelProviders.of(this,new MyFactory(\"我是参数\")).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); 我们发现在of中加入了我们的自定义工厂子类并传递了参数。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"ViewModel","slug":"ViewModel","permalink":"http://www.zydeveloper.com/tags/ViewModel/"}]},{"title":"Jetpack系列之Room","slug":"jetpack-room","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:26.492Z","comments":true,"path":"2019/07/02/jetpack-room/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-room/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Room","slug":"Room","permalink":"http://www.zydeveloper.com/tags/Room/"}]},{"title":"Mvvm架构","slug":"mvvm","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T08:14:30.612Z","comments":true,"path":"2019/07/02/mvvm/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/mvvm/","excerpt":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科","text":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科 Mvvm架构与Mvp架构相同的是同样分为三层，并且对应层的职责功能相同： Model层——主要负责提供数据。Model层提供数据如：网络数据及本地数据库中提取的数据，及数据结构如实体bean类。 ViewModel层——同Mvp中P层，主要负责业务逻辑的处理。通过使用官方的Databinding组件进行View层的数据更新等。ViewModel层中不包含任何View层api，使用双向绑定对View层控件进行数据更新，同样不需要View层的引用。 View层——负责界面的显示，View层只管负责UI展示不涉及任何业务逻辑，持有ViewModel层的引用。 Mvvm与Mvp的最大区别在于ViewModel层中不持有View层的引用，这样可以解耦View层，即View层的修改不会影响ViewModel层，同样使代码可测试性增强。也同样给项目团队协作提供可能，这样负责UI开发的人员和负责开发业务功能的人员可以专心关注自己的工作。 Mvvm带来的好处还有减少了很多代码，比如：findViewById 和 操作UI的代码。 举个栗子： 新建工程 一般我们习惯与建立模块后再模块下建立mvvm结构目录。如下图： 实体bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.baweigame.mvvmdemoapplication.student.model;public class StudentBean &#123; private String name; private int age; private String address; public StudentBean(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public StudentBean() &#123; &#125; @Override public String toString() &#123; return \"StudentBean&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; ViewModel类 123456789101112131415161718192021222324252627282930313233package com.baweigame.mvvmdemoapplication.student.viewmodel;import android.databinding.ObservableBoolean;import android.databinding.ObservableField;import android.os.Handler;import android.os.Message;public class StudentViewModel &#123; public final ObservableBoolean isVisible=new ObservableBoolean(false); public final ObservableBoolean isSuccess=new ObservableBoolean(false); public final ObservableBoolean isFalied=new ObservableBoolean(false); public final ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); public void addStudent()&#123; mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; isVisible.set(true); isSuccess.set(true); name.set(\"小红同学\"); &#125; &#125;,3000); &#125; private Handler mHandler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;;&#125; Activity Layout xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;import type=\"android.view.View\"&gt;&lt;/import&gt; &lt;variable name=\"viewmodel\" type=\"com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel\"&gt;&lt;/variable&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;viewmodel.name&#125;\" android:textColor=\"@android:color/holo_orange_dark\" android:textSize=\"20sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"2dp\" android:background=\"@android:color/holo_green_light\" android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\"&gt; &lt;/View&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"添加成功\" android:textColor=\"@android:color/holo_red_light\" android:textSize=\"20sp\" android:visibility=\"@&#123;viewmodel.isSuccess?View.VISIBLE:View.GONE&#125;\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;()-&gt;viewmodel.addStudent()&#125;\" android:text=\"添加学生\" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Activity代码 12345678910111213141516171819202122package com.baweigame.mvvmdemoapplication.student.view;import android.databinding.DataBindingUtil;import android.databinding.ViewDataBinding;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import com.baweigame.mvvmdemoapplication.R;import com.baweigame.mvvmdemoapplication.databinding.ActivityMainBinding;import com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); StudentViewModel studentViewModel = new StudentViewModel(); studentViewModel.name.set(\"小明同学\"); viewDataBinding.setViewmodel(studentViewModel); &#125;&#125; 代码比较简单不再解释。 Databinding可参考Jetpack系列之Databinding 这里还有一个坑，我们的xml中设置了android:visibility属性 使用代码如： 1android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\" 原因是因为使用了View导致编译时错误，解决方案：也就是导入View。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"Mvvm","slug":"Mvvm","permalink":"http://www.zydeveloper.com/tags/Mvvm/"}]},{"title":"Jetpack系列之Lifecycles","slug":"jetpack-lifecycles","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T05:54:41.117Z","comments":true,"path":"2019/07/02/jetpack-lifecycles/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-lifecycles/","excerpt":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.","text":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves. 生命周期感知组件执行操作，以响应另一个组件生命周期状态的更改，例如Activity和Fragment。这些组件可以帮助您生成更有组织、更容易维护的轻量级代码。 一个常见的模式是在Activity和Fragment的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码错误的增加。通过使用生命周期感知组件，您可以将依赖组件的代码从生命周期方法转移到组件本身。 参考链接：https://developer.android.google.cn/topic/libraries/architecture/lifecycle Android中的大多数应用程序组件都具有生命周期,如：Activity/Service/Fragment等。生命周期由操作系统或Framwork管理。它们是Android工作原理的核心，应用程序必须遵守它们。不这样做可能会引发内存泄漏，甚至应用程序崩溃。 可能我们之前的使用方法，如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 上面代码来源于https://developer.android.google.cn/topic/libraries/architecture/lifecycle 尽管这个示例看起来很好，但是在实际应用程序中，最终会有太多的调用来管理UI和其他组件，以响应生命周期的当前状态。管理多个组件会在生命周期方法中放置大量的代码，比如onStart()和onStop()，这使得它们很难维护。此外，不能保证组件在活动或片段停止之前启动。如果我们需要执行长时间运行的操作，比如一些配置check in onStart()，这一点尤其重要。这可能会导致一个竞态条件，即onStop()方法在onStart()之前结束，从而使组件存活的时间超过所需的时间。 Lifecycle是一个类，它保存关于组件(如Activity或Fragment)生命周期状态的信息，并允许其他对象观察这个状态。Lifecycle使用两个主要枚举来跟踪其关联组件的生命周期状态: Event从框架和Lifecycle类发出的生命周期事件。这些事件映射到活动和片段中的回调事件。State声明生命周期对象跟踪的组件的当前状态。 上图演示了States与events的对应关系。 先看一下如下两个系统接口： 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 1234public interface LifecycleObserver &#123;&#125; 一个Demo演示： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.databindingapplication;import android.arch.lifecycle.Lifecycle;import android.arch.lifecycle.LifecycleObserver;import android.arch.lifecycle.OnLifecycleEvent;import android.util.Log;public class ActivityLifecycleObserver implements LifecycleObserver &#123; private final String TAG=ActivityLifecycleObserver.class.getSimpleName(); private Lifecycle mLifecycle; public ActivityLifecycleObserver(Lifecycle lifecycle) &#123; mLifecycle=lifecycle; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; Log.d(TAG, \"onStart: ...\"); Log.d(TAG, \"onStart: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate()&#123; Log.d(TAG, \"onCreate: ...\"); Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause()&#123; Log.d(TAG, \"onPause: ...\"); Log.d(TAG, \"onPause: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125;&#125; MainActivity的onCreate中将上面的Observer注册为观察者（典型的观察者模式） 1getLifecycle().addObserver(new ActivityLifecycleObserver(getLifecycle())); 我们看到注解 OnLifecycleEvent 即 我们上面提到的Event。再来看一下输出：我们注意到上面的代码中，如： 1Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); 打印了State信息。输出的State信息与我们上图中的State信息对应。 如上就是我们用一个小demo演示了一下lifecycle的使用方法。 可能大家看后还不清楚lifecycle究竟再我们实际工作开发中能帮我们处理什么问题，下面我给大家列举一个使用场景中的实际问题，如：MVP架构这个大家应该都不陌生，Prestener层之前我们的管理代码片段如下： 12345678910111213class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 相信如上代码段会出现在大家的工程项目中，这样的后果是导致相应生命周期中代码臃肿也不利于维护。使用lifecycle可以解决如上问题，如： 123456789101112public interface IPresenter extends LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event);&#125; 这样让我们的BasePresenter实现这个接口，在我们的Presenter中就可以感知到组件的生命周期，在接口方法中做业务处理即可。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Lifecycles","slug":"Lifecycles","permalink":"http://www.zydeveloper.com/tags/Lifecycles/"}]},{"title":"Jetpack系列之Databinding","slug":"jetpack-databinding","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T06:06:46.321Z","comments":true,"path":"2019/07/02/jetpack-databinding/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-databinding/","excerpt":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。","text":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 jetpack官网地址：https://developer.android.google.cn/jetpack/ 什么是Android Jetpack？官方定义如下： Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！ Databinding概念解释参考链接：https://developer.android.google.cn/topic/libraries/data-binding/ 数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 比较一下Databinding给我们带来的不同之处。 看一段我们之前的代码 12TextView textView = findViewById(R.id.tv_login_username);textView.setText(User.getUserName()); 这段代码很简单，实现的逻辑是找到TextView控件并设置其Text属性值。再来看看Databinding的实现方式。 12&lt;TextView android:text=\"@&#123;User.userName&#125;\" /&gt; 我们发现Databinding方式并没有使用java代码就实现了控件查找并设置Text属性值。带来的好处是其维护起来更简单、方便。还可以提高应用性能，并且有助于防止内存泄漏以及避免空指针异常。 Demo演示Databinding使用过程第一步 开启databinding在工程build.gradle文件中开启databinding，如: 第二步 新建实体bean类\\业务实体类新建实体bean类，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.baweigame.databindingapplication;import android.databinding.ObservableField;public class StudentBean &#123; public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); private int id; private int age; private String address; public StudentBean() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; public ObservableField name=new ObservableField&lt;&gt;();这里有个很有趣的东西如上。——ObservableFields一个类中的单独的字段做观察，如果数据有变动则会收到通知。除了ObservableField，还有ObservableBoolean、ObservableInt… 另一种实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class StudentBean extends BaseObservable&#123; @Bindable private String name; private int id; private int age; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 我们发现了一些差异，首先继承了BaseObservable参考链接：https://developer.android.google.cn/reference/android/databinding/BaseObservable @Bindable 可以加到字段名上 也可以加载 get方法上 效果是一样 set方法上手动调用notifyPropertyChanged通知数据更新，注意：参数要写BR.XX（这是一个坑） 上面两处差异部分我们先记录下来，下面具体Demo演示时我们看具体有什么用处。 新建响应点击事件业务处理类，如： 12345public class ClickListener&#123; public void btnClickListener(View view)&#123; studentBean.setName(\"新名字\"); &#125;&#125; 第三步 新建布局文件新建layout布局并设置绑定关系 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"student\" type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt;&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(student.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.address&#125;\"/&gt; &lt;Button android:text=\"点击\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;clickHandler.btnClickListener&#125;\"/&gt;&lt;/LinearLayout&gt;&lt;/layout&gt; 首先我们看根节点变成了layout 并且下方为data节点 ，data节点中有包含了variable节点，这些节点都什么作用，下面我们一一说明： 最外层用layout标签，databinding固定写法 data标签就是一个让我们数据绑定的标签 variable放置绑定的变量 variable包含type和name属性 type属性 标识变量类型，比如java.lang.String这就是String类型，com.baweigame.databindingapplication.StudentBean 这个就是一个定义的一个StudentBean类型com.baweigame.databindingapplication.MainActivity.ClickListener是我定义用于处理事件的业务类型 name属性 表示的就是我定义的一个变量名称，这个变量名称我们会在下方的布局和对应的java代码中用到 variable还有另一种写法如： 123456789101112&lt;data&gt; &lt;!--&lt;variable--&gt; &lt;!--name=\"student\"--&gt; &lt;!--type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt;--&gt; &lt;import type=\"com.baweigame.databindingapplication.StudentBean\" &lt;variable name=\"student\" type=\"StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt; 其中@{}就是我们绑定数据的写法。 其中大家应该注意 1@&#123;String.valueOf(Student.age)&#125; 表达式即可以嵌入表达式，可以在表达式语言中使用以下运算符和关键字： 基本运算 + - / * % 字符串连接 + 逻辑表达式 &amp;&amp; || 二进制 &amp; | ^ 一元运算符 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较运算 == &gt; &lt; &gt;= &lt;= instanceof 分组 () 字面值 - 字符，字符串，数字， null 强转 方法调用 属性访问 数组访问 [] 三元运算符 ?: 绑定处理事件 1@&#123;clickHandler.btnClickListener&#125; 事件处理部分：(方法与butterknife处理事件类似) 1234public void btnClickListener(View view)&#123;// studentBean.name.set(\"新名字\"); studentBean.setName(\"新名字\"); &#125; 大家注意到方法中我们修改了studentbean类中name值，这里面为什么修改name值ui上会同步更新就是因为上面我们的两种设置，如：方法一： 1public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); 方法二： 1234public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; 最后 设置Activity content就是MainActivity中的setContentView处理，我们之前设置内容视图方法都是使用setContentView，在Databinding中我们需要如下设置方法： 12345678 ActivityMainBinding dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);// studentBean.name.set(\"小明\"); studentBean.setName(\"小明\"); studentBean.setAddress(\"北京市朝阳区\"); studentBean.setAge(20); studentBean.setId(1); dataBinding.setStudent(studentBean); dataBinding.setClickHandler(new ClickListener()); ActivityMainBinding即自动生成的绑定类，我们看这个类生成的类名是我们的layout名+Binding组成，即生成规则=layout名+Binding当然你也可以自定义类名，方法如： 1MyStudent dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 如果是Fragment、Listview、Recyclerview 使用则，需要使用inflate()绑定类或者DataBindingUtil类方法： 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);或者ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); 如上即通过一个小Demo演示了DataBinding的具体使用方式。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Databinding","slug":"Databinding","permalink":"http://www.zydeveloper.com/tags/Databinding/"}]},{"title":"Jetpack系列之LiveData","slug":"jetpack-livedata","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-12T02:42:01.585Z","comments":true,"path":"2019/07/02/jetpack-livedata/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-livedata/","excerpt":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如Activity、Fragment或Service。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于STARTED或RESUMED状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为 DESTROYED时，此关系允许删除观察者。这对于Activity和Fragment尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当Activity和Fragment的生命周期被破坏时，它们会立即取消订阅。","text":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如Activity、Fragment或Service。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于STARTED或RESUMED状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为 DESTROYED时，此关系允许删除观察者。这对于Activity和Fragment尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当Activity和Fragment的生命周期被破坏时，它们会立即取消订阅。 LiveData有哪些优点呢? 1、保证UI与数据状态同步 LiveData遵循观察者模式。当生命周期状态发生变化时，LiveData通知观察者对象。可以合并代码来更新这些观察者对象中的UI。观察者可以在每次发生更改时更新UI，而不是每次应用程序数据更改时都更新UI。 2、不会发生内存泄漏 观察者被绑定到生命周期对象，并在其关联的生命周期被销毁后进行清理。 3、停止activity不会造成crash 如果观察者的生命周期是不活动的，例如在后堆栈中的活动，那么它不会接收任何LiveData事件。 4、不需要手动管理生命周期 UI组件只观察相关数据，不停止或恢复观察。LiveData自动管理所有这些，因为它在观察过程中知道相关的生命周期状态变化。 5、总是最新的数据 如果一个生命周期变为不活动的，它将在再次活动时接收最新的数据。例如，在后台的活动在返回到前台后立即接收最新的数据。 6、适当的配置更改 如果某个Activity或Fragment由于配置更改(如设备旋转)而重新创建，它将立即接收最新可用数据。 7、共享数据 可以使用singleton模式扩展LiveData对象来包装系统服务，以便在您的应用程序中共享它们。LiveData对象连接到系统服务一次，然后任何需要该资源的观察者都可以查看LiveData对象 参考：https://developer.android.google.cn/topic/libraries/architecture/livedata LiveData是一个装饰器，可以用于任何数据，包括实现集合的对象，比如List。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问。 一个示例新建ViewModel之类 1234567891011121314package com.baweigame.livedatademoapplication;import android.arch.lifecycle.MediatorLiveData;import android.arch.lifecycle.MutableLiveData;import android.arch.lifecycle.ViewModel;import java.util.List;public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;List&lt;String&gt;&gt; currentList=new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;List&lt;String&gt;&gt; getCurrentList()&#123; return currentList; &#125;&#125; Activity布局文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;TextView android:id=\"@+id/tv_txt\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; &lt;Button android:id=\"@+id/btn_additem\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"增加list item\"/&gt;&lt;/LinearLayout&gt; Activity 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.baweigame.livedatademoapplication;import android.arch.lifecycle.Observer;import android.arch.lifecycle.ViewModelProvider;import android.arch.lifecycle.ViewModelProviders;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private TextView tvTxt; private Button btnAdditem; private MyViewModel myViewModel; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); list = new ArrayList&lt;&gt;(); myViewModel= ViewModelProviders.of(this).get(MyViewModel.class); myViewModel.getCurrentList().observe(this, new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onChanged(@Nullable List&lt;String&gt; strings) &#123; tvTxt.setText(\"当前存在\"+strings.size()+\"条数据\"); &#125; &#125;); &#125; private void initListener() &#123; btnAdditem.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (int i=0;i&lt;3;i++)&#123; list.add(String.valueOf(i)); &#125; myViewModel.getCurrentList().setValue(list); &#125; &#125;); &#125; private void initView() &#123; tvTxt = (TextView) findViewById(R.id.tv_txt); btnAdditem = (Button) findViewById(R.id.btn_additem); &#125;&#125; 代码很简单，主要实现了使用LiveData的子类MutableLiveData 包含了List类型数据，页面上一个Button控件一个Textview控件，点击Button控件通过MutableLiveData的setValue方法更新数据。TextView文本更新list的size。 如上演示了LiveData的基本使用方式。 MutableLiveData 类继承于LiveData 1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 提供2个方法，分别为：postValue与setValuesetValue——只能从main线程调用postValue——可以从非主线程调用 MutableLiveData还有一个子类MediatorLiveData 可观察多个LiveData对象，响应来自所观察LiveData对象的onChanged事件。 我们修改一下上面的示例来演示一下MediatorLiveData我们加入另一个MutableLiveData list2 和 MediatorLiveData mediatorLiveDataactivity代码修改为调用了MediatorLiveData 方法加入了上面的两个MutableLiveData，并在观察者（Observer）中onChanged方法中吐丝了list的size。注意最下面的方法observe，如果不调用该方法进行注册上面的onChanged方法是不会回调的。我们分别设置了两个MutableLiveData的value。运行程序我们发现两个观察者都弹出了吐丝。 在将LiveData对象发送给观察者之前，您可能希望更改存储在LiveData对象中的值，或者您可能需要根据另一个LiveData实例的值返回另一个LiveData实例。 官方给我们提供两种方法： Transformations.map() Demo: 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); Transformations.switchMap() 与map()类似，将函数应用于存储在LiveData对象中的值，并将结果解包并向下分派。传递给switchMap()的函数必须返回LiveData对象 Demo: 123456private LiveData&lt;User&gt; getUser(String id) &#123; ...;&#125;LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"LiveData","slug":"LiveData","permalink":"http://www.zydeveloper.com/tags/LiveData/"}]},{"title":"Android 组件化开发","slug":"Componentization","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T07:26:35.065Z","comments":true,"path":"2019/07/02/Componentization/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/Componentization/","excerpt":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科","text":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科 本人对于组件化的理解为是一种架构思想，与传统项目（一般指模块化）相比各个业务组件相互隔离，使各个组件可以单独运行单独测试，使用“壳工程”将其组装到一起。这样带来的好处是业务模块单独开发维护降低耦合性，使项目可测试性及可维护性提升。 （该图片来源于互联网） 上图很形象的描述了组件化各层级的结构。 下面我们通过一个Demo来具体演示一下组件化该如何搭建？","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"}]}]}
{"meta":{"title":"哈哈镜的技术博客","subtitle":null,"description":null,"author":"Zhangyue","url":"http://www.zydeveloper.com","root":"/"},"pages":[{"title":"分类数据","date":"2019-07-01T03:32:35.000Z","updated":"2019-07-01T08:37:30.100Z","comments":true,"path":"categories/index.html","permalink":"http://www.zydeveloper.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 组件化开发","slug":"Componentization","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T07:26:35.065Z","comments":true,"path":"2019/07/02/Componentization/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/Componentization/","excerpt":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科","text":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科 本人对于组件化的理解为是一种架构思想，与传统项目（一般指模块化）相比各个业务组件相互隔离，使各个组件可以单独运行单独测试，使用“壳工程”将其组装到一起。这样带来的好处是业务模块单独开发维护降低耦合性，使项目可测试性及可维护性提升。 （该图片来源于互联网） 上图很形象的描述了组件化各层级的结构。 下面我们通过一个Demo来具体演示一下组件化该如何搭建？","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"}]},{"title":"Jetpack系列之Room","slug":"jetpack-room","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:26.492Z","comments":true,"path":"2019/07/02/jetpack-room/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-room/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Room","slug":"Room","permalink":"http://www.zydeveloper.com/tags/Room/"}]},{"title":"Jetpack系列之LiveData","slug":"jetpack-livedata","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:37.528Z","comments":true,"path":"2019/07/02/jetpack-livedata/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-livedata/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"LiveData","slug":"LiveData","permalink":"http://www.zydeveloper.com/tags/LiveData/"}]},{"title":"Jetpack系列之Lifecycles","slug":"jetpack-lifecycles","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T05:54:41.117Z","comments":true,"path":"2019/07/02/jetpack-lifecycles/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-lifecycles/","excerpt":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.","text":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves. 生命周期感知组件执行操作，以响应另一个组件生命周期状态的更改，例如Activity和Fragment。这些组件可以帮助您生成更有组织、更容易维护的轻量级代码。 一个常见的模式是在Activity和Fragment的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码错误的增加。通过使用生命周期感知组件，您可以将依赖组件的代码从生命周期方法转移到组件本身。 参考链接：https://developer.android.google.cn/topic/libraries/architecture/lifecycle Android中的大多数应用程序组件都具有生命周期,如：Activity/Service/Fragment等。生命周期由操作系统或Framwork管理。它们是Android工作原理的核心，应用程序必须遵守它们。不这样做可能会引发内存泄漏，甚至应用程序崩溃。 可能我们之前的使用方法，如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 上面代码来源于https://developer.android.google.cn/topic/libraries/architecture/lifecycle 尽管这个示例看起来很好，但是在实际应用程序中，最终会有太多的调用来管理UI和其他组件，以响应生命周期的当前状态。管理多个组件会在生命周期方法中放置大量的代码，比如onStart()和onStop()，这使得它们很难维护。此外，不能保证组件在活动或片段停止之前启动。如果我们需要执行长时间运行的操作，比如一些配置check in onStart()，这一点尤其重要。这可能会导致一个竞态条件，即onStop()方法在onStart()之前结束，从而使组件存活的时间超过所需的时间。 Lifecycle是一个类，它保存关于组件(如Activity或Fragment)生命周期状态的信息，并允许其他对象观察这个状态。Lifecycle使用两个主要枚举来跟踪其关联组件的生命周期状态: Event从框架和Lifecycle类发出的生命周期事件。这些事件映射到活动和片段中的回调事件。State声明生命周期对象跟踪的组件的当前状态。 上图演示了States与events的对应关系。 先看一下如下两个系统接口： 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 1234public interface LifecycleObserver &#123;&#125; 一个Demo演示： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.databindingapplication;import android.arch.lifecycle.Lifecycle;import android.arch.lifecycle.LifecycleObserver;import android.arch.lifecycle.OnLifecycleEvent;import android.util.Log;public class ActivityLifecycleObserver implements LifecycleObserver &#123; private final String TAG=ActivityLifecycleObserver.class.getSimpleName(); private Lifecycle mLifecycle; public ActivityLifecycleObserver(Lifecycle lifecycle) &#123; mLifecycle=lifecycle; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; Log.d(TAG, \"onStart: ...\"); Log.d(TAG, \"onStart: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate()&#123; Log.d(TAG, \"onCreate: ...\"); Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause()&#123; Log.d(TAG, \"onPause: ...\"); Log.d(TAG, \"onPause: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125;&#125; MainActivity的onCreate中将上面的Observer注册为观察者（典型的观察者模式） 1getLifecycle().addObserver(new ActivityLifecycleObserver(getLifecycle())); 我们看到注解 OnLifecycleEvent 即 我们上面提到的Event。再来看一下输出：我们注意到上面的代码中，如： 1Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); 打印了State信息。输出的State信息与我们上图中的State信息对应。 如上就是我们用一个小demo演示了一下lifecycle的使用方法。 可能大家看后还不清楚lifecycle究竟再我们实际工作开发中能帮我们处理什么问题，下面我给大家列举一个使用场景中的实际问题，如：MVP架构这个大家应该都不陌生，Prestener层之前我们的管理代码片段如下： 12345678910111213class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 相信如上代码段会出现在大家的工程项目中，这样的后果是导致相应生命周期中代码臃肿也不利于维护。使用lifecycle可以解决如上问题，如： 123456789101112public interface IPresenter extends LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event);&#125; 这样让我们的BasePresenter实现这个接口，在我们的Presenter中就可以感知到组件的生命周期，在接口方法中做业务处理即可。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Lifecycles","slug":"Lifecycles","permalink":"http://www.zydeveloper.com/tags/Lifecycles/"}]},{"title":"Mvvm架构","slug":"mvvm","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T06:32:28.750Z","comments":true,"path":"2019/07/02/mvvm/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/mvvm/","excerpt":"","text":"Mvvm架构与Mvp架构相同的是同样分为三层，并且对应层的职责功能相同： Model层——主要负责提供数据。Model层提供数据如：网络数据及本地数据库中提取的数据，及数据结构如实体bean类。 ViewModel层——同Mvp中P层，主要负责业务逻辑的处理。通过使用官方的Databinding组件进行View层的数据更新等。ViewModel层中不包含任何View层api，使用双向绑定对View层控件进行数据更新，同样不需要View层的引用。 View层——负责界面的显示，View层只管负责UI展示不涉及任何业务逻辑，持有ViewModel层的引用。 Mvvm与Mvp的最大区别在于ViewModel层中不持有View层的引用，这样可以解耦View层，即View层的修改不会影响ViewModel层，同样使代码可测试性增强。也同样给项目团队协作提供可能，这样负责UI开发的人员和负责开发业务功能的人员可以专心关注自己的工作。 Mvvm带来的好处还有减少了很多代码，比如：findViewById 和 操作UI的代码。 举个栗子：","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"Mvvm","slug":"Mvvm","permalink":"http://www.zydeveloper.com/tags/Mvvm/"}]},{"title":"Jetpack系列之Databinding","slug":"jetpack-databinding","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T06:06:46.321Z","comments":true,"path":"2019/07/02/jetpack-databinding/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-databinding/","excerpt":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。","text":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 jetpack官网地址：https://developer.android.google.cn/jetpack/ 什么是Android Jetpack？官方定义如下： Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！ Databinding概念解释参考链接：https://developer.android.google.cn/topic/libraries/data-binding/ 数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 比较一下Databinding给我们带来的不同之处。 看一段我们之前的代码 12TextView textView = findViewById(R.id.tv_login_username);textView.setText(User.getUserName()); 这段代码很简单，实现的逻辑是找到TextView控件并设置其Text属性值。再来看看Databinding的实现方式。 12&lt;TextView android:text=\"@&#123;User.userName&#125;\" /&gt; 我们发现Databinding方式并没有使用java代码就实现了控件查找并设置Text属性值。带来的好处是其维护起来更简单、方便。还可以提高应用性能，并且有助于防止内存泄漏以及避免空指针异常。 Demo演示Databinding使用过程第一步 开启databinding在工程build.gradle文件中开启databinding，如: 第二步 新建实体bean类\\业务实体类新建实体bean类，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.baweigame.databindingapplication;import android.databinding.ObservableField;public class StudentBean &#123; public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); private int id; private int age; private String address; public StudentBean() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; public ObservableField name=new ObservableField&lt;&gt;();这里有个很有趣的东西如上。——ObservableFields一个类中的单独的字段做观察，如果数据有变动则会收到通知。除了ObservableField，还有ObservableBoolean、ObservableInt… 另一种实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class StudentBean extends BaseObservable&#123; @Bindable private String name; private int id; private int age; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 我们发现了一些差异，首先继承了BaseObservable参考链接：https://developer.android.google.cn/reference/android/databinding/BaseObservable @Bindable 可以加到字段名上 也可以加载 get方法上 效果是一样 set方法上手动调用notifyPropertyChanged通知数据更新，注意：参数要写BR.XX（这是一个坑） 上面两处差异部分我们先记录下来，下面具体Demo演示时我们看具体有什么用处。 新建响应点击事件业务处理类，如： 12345public class ClickListener&#123; public void btnClickListener(View view)&#123; studentBean.setName(\"新名字\"); &#125;&#125; 第三步 新建布局文件新建layout布局并设置绑定关系 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"student\" type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt;&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(student.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.address&#125;\"/&gt; &lt;Button android:text=\"点击\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;clickHandler.btnClickListener&#125;\"/&gt;&lt;/LinearLayout&gt;&lt;/layout&gt; 首先我们看根节点变成了layout 并且下方为data节点 ，data节点中有包含了variable节点，这些节点都什么作用，下面我们一一说明： 最外层用layout标签，databinding固定写法 data标签就是一个让我们数据绑定的标签 variable放置绑定的变量 variable包含type和name属性 type属性 标识变量类型，比如java.lang.String这就是String类型，com.baweigame.databindingapplication.StudentBean 这个就是一个定义的一个StudentBean类型com.baweigame.databindingapplication.MainActivity.ClickListener是我定义用于处理事件的业务类型 name属性 表示的就是我定义的一个变量名称，这个变量名称我们会在下方的布局和对应的java代码中用到 variable还有另一种写法如： 123456789101112&lt;data&gt; &lt;!--&lt;variable--&gt; &lt;!--name=\"student\"--&gt; &lt;!--type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt;--&gt; &lt;import type=\"com.baweigame.databindingapplication.StudentBean\" &lt;variable name=\"student\" type=\"StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt; 其中@{}就是我们绑定数据的写法。 其中大家应该注意 1@&#123;String.valueOf(Student.age)&#125; 表达式即可以嵌入表达式，可以在表达式语言中使用以下运算符和关键字： 基本运算 + - / * % 字符串连接 + 逻辑表达式 &amp;&amp; || 二进制 &amp; | ^ 一元运算符 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较运算 == &gt; &lt; &gt;= &lt;= instanceof 分组 () 字面值 - 字符，字符串，数字， null 强转 方法调用 属性访问 数组访问 [] 三元运算符 ?: 绑定处理事件 1@&#123;clickHandler.btnClickListener&#125; 事件处理部分：(方法与butterknife处理事件类似) 1234public void btnClickListener(View view)&#123;// studentBean.name.set(\"新名字\"); studentBean.setName(\"新名字\"); &#125; 大家注意到方法中我们修改了studentbean类中name值，这里面为什么修改name值ui上会同步更新就是因为上面我们的两种设置，如：方法一： 1public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); 方法二： 1234public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; 最后 设置Activity content就是MainActivity中的setContentView处理，我们之前设置内容视图方法都是使用setContentView，在Databinding中我们需要如下设置方法： 12345678 ActivityMainBinding dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);// studentBean.name.set(\"小明\"); studentBean.setName(\"小明\"); studentBean.setAddress(\"北京市朝阳区\"); studentBean.setAge(20); studentBean.setId(1); dataBinding.setStudent(studentBean); dataBinding.setClickHandler(new ClickListener()); ActivityMainBinding即自动生成的绑定类，我们看这个类生成的类名是我们的layout名+Binding组成，即生成规则=layout名+Binding当然你也可以自定义类名，方法如： 1MyStudent dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 如果是Fragment、Listview、Recyclerview 使用则，需要使用inflate()绑定类或者DataBindingUtil类方法： 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);或者ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); 如上即通过一个小Demo演示了DataBinding的具体使用方式。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Databinding","slug":"Databinding","permalink":"http://www.zydeveloper.com/tags/Databinding/"}]}]}
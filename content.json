{"meta":{"title":"哈哈镜的技术博客","subtitle":null,"description":null,"author":"Zhangyue","url":"http://www.zydeveloper.com","root":"/"},"pages":[{"title":"分类数据","date":"2019-07-01T03:32:35.000Z","updated":"2019-07-01T08:37:30.100Z","comments":true,"path":"categories/index.html","permalink":"http://www.zydeveloper.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 组件化开发","slug":"Componentization","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T05:08:30.565Z","comments":true,"path":"2019/07/02/Componentization/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/Componentization/","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"}]},{"title":"Jetpack系列之LiveData","slug":"jetpack-livedata","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:37.528Z","comments":true,"path":"2019/07/02/jetpack-livedata/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-livedata/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"LiveData","slug":"LiveData","permalink":"http://www.zydeveloper.com/tags/LiveData/"}]},{"title":"Jetpack系列之Lifecycles","slug":"jetpack-lifecycles","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:44.788Z","comments":true,"path":"2019/07/02/jetpack-lifecycles/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-lifecycles/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Lifecycles","slug":"Lifecycles","permalink":"http://www.zydeveloper.com/tags/Lifecycles/"}]},{"title":"Mvvm架构","slug":"mvvm","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T05:05:14.461Z","comments":true,"path":"2019/07/02/mvvm/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/mvvm/","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"Mvvm","slug":"Mvvm","permalink":"http://www.zydeveloper.com/tags/Mvvm/"}]},{"title":"Jetpack系列之Room","slug":"jetpack-room","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:26.492Z","comments":true,"path":"2019/07/02/jetpack-room/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-room/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Room","slug":"Room","permalink":"http://www.zydeveloper.com/tags/Room/"}]},{"title":"Jetpack系列之Databinding","slug":"jetpack-databinding","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T14:33:35.645Z","comments":true,"path":"2019/07/02/jetpack-databinding/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-databinding/","excerpt":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。","text":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 jetpack官网地址：https://developer.android.google.cn/jetpack/ 什么是Android Jetpack？官方定义如下： Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！ Databinding概念解释参考链接：https://developer.android.google.cn/topic/libraries/data-binding/ 数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 比较一下Databinding给我们带来的不同之处。 看一段我们之前的代码 12TextView textView = findViewById(R.id.tv_login_username);textView.setText(User.getUserName()); 这段代码很简单，实现的逻辑是找到TextView控件并设置其Text属性值。再来看看Databinding的实现方式。 12&lt;TextView android:text=\"@&#123;User.userName&#125;\" /&gt; 我们发现Databinding方式并没有使用java代码就实现了控件查找并设置Text属性值。带来的好处是其维护起来更简单、方便。还可以提高应用性能，并且有助于防止内存泄漏以及避免空指针异常。 Demo演示Databinding使用过程第一步 开启databinding在工程build.gradle文件中开启databinding，如: 第二步 新建实体bean类\\业务实体类新建实体bean类，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.baweigame.databindingapplication;import android.databinding.ObservableField;public class StudentBean &#123; public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); private int id; private int age; private String address; public StudentBean() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; public ObservableField name=new ObservableField&lt;&gt;();这里有个很有趣的东西如上。——ObservableFields一个类中的单独的字段做观察，如果数据有变动则会收到通知。除了ObservableField，还有ObservableBoolean、ObservableInt… 另一种实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class StudentBean extends BaseObservable&#123; @Bindable private String name; private int id; private int age; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 我们发现了一些差异，首先继承了BaseObservable参考链接：https://developer.android.google.cn/reference/android/databinding/BaseObservable @Bindable 可以加到字段名上 也可以加载 get方法上 效果是一样 set方法上手动调用notifyPropertyChanged通知数据更新，注意：参数要写BR.XX（这是一个坑） 上面两处差异部分我们先记录下来，下面具体Demo演示时我们看具体有什么用处。 新建响应点击事件业务处理类，如： 12345public class ClickListener&#123; public void btnClickListener(View view)&#123; studentBean.setName(\"新名字\"); &#125;&#125; 第三步 新建布局文件新建layout布局并设置绑定关系 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"student\" type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt;&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(student.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.address&#125;\"/&gt; &lt;Button android:text=\"点击\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;clickHandler.btnClickListener&#125;\"/&gt;&lt;/LinearLayout&gt;&lt;/layout&gt; 首先我们看根节点变成了layout 并且下方为data节点 ，data节点中有包含了variable节点，这些节点都什么作用，下面我们一一说明： 最外层用layout标签，databinding固定写法 data标签就是一个让我们数据绑定的标签 variable放置绑定的变量 variable包含type和name属性 type属性 标识变量类型，比如java.lang.String这就是String类型，com.baweigame.databindingapplication.StudentBean 这个就是一个定义的一个StudentBean类型com.baweigame.databindingapplication.MainActivity.ClickListener是我定义用于处理事件的业务类型 name属性 表示的就是我定义的一个变量名称，这个变量名称我们会在下方的布局和对应的java代码中用到 variable还有另一种写法如： 123456789101112&lt;data&gt; &lt;!--&lt;variable--&gt; &lt;!--name=\"student\"--&gt; &lt;!--type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt;--&gt; &lt;import type=\"com.baweigame.databindingapplication.StudentBean\" &lt;variable name=\"student\" type=\"StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt; 其中@{}就是我们绑定数据的写法。 其中大家应该注意 1@&#123;String.valueOf(Student.age)&#125; 表达式即可以嵌入表达式，可以在表达式语言中使用以下运算符和关键字： 基本运算 + - / * % 字符串连接 + 逻辑表达式 &amp;&amp; || 二进制 &amp; | ^ 一元运算符 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较运算 == &gt; &lt; &gt;= &lt;= instanceof 分组 () 字面值 - 字符，字符串，数字， null 强转 方法调用 属性访问 数组访问 [] 三元运算符 ?: 绑定处理事件 1@&#123;clickHandler.btnClickListener&#125; 事件处理部分：(方法与butterknife处理事件类似) 1234public void btnClickListener(View view)&#123;// studentBean.name.set(\"新名字\"); studentBean.setName(\"新名字\"); &#125; 大家注意到方法中我们修改了studentbean类中name值，这里面为什么修改name值ui上会同步更新就是因为上面我们的两种设置，如：方法一： 1public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); 方法二： 1234public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; 最后 设置Activity content就是MainActivity中的setContentView处理，我们之前设置内容视图方法都是使用setContentView，在Databinding中我们需要如下设置方法： 12345678 ActivityMainBinding dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);// studentBean.name.set(\"小明\"); studentBean.setName(\"小明\"); studentBean.setAddress(\"北京市朝阳区\"); studentBean.setAge(20); studentBean.setId(1); dataBinding.setStudent(studentBean); dataBinding.setClickHandler(new ClickListener()); ActivityMainBinding即自动生成的绑定类，我们看这个类生成的类名是我们的layout名+Binding组成，即生成规则=layout名+Binding当然你也可以自定义类名，方法如： 1MyStudent dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 如上即通过一个小Demo演示了DataBinding的具体使用方式。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Databinding","slug":"Databinding","permalink":"http://www.zydeveloper.com/tags/Databinding/"}]}]}
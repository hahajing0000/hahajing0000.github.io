{"meta":{"title":"哈哈镜的技术博客","subtitle":null,"description":null,"author":"Zhangyue","url":"http://www.zydeveloper.com","root":"/"},"pages":[{"title":"分类数据","date":"2019-07-01T03:32:35.000Z","updated":"2019-07-01T08:37:30.100Z","comments":true,"path":"categories/index.html","permalink":"http://www.zydeveloper.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Jetpack系列之ViewModel","slug":"jetpack-viewmodel","date":"2019-07-08T16:00:00.000Z","updated":"2019-07-10T01:44:55.551Z","comments":true,"path":"2019/07/09/jetpack-viewmodel/","link":"","permalink":"http://www.zydeveloper.com/2019/07/09/jetpack-viewmodel/","excerpt":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。","text":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。 聊聊ViewModel主要作用？1、应用于MVVM模式将UI层与Model业务层分离。2、可以存储数据（如：fragment之间共享数据）3、为UI提供数据 Android Framwork管理UI控件的生命周期，比如Activity和Fragment。Framwork可能决定销毁或重新创建一个UI控件，以响应某些用户操作或设备事件。如果系统销毁或重新创建一个UI控件，您存储在其中的任何与UI相关的临时数据都将丢失。例如，您的应用程序可能在其中一个活动中包含一个用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。对于简单数据,活动可以使用方法在onCreate()中恢复数据,但这种方法只适用于少量的数据可以序列化反序列化,而不是潜在的大量数据的用户列表或位图。另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁这些调用后对其进行清理，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改重新创建对象的情况下，这是对资源的浪费，因为对象可能不得不重新发出它已经发出的调用。活动和片段等UI控件主要用于显示UI数据、响应用户操作或处理操作系统通信(如权限请求)。要求UI控制器也负责从数据库或网络加载数据，会使类膨胀。将过多的责任分配给UI控制器可能导致一个类试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式将过多的责任分配给UI控制器也会使测试变得更加困难。将视图数据所有权从UI控制器逻辑中分离出来更容易也更有效。 体系结构组件为负责UI准备数据的UI控制器提供ViewModel helper类。在配置更改期间自动保留ViewModel对象，以便它们所持有的数据可以立即用于下一个Activity或Fragment实例。例如，如果您需要在应用程序中显示用户列表，请确保将获取和保存用户列表的责任分配给ViewModel，而不是activity或fragment。 ViewModel对象的作用域是在获取ViewModel时传递给ViewModelProvider的生命周期。视图模型一直保存在内存中，直到它的作用域永久消失:对于Activity，当它结束时，而对于Fragment，当它被分离时。下图说明了一个活动在进行旋转并完成时的各种生命周期状态。图中还显示了关联活动生命周期旁边的ViewModel的生命周期。这个图说明了活动的状态。同样的基本状态也适用于片段的生命周期。 参考：https://developer.android.google.cn/topic/libraries/architecture/viewmodel ##基本使用 首先导依赖：implementation ‘android.arch.lifecycle:extensions:1.1.1’ ViewModel类 12345678910111213141516171819202122232425package com.baweigame.databindingjavademoapplication;import android.arch.lifecycle.MutableLiveData;import android.arch.lifecycle.ViewModel;public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;PersonBean&gt; personLiveData=new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;PersonBean&gt; getPersonLiveData() &#123; return personLiveData; &#125; public void setPersonLiveData(MutableLiveData&lt;PersonBean&gt; personLiveData) &#123; this.personLiveData = personLiveData; &#125; public void loadPersonData()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; personLiveData.postValue(new PersonBean(\"小明\",20,\"北京市海淀区\")); &#125; &#125;).start(); &#125;&#125; Activity中使用 123456ViewModelProviders.of(this).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); 然后，可在Activity中观察数据变化。 Fragment中共享数据 由于ViewModel的生命周期一直在内存中存在知道被销毁，所以可以在Fragment间传递数据，如：有两个Fragment Fragment1： 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125;&#125;); Fragment2: 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); Activity中更新数据： 1ViewModelProviders.of(this).get(MyViewModel.class).loadPersonData(); 这样就实现了Fragment间的数据共享。 ViewModelProviders 类提供了4个方法 of() 创建新的 ViewModelProvider 对象。 1234ViewModelProviders.of(Fragment)ViewModelProviders.of(FragmentActivity)ViewModelProviders.of(Fragment, Factory)ViewModelProviders.of(FragmentActivity, Factory)","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"ViewModel","slug":"ViewModel","permalink":"http://www.zydeveloper.com/tags/ViewModel/"}]},{"title":"Jetpack系列之Room","slug":"jetpack-room","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:26.492Z","comments":true,"path":"2019/07/02/jetpack-room/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-room/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Room","slug":"Room","permalink":"http://www.zydeveloper.com/tags/Room/"}]},{"title":"Jetpack系列之Lifecycles","slug":"jetpack-lifecycles","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T05:54:41.117Z","comments":true,"path":"2019/07/02/jetpack-lifecycles/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-lifecycles/","excerpt":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.","text":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves. 生命周期感知组件执行操作，以响应另一个组件生命周期状态的更改，例如Activity和Fragment。这些组件可以帮助您生成更有组织、更容易维护的轻量级代码。 一个常见的模式是在Activity和Fragment的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码错误的增加。通过使用生命周期感知组件，您可以将依赖组件的代码从生命周期方法转移到组件本身。 参考链接：https://developer.android.google.cn/topic/libraries/architecture/lifecycle Android中的大多数应用程序组件都具有生命周期,如：Activity/Service/Fragment等。生命周期由操作系统或Framwork管理。它们是Android工作原理的核心，应用程序必须遵守它们。不这样做可能会引发内存泄漏，甚至应用程序崩溃。 可能我们之前的使用方法，如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 上面代码来源于https://developer.android.google.cn/topic/libraries/architecture/lifecycle 尽管这个示例看起来很好，但是在实际应用程序中，最终会有太多的调用来管理UI和其他组件，以响应生命周期的当前状态。管理多个组件会在生命周期方法中放置大量的代码，比如onStart()和onStop()，这使得它们很难维护。此外，不能保证组件在活动或片段停止之前启动。如果我们需要执行长时间运行的操作，比如一些配置check in onStart()，这一点尤其重要。这可能会导致一个竞态条件，即onStop()方法在onStart()之前结束，从而使组件存活的时间超过所需的时间。 Lifecycle是一个类，它保存关于组件(如Activity或Fragment)生命周期状态的信息，并允许其他对象观察这个状态。Lifecycle使用两个主要枚举来跟踪其关联组件的生命周期状态: Event从框架和Lifecycle类发出的生命周期事件。这些事件映射到活动和片段中的回调事件。State声明生命周期对象跟踪的组件的当前状态。 上图演示了States与events的对应关系。 先看一下如下两个系统接口： 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 1234public interface LifecycleObserver &#123;&#125; 一个Demo演示： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.databindingapplication;import android.arch.lifecycle.Lifecycle;import android.arch.lifecycle.LifecycleObserver;import android.arch.lifecycle.OnLifecycleEvent;import android.util.Log;public class ActivityLifecycleObserver implements LifecycleObserver &#123; private final String TAG=ActivityLifecycleObserver.class.getSimpleName(); private Lifecycle mLifecycle; public ActivityLifecycleObserver(Lifecycle lifecycle) &#123; mLifecycle=lifecycle; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; Log.d(TAG, \"onStart: ...\"); Log.d(TAG, \"onStart: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate()&#123; Log.d(TAG, \"onCreate: ...\"); Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause()&#123; Log.d(TAG, \"onPause: ...\"); Log.d(TAG, \"onPause: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125;&#125; MainActivity的onCreate中将上面的Observer注册为观察者（典型的观察者模式） 1getLifecycle().addObserver(new ActivityLifecycleObserver(getLifecycle())); 我们看到注解 OnLifecycleEvent 即 我们上面提到的Event。再来看一下输出：我们注意到上面的代码中，如： 1Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); 打印了State信息。输出的State信息与我们上图中的State信息对应。 如上就是我们用一个小demo演示了一下lifecycle的使用方法。 可能大家看后还不清楚lifecycle究竟再我们实际工作开发中能帮我们处理什么问题，下面我给大家列举一个使用场景中的实际问题，如：MVP架构这个大家应该都不陌生，Prestener层之前我们的管理代码片段如下： 12345678910111213class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 相信如上代码段会出现在大家的工程项目中，这样的后果是导致相应生命周期中代码臃肿也不利于维护。使用lifecycle可以解决如上问题，如： 123456789101112public interface IPresenter extends LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event);&#125; 这样让我们的BasePresenter实现这个接口，在我们的Presenter中就可以感知到组件的生命周期，在接口方法中做业务处理即可。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Lifecycles","slug":"Lifecycles","permalink":"http://www.zydeveloper.com/tags/Lifecycles/"}]},{"title":"Jetpack系列之LiveData","slug":"jetpack-livedata","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-09T11:31:12.047Z","comments":true,"path":"2019/07/02/jetpack-livedata/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-livedata/","excerpt":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于启动或恢复状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为销毁时，此关系允许删除观察者。这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当活动和片段的生命周期被破坏时，它们会立即取消订阅。","text":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如活动、片段或服务。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于启动或恢复状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为销毁时，此关系允许删除观察者。这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当活动和片段的生命周期被破坏时，它们会立即取消订阅。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"LiveData","slug":"LiveData","permalink":"http://www.zydeveloper.com/tags/LiveData/"}]},{"title":"Android 组件化开发","slug":"Componentization","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T07:26:35.065Z","comments":true,"path":"2019/07/02/Componentization/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/Componentization/","excerpt":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科","text":"什么是组件化？ 组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科 本人对于组件化的理解为是一种架构思想，与传统项目（一般指模块化）相比各个业务组件相互隔离，使各个组件可以单独运行单独测试，使用“壳工程”将其组装到一起。这样带来的好处是业务模块单独开发维护降低耦合性，使项目可测试性及可维护性提升。 （该图片来源于互联网） 上图很形象的描述了组件化各层级的结构。 下面我们通过一个Demo来具体演示一下组件化该如何搭建？","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"}]},{"title":"Mvvm架构","slug":"mvvm","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T08:14:30.612Z","comments":true,"path":"2019/07/02/mvvm/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/mvvm/","excerpt":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科","text":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科 Mvvm架构与Mvp架构相同的是同样分为三层，并且对应层的职责功能相同： Model层——主要负责提供数据。Model层提供数据如：网络数据及本地数据库中提取的数据，及数据结构如实体bean类。 ViewModel层——同Mvp中P层，主要负责业务逻辑的处理。通过使用官方的Databinding组件进行View层的数据更新等。ViewModel层中不包含任何View层api，使用双向绑定对View层控件进行数据更新，同样不需要View层的引用。 View层——负责界面的显示，View层只管负责UI展示不涉及任何业务逻辑，持有ViewModel层的引用。 Mvvm与Mvp的最大区别在于ViewModel层中不持有View层的引用，这样可以解耦View层，即View层的修改不会影响ViewModel层，同样使代码可测试性增强。也同样给项目团队协作提供可能，这样负责UI开发的人员和负责开发业务功能的人员可以专心关注自己的工作。 Mvvm带来的好处还有减少了很多代码，比如：findViewById 和 操作UI的代码。 举个栗子： 新建工程 一般我们习惯与建立模块后再模块下建立mvvm结构目录。如下图： 实体bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.baweigame.mvvmdemoapplication.student.model;public class StudentBean &#123; private String name; private int age; private String address; public StudentBean(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public StudentBean() &#123; &#125; @Override public String toString() &#123; return \"StudentBean&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; ViewModel类 123456789101112131415161718192021222324252627282930313233package com.baweigame.mvvmdemoapplication.student.viewmodel;import android.databinding.ObservableBoolean;import android.databinding.ObservableField;import android.os.Handler;import android.os.Message;public class StudentViewModel &#123; public final ObservableBoolean isVisible=new ObservableBoolean(false); public final ObservableBoolean isSuccess=new ObservableBoolean(false); public final ObservableBoolean isFalied=new ObservableBoolean(false); public final ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); public void addStudent()&#123; mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; isVisible.set(true); isSuccess.set(true); name.set(\"小红同学\"); &#125; &#125;,3000); &#125; private Handler mHandler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;;&#125; Activity Layout xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;import type=\"android.view.View\"&gt;&lt;/import&gt; &lt;variable name=\"viewmodel\" type=\"com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel\"&gt;&lt;/variable&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;viewmodel.name&#125;\" android:textColor=\"@android:color/holo_orange_dark\" android:textSize=\"20sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"2dp\" android:background=\"@android:color/holo_green_light\" android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\"&gt; &lt;/View&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"添加成功\" android:textColor=\"@android:color/holo_red_light\" android:textSize=\"20sp\" android:visibility=\"@&#123;viewmodel.isSuccess?View.VISIBLE:View.GONE&#125;\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;()-&gt;viewmodel.addStudent()&#125;\" android:text=\"添加学生\" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Activity代码 12345678910111213141516171819202122package com.baweigame.mvvmdemoapplication.student.view;import android.databinding.DataBindingUtil;import android.databinding.ViewDataBinding;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import com.baweigame.mvvmdemoapplication.R;import com.baweigame.mvvmdemoapplication.databinding.ActivityMainBinding;import com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); StudentViewModel studentViewModel = new StudentViewModel(); studentViewModel.name.set(\"小明同学\"); viewDataBinding.setViewmodel(studentViewModel); &#125;&#125; 代码比较简单不再解释。 Databinding可参考Jetpack系列之Databinding 这里还有一个坑，我们的xml中设置了android:visibility属性 使用代码如： 1android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\" 原因是因为使用了View导致编译时错误，解决方案：也就是导入View。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"Mvvm","slug":"Mvvm","permalink":"http://www.zydeveloper.com/tags/Mvvm/"}]},{"title":"Jetpack系列之Databinding","slug":"jetpack-databinding","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T06:06:46.321Z","comments":true,"path":"2019/07/02/jetpack-databinding/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-databinding/","excerpt":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。","text":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 jetpack官网地址：https://developer.android.google.cn/jetpack/ 什么是Android Jetpack？官方定义如下： Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！ Databinding概念解释参考链接：https://developer.android.google.cn/topic/libraries/data-binding/ 数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 比较一下Databinding给我们带来的不同之处。 看一段我们之前的代码 12TextView textView = findViewById(R.id.tv_login_username);textView.setText(User.getUserName()); 这段代码很简单，实现的逻辑是找到TextView控件并设置其Text属性值。再来看看Databinding的实现方式。 12&lt;TextView android:text=\"@&#123;User.userName&#125;\" /&gt; 我们发现Databinding方式并没有使用java代码就实现了控件查找并设置Text属性值。带来的好处是其维护起来更简单、方便。还可以提高应用性能，并且有助于防止内存泄漏以及避免空指针异常。 Demo演示Databinding使用过程第一步 开启databinding在工程build.gradle文件中开启databinding，如: 第二步 新建实体bean类\\业务实体类新建实体bean类，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.baweigame.databindingapplication;import android.databinding.ObservableField;public class StudentBean &#123; public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); private int id; private int age; private String address; public StudentBean() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; public ObservableField name=new ObservableField&lt;&gt;();这里有个很有趣的东西如上。——ObservableFields一个类中的单独的字段做观察，如果数据有变动则会收到通知。除了ObservableField，还有ObservableBoolean、ObservableInt… 另一种实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class StudentBean extends BaseObservable&#123; @Bindable private String name; private int id; private int age; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 我们发现了一些差异，首先继承了BaseObservable参考链接：https://developer.android.google.cn/reference/android/databinding/BaseObservable @Bindable 可以加到字段名上 也可以加载 get方法上 效果是一样 set方法上手动调用notifyPropertyChanged通知数据更新，注意：参数要写BR.XX（这是一个坑） 上面两处差异部分我们先记录下来，下面具体Demo演示时我们看具体有什么用处。 新建响应点击事件业务处理类，如： 12345public class ClickListener&#123; public void btnClickListener(View view)&#123; studentBean.setName(\"新名字\"); &#125;&#125; 第三步 新建布局文件新建layout布局并设置绑定关系 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"student\" type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt;&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(student.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.address&#125;\"/&gt; &lt;Button android:text=\"点击\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;clickHandler.btnClickListener&#125;\"/&gt;&lt;/LinearLayout&gt;&lt;/layout&gt; 首先我们看根节点变成了layout 并且下方为data节点 ，data节点中有包含了variable节点，这些节点都什么作用，下面我们一一说明： 最外层用layout标签，databinding固定写法 data标签就是一个让我们数据绑定的标签 variable放置绑定的变量 variable包含type和name属性 type属性 标识变量类型，比如java.lang.String这就是String类型，com.baweigame.databindingapplication.StudentBean 这个就是一个定义的一个StudentBean类型com.baweigame.databindingapplication.MainActivity.ClickListener是我定义用于处理事件的业务类型 name属性 表示的就是我定义的一个变量名称，这个变量名称我们会在下方的布局和对应的java代码中用到 variable还有另一种写法如： 123456789101112&lt;data&gt; &lt;!--&lt;variable--&gt; &lt;!--name=\"student\"--&gt; &lt;!--type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt;--&gt; &lt;import type=\"com.baweigame.databindingapplication.StudentBean\" &lt;variable name=\"student\" type=\"StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt; 其中@{}就是我们绑定数据的写法。 其中大家应该注意 1@&#123;String.valueOf(Student.age)&#125; 表达式即可以嵌入表达式，可以在表达式语言中使用以下运算符和关键字： 基本运算 + - / * % 字符串连接 + 逻辑表达式 &amp;&amp; || 二进制 &amp; | ^ 一元运算符 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较运算 == &gt; &lt; &gt;= &lt;= instanceof 分组 () 字面值 - 字符，字符串，数字， null 强转 方法调用 属性访问 数组访问 [] 三元运算符 ?: 绑定处理事件 1@&#123;clickHandler.btnClickListener&#125; 事件处理部分：(方法与butterknife处理事件类似) 1234public void btnClickListener(View view)&#123;// studentBean.name.set(\"新名字\"); studentBean.setName(\"新名字\"); &#125; 大家注意到方法中我们修改了studentbean类中name值，这里面为什么修改name值ui上会同步更新就是因为上面我们的两种设置，如：方法一： 1public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); 方法二： 1234public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; 最后 设置Activity content就是MainActivity中的setContentView处理，我们之前设置内容视图方法都是使用setContentView，在Databinding中我们需要如下设置方法： 12345678 ActivityMainBinding dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);// studentBean.name.set(\"小明\"); studentBean.setName(\"小明\"); studentBean.setAddress(\"北京市朝阳区\"); studentBean.setAge(20); studentBean.setId(1); dataBinding.setStudent(studentBean); dataBinding.setClickHandler(new ClickListener()); ActivityMainBinding即自动生成的绑定类，我们看这个类生成的类名是我们的layout名+Binding组成，即生成规则=layout名+Binding当然你也可以自定义类名，方法如： 1MyStudent dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 如果是Fragment、Listview、Recyclerview 使用则，需要使用inflate()绑定类或者DataBindingUtil类方法： 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);或者ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); 如上即通过一个小Demo演示了DataBinding的具体使用方式。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Databinding","slug":"Databinding","permalink":"http://www.zydeveloper.com/tags/Databinding/"}]}]}
{"meta":{"title":"一个老程序猿","subtitle":null,"description":"记录技术点滴","author":"Zhangyue","url":"http://www.zydeveloper.com","root":"/"},"pages":[{"title":"分类数据","date":"2019-07-01T03:32:35.000Z","updated":"2019-07-01T08:37:30.100Z","comments":true,"path":"categories/index.html","permalink":"http://www.zydeveloper.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"FFmpeg系列 番外篇 Android C++ 子线程 及 生产者消费者模型","slug":"ffmpeg-other1-thread","date":"2019-09-04T16:00:00.000Z","updated":"2019-09-05T07:10:54.083Z","comments":true,"path":"2019/09/05/ffmpeg-other1-thread/","link":"","permalink":"http://www.zydeveloper.com/2019/09/05/ffmpeg-other1-thread/","excerpt":"这篇来讲讲Android C++ 子线程 及 生产者消费者模型","text":"这篇来讲讲Android C++ 子线程 及 生产者消费者模型 Android 中的C++ 线程，我们要使用 POSIX 编写多线程 C++ 程序。 重要有三个方法： pthread_t —— 声明线程pthread_create —— 创建线程pthread_exit —— 终止线程 一个Demo来演示线程使用： 1234567891011121314public native void normalThread();----------------------------------------------pthread_t thread;void *normalCallback(void *data)&#123; LOGI(\"create normal thread from c++\"); pthread_exit(&amp;thread);&#125;extern \"C\"JNIEXPORT void JNICALLJava_com_music_mplayer_Demo_normalThread(JNIEnv *env, jobject instance) &#123; pthread_create(&amp;thread,NULL,normalCallback,NULL);&#125; 使用起来相对简单。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/tags/FFmpeg/"}]},{"title":"FFmpeg系列 三、音乐APP（添加Module并添加FFmpeg动态库）","slug":"ffmpeg-demo1-module","date":"2019-09-04T16:00:00.000Z","updated":"2019-09-05T03:56:27.850Z","comments":true,"path":"2019/09/05/ffmpeg-demo1-module/","link":"","permalink":"http://www.zydeveloper.com/2019/09/05/ffmpeg-demo1-module/","excerpt":"基于之前的工程来添加Module工程。","text":"基于之前的工程来添加Module工程。 创建Module工程 将新建的Module工程添加到APP工程中。 Module添加C++支持将app gradle中的配置移植到module gradle中将app gradle中的如下配置移植到module gradle中。 将app中的CMakeLists.txt移植到module中注意我们要移植到module工程的根目录中，如： module工程中创建类文件添加native方法 有报红的是因为我们移植过来的cpp文件jni 方法包名不对引起的。 修正为： 修改app的MainActivity代码用于测试验证结果12345678910111213141516171819package com.music.app;import *;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = findViewById(R.id.sample_text); tv.setText(new Demo().stringFromJNI()); &#125;&#125; 我们看到上面已经正常输出了c++的运算结果。 添加FFmpeg动态库这里面提到的资源如果给位没有，请参考： FFmpeg系列 一、编译FFmpeg module cpp文件夹中创建include文件夹，并添加ffmpeg中include中所有文件 module main文件夹中创建jniLibs,复制arm 和 x86的.so库到jinLibs中创建jniLibs目录将arm和x86动态库拷贝到jinLibs目录下。 配置module gradle文件 cmakelists.txt 配置FFmpeg导入include路径12#导入头文件路径include_directories(src/main/cpp/include) 添加动态库12#导入动态库add_library(avcodec-57 SHARED IMPORTED) 设置动态库路径12#设置动态库路径set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so) 链接动态库123456target_link_libraries( # Specifies the target library. native-lib avcodec-57 $&#123;log-lib&#125; ) 最终CMake1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677cmake_minimum_required(VERSION 3.4.1)#导入头文件路径include_directories(include)#导入动态库add_library(avcodec-57 SHARED IMPORTED)#设置动态库路径set_target_properties(avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavcodec-57.so)#导入动态库add_library(avdevice-57 SHARED IMPORTED)#设置动态库路径set_target_properties(avdevice-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavdevice-57.so)#导入动态库add_library(avfilter-6 SHARED IMPORTED)#设置动态库路径set_target_properties(avfilter-6 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavfilter-6.so)#导入动态库add_library(avformat-57 SHARED IMPORTED)#设置动态库路径set_target_properties(avformat-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavformat-57.so)#导入动态库add_library(avutil-55 SHARED IMPORTED)#设置动态库路径set_target_properties(avutil-55 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libavutil-55.so)#导入动态库add_library(postproc-54 SHARED IMPORTED)#设置动态库路径set_target_properties(postproc-54 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libpostproc-54.so)#导入动态库add_library(swresample-2 SHARED IMPORTED)#设置动态库路径set_target_properties(swresample-2 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswresample-2.so)#导入动态库add_library(swscale-4 SHARED IMPORTED)#设置动态库路径set_target_properties(swscale-4 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;/libswscale-4.so)add_library(native-lib SHARED native-lib.cpp)find_library(log-lib log )target_link_libraries(native-lib $&#123;log-lib&#125; avcodec-57 avdevice-57 avfilter-6 avformat-57 avutil-55 postproc-54 swresample-2 swscale-4 ) 注意：CMakeLists.txt文件需要放到项目跟目录，否则会出现路径不对引发的错误。 Demo验证FFmpeg是否集成成功在module 工程 Demo中导入动态库并加入native方法： 1234567891011121314151617181920212223242526package com.music.mplayer;public class Demo &#123; // Used to load the &apos;native-lib&apos; library on application startup. static &#123; System.loadLibrary(&quot;native-lib&quot;); System.loadLibrary(&quot;avcodec-57&quot;); System.loadLibrary(&quot;avdevice-57&quot;); System.loadLibrary(&quot;avfilter-6&quot;); System.loadLibrary(&quot;avformat-57&quot;); System.loadLibrary(&quot;avutil-55&quot;); System.loadLibrary(&quot;postproc-54&quot;); System.loadLibrary(&quot;swresample-2&quot;); System.loadLibrary(&quot;swscale-4&quot;); &#125; /** * A native method that is implemented by the &apos;native-lib&apos; native library, * which is packaged with this application. */ public native String stringFromJNI(); public native void testFFmpeg();&#125; 报红的部分 alt+enter 搞定。 native-lib.cpp代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;extern \"C\"&#123;#include &lt;libavformat/avformat.h&gt;&#125;#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,\"zhangyue\",FORMAT,##__VA_ARGS__);extern \"C\"JNIEXPORT jstringJNICALLJava_com_music_mplayer_Demo_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = \"Welcome to\"; return env-&gt;NewStringUTF(hello.c_str());&#125;extern \"C\"JNIEXPORT void JNICALLJava_com_music_mplayer_Demo_testFFmpeg(JNIEnv *env, jobject instance) &#123;// TODO av_register_all(); AVCodec *c_temp = av_codec_next(NULL); while (c_temp != NULL) &#123; switch (c_temp-&gt;type) &#123; case AVMEDIA_TYPE_VIDEO: LOGI(\"[Video]:%s\", c_temp-&gt;name); break; case AVMEDIA_TYPE_AUDIO: LOGI(\"[Audio]:%s\", c_temp-&gt;name); break; default: LOGI(\"[Other]:%s\", c_temp-&gt;name); break; &#125; c_temp = c_temp-&gt;next; &#125;&#125; MainActivity代码修改为： 12345678910111213141516package com.music.app;import ****;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Demo().testFFmpeg(); &#125;&#125; 运行程序后，logcat输出如下log： 打印了ffmpeg支持的视频格式，说明我们已经集成成功了！","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/tags/FFmpeg/"}]},{"title":"FFmpeg系列 一、编译FFmpeg","slug":"ffmpeg-build","date":"2019-09-03T16:00:00.000Z","updated":"2019-09-04T08:58:51.311Z","comments":true,"path":"2019/09/04/ffmpeg-build/","link":"","permalink":"http://www.zydeveloper.com/2019/09/04/ffmpeg-build/","excerpt":"编译FFmpeg在Ubuntu中编译Android平台的FFmpeg（arm和x86）","text":"编译FFmpeg在Ubuntu中编译Android平台的FFmpeg（arm和x86） 环境准备： -下载FFmpeg源码（v3.3.9）-下载NDK（r14b）-编写Android编译脚本 下载FFmpeg源码（v3.3.9）V3.3.9下载地址 下载NDK（r14b）NDK r14b 下载 因为在Ubuntu下编译，便于我们方便连接操作，我这里使用XShell与XFTP工具。 使用FTP上传下载文件到Ubuntu中 解压文件解压FFmpegtar -zxvf ffmpeg-3.3.9.tar.gz 解压NDKunzip android-ndk-r14b-linux-x86_64.zip 修改脚本修改FFmpeg的configure文件因为android只能加载.so的动态库，不能识别如.so.57结尾的* 将虚拟机中的configure文件使用FTP下载到本地进行如下修改： 进行如图修改： 修改内容如下： 123456789#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos; 修改后更新到Ubuntu中。 设置configure权限并执行。 123chmod 777 configure./configure 编写Android编译脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/bash#NDK路径 此次要改成你真实环境ndk所在目录export NDK_HOME=/home/**/ffmpeg/android-ndk-r14b #android 平台版本export PLATFORM_VERSION=android-9#定义build函数function build&#123; #输出编译的哪个平台 echo \"start build ffmpeg for $ARCH\" #传入参数——目标平台linux ./configure --target-os=linux \\ #输出路径 --prefix=$PREFIX --arch=$ARCH \\ #排除 doc --disable-doc \\ --enable-shared \\ #去掉静态库 --disable-static \\ #去掉汇编 --disable-yasm \\ --disable-asm \\ --disable-symver \\ --enable-gpl \\ #去掉。。。 --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ #配置交叉编译环境 --cross-prefix=$CROSS_COMPILE \\ #启用交叉编译环境 --enable-cross-compile \\ --sysroot=$SYSROOT \\ #开启最小编译 --enable-small \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install echo \"build ffmpeg for $ARCH finished\"&#125;#armARCH=armCPU=arm#输出路径为当前目录下的android下的架构 动态库及头文件会放到这里PREFIX=$(pwd)/android/$ARCH#配置编译工具TOOLCHAIN=$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64#交叉编译目录CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-ADDI_CFLAGS=\"-marm\"#系统平台目录SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/build#x86ARCH=x86CPU=x86PREFIX=$(pwd)/android/$ARCHTOOLCHAIN=$NDK_HOME/toolchains/x86-4.9/prebuilt/linux-x86_64CROSS_COMPILE=$TOOLCHAIN/bin/i686-linux-android-ADDI_CFLAGS=\"-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32\"SYSROOT=$NDK_HOME/platforms/$PLATFORM_VERSION/arch-$ARCH/build （使用时要将上面中文注释都去掉，否则有坑哈~） 执行android编译脚本： 123chmod 777 build_android.sh./build_android.sh 其中可能遇到一些问题，解决方法可以参见下方说明。编译中： 大概编译10分钟左右，我是虚拟机编译可能比较慢，各位可以使用真机编译会快一点。最终编译完成后如下：取出我们使用的文件：include头文件使用arm或者x86的都可以。 如上就是ffmpeg的编译过程。 常见问题问题1：1gcc is unable to create an executable file. 解决方法： 1sudo apt-get install gcc 问题2：1yasm/nasm not found or too old. Use --disable-yasm for a crippled build. 原因：yasm是汇编编译器，ffmpeg为了提高效率使用了汇编指令，如MMX和SSE等。所以系统中未安装yasm时，就会报上面错误。 解决方法： 1sudo apt install yasm 问题3：1mark command not found 解决方法： 1sudo apt-get install make","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/tags/FFmpeg/"}]},{"title":"FFmpeg系列 二、音乐APP（创建工程）","slug":"ffmpeg-demo","date":"2019-09-03T16:00:00.000Z","updated":"2019-09-04T11:58:30.047Z","comments":true,"path":"2019/09/04/ffmpeg-demo/","link":"","permalink":"http://www.zydeveloper.com/2019/09/04/ffmpeg-demo/","excerpt":"通过实现一个音乐APP来演示ffmpeg的使用。","text":"通过实现一个音乐APP来演示ffmpeg的使用。 使用AndroidStudio创建项目： 下一步 下一步 Finish 如有报错，要检查是否配置了NDK，如： 下面来聊聊 CMakeLists.txt: 1234567891011121314151617181920212223242526272829#cmake的版本cmake_minimum_required(VERSION 3.4.1)#添加一个library 名称为native-libadd_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). native-lib.cpp )#动态库 log-lib —— 别名 log —— 实际动态库find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )#连接上面的动态库 native-lib 及 log动态库target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 在来看看app gradle文件 1234567891011121314151617181920212223242526272829apply plugin: 'com.android.application'android &#123; 。。。 defaultConfig &#123; 。。。 //编译时加入的动态库 externalNativeBuild &#123; cmake &#123; cppFlags \"\" &#125; &#125; &#125; buildTypes &#123; release &#123; 。。。 &#125; &#125; //build文件路径 externalNativeBuild &#123; cmake &#123; path \"src/main/cpp/CMakeLists.txt\" &#125; &#125;&#125;dependencies &#123; 。。。&#125; 再看看MainActivity加入了哪些东西： 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; // 加入动态库 static &#123; System.loadLibrary(\"native-lib\"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = findViewById(R.id.sample_text); tv.setText(stringFromJNI()); &#125; //需要c/c++实现的native方法 public native String stringFromJNI();&#125; 在看看native-lib.cpp 12345678910111213141516#include &lt;jni.h&gt;#include &lt;string&gt;//使用C编译extern \"C\"//导出方法 类型jsstringJNIEXPORT jstring//JNI调用JNICALL//命名为Java_开头 然后是包名.用_替换+类名+native方法名Java_com_music_app_MainActivity_stringFromJNI( // JNIEnv* env, jobject /* this */) &#123; std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 运行验证一下。 如果cmake没有按照，则需要安装如下：","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://www.zydeveloper.com/tags/FFmpeg/"}]},{"title":"三次握手与四次挥手及Http协议","slug":"networkprotocol","date":"2019-08-15T16:00:00.000Z","updated":"2019-08-16T08:20:39.977Z","comments":true,"path":"2019/08/16/networkprotocol/","link":"","permalink":"http://www.zydeveloper.com/2019/08/16/networkprotocol/","excerpt":"以下内容摘录自《Android进阶之光》——刘望舒 TCP的三次握手与四次挥手为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。","text":"以下内容摘录自《Android进阶之光》——刘望舒 TCP的三次握手与四次挥手为什么这里要插入TCP的三次握手与四次挥手的知识呢？ 因为在后面章节分析OkHttp源码的时候会涉及。 通常我们进行HTTP连接网络的时候会进行TCP的三次握手， 然后传输数据， 之后再释放连接。 TCP三次握手TCP三次握手的过程如下。 • 第一次握手： 建立连接。 客户端发送连接请求报文段， 将 SYN 设置为 1、 Sequence Number（seq） 为x； 接下来客户端进入SYN_SENT状态， 等待服务端的确认。 • 第二次握手： 服务器收到客户端的 SYN 报文段， 对 SYN 报文段进行确认， 设置AcknowledgmentNumber（ACK） 为 x+1（seq+1） ； 同时自己还要发送 SYN 请求信息， 将SYN设置为1、 seq为y。 服务端将上述所有信息放到SYN+ACK报文段中， 一并发送给客户端， 此时服务端进入SYN_RCVD状态。 • 第三次握手： 客户端收到服务端的SYN+ACK报文段； 然后将ACK设置为y+1， 向服务端发送ACK报文段， 这个报文段发送完毕后， 客户端和服务端都进入ESTABLISHED （TCP连接成功）状态， 完成TCP的三次握手。 四次挥手当客户端和服务端通过三次握手建立了TCP连接以后， 当数据传送完毕， 断开连接时就需要进行TCP的四次挥手。 其四次挥手如下所示。 • 第一次挥手： 客户端设置seq和ACK， 向服务端发送一个FIN报文段。 此时， 客户端进入FIN_WAIT_1状态， 表示客户端没有数据要发送给服务端了。 • 第二次挥手： 服务端收到了客户端发送的FIN报文段， 向客户端回了一个ACK报文段。 • 第三次挥手： 服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进LAST_ACK状态。 • 第四次挥手： 客户端收到服务端发送的FIN报文段， 向服务端发送ACK报文段， 然后客户端进入TIME_WAIT状态。 服务端收到客户端的ACK报文段以后， 就关闭连接。 此时， 客户端等待2MSL（最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。如果有大量的连接， 每次在连接、 关闭时都要经历三次握手、 四次挥手， 这很显然会造成性能低下。因此， HTTP有一种叫作keepalive connections的机制， 它可以在传输数据后仍然保持连接， 当客户端需要再次获取数据时， 直接使用刚刚空闲下来的连接而无须再次握手. HTTP协议原理作为移动开发者， 开发的应用不免会对网络进行访问。 虽然现在已经有很多开源库帮助我们可以轻而易举地访问网络， 但是我们仍需要去了解网络访问的原理， 这也是一个优秀开发人员所必备的知识点。 HTTP简介HTTP 是一个属于应用层的面向对象的协议， 由于其简捷、 快速的方式， 适用于分布式超媒体信息系统。 它于1990年被提出， 经过几年的使用与发展， 得到不断的完善和扩展。 1.HTTP的历史版本• HTTP 0.9： 1991年发布的第一个版本， 只有一个命令GET， 服务器只能回应HTML格式的字符串。• HTTP 1.0： 1996年发布的版本， 内容量大大增加。 除了GET命令外， 还引入了POST命令和HEAD命令。 HTTP请求和回应的格式除了数据部分， 每次通信都必须包括头信息， 用来描述一些元数据。• HTTP 1.1： 1997发布的版本， 进一步完善了HTTP协议， 直到现在还是最流行的版本。• SPDY协议： 2009年谷歌为了解决 HTTP 1.1效率不高的问题而自行研发的协议。• HTTP 2： 2015年新发布的版本， SPDY 协议的主要特性也在此版本中。 2.HTTP协议的主要特点HTTP协议的主要特点如下。• 支持C/S（客户/服务器） 模式。• 简单快速： 客户向服务器请求服务时， 只需传送请求方法和路径。 请求方法常用的有GET、 HEAD、POST， 每种方法规定了客户与服务器联系的类型不同。 由于 HTTP 协议简单，使得HTTP服务器的程序规模小， 因而通信速度很快。• 灵活： HTTP允许传输任意类型的数据对象。 正在传输的类型由Content-Type加以标记。 • 无连接： 无连接的含义是限制每次连接只处理一个请求。 服务器处理完客户的请求， 并收到客户的应答后， 即断开连接。 采用这种方式可以节省传输时间。• 无状态： HTTP协议是无状态协议， 无状态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据量增大； 而另一方面， 在服务器不需要先前信息时它的应答速度就较快。 HTTP URL的格式如下所示： http://host[＂:＂port][abs_path] http表示要通过HTTP协议来定位网络资源； host表示合法的Internet主机域名或者IP地址； port指定一个端口号， 为空则使用默认端口80； abs_path指定请求资源的URI（Web上任意的可用资源） 。 HTTP有两种报文， 分别是请求报文和响应报文， 下面先来查看请求报文。 HTTP请求报文HTTP 报文是面向文本的， 报文中的每一个字段都是一些ASCII码串， 各个字段的长度是不确定的。 一般一个HTTP请求报文由请求行、 请求报头、 空行和请求数据4个部分组成 1.请求行请求行由请求方法、 URL字段和HTTP协议的版本组成， 格式如下： Method Request-URI HTTP-Version CRLF 其中 Method表示请求方法； Request-URI是一个统一资源标识符； HTTP-Version表示请求的HTTP协议版本； CRLF表示回车和换行（除了作为结尾的CRLF外， 不允许出现单独的CR或LF字符） 。 HTTP请求方法有8种， 分别是GET、 POST、 HEAD、 PUT、 DELETE、 TRACE、CONNECT、OPTIONS。 对于移动开发最常用的就是GET和POST了。 • GET： 请求获取Request-URI所标识的资源。• POST： 在Request-URI所标识的资源后附加新的数据。• HEAD： 请求获取由Request-URI所标识的资源的响应消息报头。• PUT： 请求服务器存储一个资源， 并用Request-URI作为其标识。• DELETE： 请求服务器删除Request-URI所标识的资源。• TRACE： 请求服务器回送收到的请求信息， 主要用于测试或诊断。• CONNECT： HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。• OPTIONS： 请求查询服务器的性能， 或者查询与资源相关的选项和需求。 例如， 访问我的CSDN博客地址的请求行：GET http://zydeveloper.com 2.请求报头在请求行之后会有0个或者多个请求报头， 每个请求报头都包含一个名字和一个值， 它们之间用英文冒号“： ”分割。 关于请求报头， 我们会在后面做统一解释。 3.请求数据请求数据不在GET方法中使用， 而在POST方法中使用。 POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求报头是Content-Type和Content-Length。 HTTP响应报文 HTTP 的响应报文由状态行、 响应报头、 空行、 响应正文组成。 关于响应报头， 我们会在后面做统一解释。 响应正文是服务器返回的资源的内容。 我们先来看看状态行。 状态行格式如下所示： HTTP-Version Status-Code Reason-Phrase CRLF 其中， HTTP-Version表示服务器HTTP协议的版本； Status-Code表示服务器发回的响应状态码； ReasonPhrase表示状态码的文本描述。 状态码由3位数字组成， 第一个数字定义了响应的类别， 且有以下5种可能取值。 • 100～199： 指示信息， 收到请求， 需要请求者继续执行操作。• 200～299： 请求成功， 请求已被成功接收并处理。• 300～399： 重定向， 要完成请求必须进行更进一步的操作。• 400～499： 客户端错误， 请求有语法错误或请求无法实现。• 500～599： 服务器错误， 服务器不能实现合法的请求。 常见的状态码如下。• 200 OK： 客户端请求成功。• 400 Bad Request： 客户端请求有语法错误， 服务器无法理解。• 401 Unauthorized： 请求未经授权， 这个状态码必须和WWW-Authenticate报头域一起使用。• 403 Forbidden： 服务器收到请求， 但是拒绝提供服务。• 500 Internal Server Error： 服务器内部错误， 无法完成请求。• 503 Server Unavailable： 服务器当前不能处理客户端的请求， 一段时间后可能恢复正常。 例如， 访问我的CSDN博客地址， 响应的状态行如下所示： HTTP/1.1 200 OK HTTP的消息报头消息报头分为通用报头、 请求报头、 响应报头、 实体报头等。 消息报头由键值对组成， 每行一对， 关键字和值用英文冒号“： ”分隔。 1.通用报头它既可以出现在请求报头， 也可以出现在响应报头中， 如下所示。• Date： 表示消息产生的日期和时间。• Connection： 允许发送指定连接的选项。 例如指定连接是连续的； 或者指定“close”选项， 通知服务器， 在响应完成后， 关闭连接。• Cache-Control： 用于指定缓存指令， 缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现） ， 且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 。 2.请求报头请求报头通知服务器关于客户端请求的信息。 典型的请求报头如下所示。• Host： 请求的主机名， 允许多个域名同处一个IP地址， 即虚拟主机。• User-Agent： 发送请求的浏览器类型、 操作系统等信息。• Accept： 客户端可识别的内容类型列表， 用于指定客户端接收哪些类型的信息。• Accept-Encoding： 客户端可识别的数据编码。• Accept-Language： 表示浏览器所支持的语言类型。• Connection： 允许客户端和服务器指定与请求/响应连接有关的选项。 例如， 这时为Keep-Alive则表示保持连接。• Transfer-Encoding： 告知接收端为了保证报文的可靠传输， 对报文采用了什么编码方式。 3.响应报头用于服务器传递自身信息的响应。 常见的响应报头如下所示。• Location： 用于重定向接收者到一个新的位置， 常用在更换域名的时候。• Server： 包含服务器用来处理请求的系统信息， 与User-Agent请求报头是相对应的。 4.实体报头实体报头用来定义被传送资源的信息， 其既可用于请求也可用于响应。 请求和响应消息都可以传送一个实体。 常见的实体报头如下所示。• Content-Type： 发送给接收者的实体正文的媒体类型。• Content-Lenght： 实体正文的长度。• Content-Language： 描述资源所用的自然语言。• Content-Encoding： 实体报头被用作媒体类型的修饰符。 它的值指示了已经被应用到实体正文的附加内容的编码， 因而要获得Content-Type报头域中所引用的媒体类型， 必须采用相应的解码机制。• Last-Modified： 实体报头用于指示资源的最后修改日期和时间。• Expires： 实体报头给出响应过期的日期和时间。","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://www.zydeveloper.com/categories/网络协议/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.zydeveloper.com/tags/其他/"}]},{"title":"Activity启动流程","slug":"activitystart","date":"2019-08-14T16:00:00.000Z","updated":"2019-08-27T11:01:30.312Z","comments":true,"path":"2019/08/15/activitystart/","link":"","permalink":"http://www.zydeveloper.com/2019/08/15/activitystart/","excerpt":"这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。","text":"这里从Launcher点击app图标开始到Launcher的onStop,使用泳道图的方式进行演示了App。","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://www.zydeveloper.com/categories/Android进阶/"}],"tags":[{"name":"启动流程","slug":"启动流程","permalink":"http://www.zydeveloper.com/tags/启动流程/"}]},{"title":"Android 多渠道打包","slug":"ReleaseApp","date":"2019-08-08T16:00:00.000Z","updated":"2019-08-13T02:36:07.086Z","comments":true,"path":"2019/08/09/ReleaseApp/","link":"","permalink":"http://www.zydeveloper.com/2019/08/09/ReleaseApp/","excerpt":"我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。","text":"我们的产品上线后会发布到不同的应用商店供用户下载，对于不同的应用商店上线的APP版本进行跟踪统计。这时我们对于不同的应用上线应用商店划分不同的渠道，也就是我们所说的多渠道打包。 下面我们来介绍如何使用Gradle进行多渠道打包。 使用Gradle多渠道打包主要使用ProductFlavors。 ProductFlavors1234567891011121314android&#123; flavorDimensions \"channelpackage\" productFlavors&#123; //小米 xiaomi&#123; &#125; //豌豆荚 wandoujia&#123; &#125; //应用宝 yingyongbao&#123; &#125; &#125;&#125; 我们发现有3个渠道xiaomi wandoujia yingyongbao。还有flavorDimensions,这个是干嘛用的呢？如果不加就会报： Error:All flavors must now belong to a named flavor dimension.Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html 大概意思是所有的flavors都要属于同一个规格。点击链接地址后（要翻墙）：Plugin 3.0.0 includes a new dependency mechanism that automatically matches variants when consuming a library. This means an app’s debug variant automatically consumes a library’s debug variant, and so on. It also works when using flavors—an app’s redDebug variant will consume a library’s redDebug variant. To make this work, the plugin now requires that all flavors belong to a named flavor dimension —even if you intend to use only a single dimension. Otherwise, you will get the following build error: 12Error:All flavors must now belong to a named flavor dimension.The flavor 'flavor_name' is not assigned to a flavor dimension. To resolve this error, assign each flavor to a named dimension, as shown in the sample below. Because dependency matching is now taken care of by the plugin, you should name your flavor dimensions carefully. For example, if all your app and library modules use the foo dimension, you’ll have less control over which flavors are matched by the plugin. 我们可以参考友盟的渠道包方式在清单文件中加入： 123&lt;meta-data android:name=\"MY_CHANNEL\" android:value=\"$&#123;CHANNEL_VALUE&#125;\" /&gt; 同时修改上面的Gradle为： 123456789101112131415flavorDimensions \"channelpackage\"productFlavors&#123; //小米 xiaomi&#123; manifestPlaceholders = [CHANNEL_VALUE:\"xiaomi\"] &#125; //豌豆荚 wandoujia&#123; manifestPlaceholders = [CHANNEL_VALUE:\"wandoujia\"] &#125; //应用宝 yingyongbao&#123; manifestPlaceholders = [CHANNEL_VALUE:\"yingyongbao\"] &#125;&#125; 配置好后到工程的跟目录下执行： 1gradlew assemble 打包成功后：在app下的output下就可以看看我们刚刚打的渠道包了。我们看到已经打包好了不同渠道的debug与release版本的APK。 当然也可以指定打包： 只打release版本包 1gradlew assembleRelease 只打debug版本包 1gradlew assembleDebug 只打小米渠道包 1gradlew assemblexiaomi 只打小米渠道Release包 1gradlew assemblexiaomiRelease 多渠道打包时我们可能还会加入一些其他设置如： 加入不同的APPID及版本号： 1234567891011121314151617181920212223242526272829303132def getTime() &#123; return new Date().format(\"yyyyMMdd\", TimeZone.getTimeZone(\"UTC\"))&#125;android&#123;...flavorDimensions \"channelpackage\"productFlavors&#123; //小米 xiaomi&#123; applicationId \"com.channel.xiaomi.application\" versionCode 1 versionName \"1.0.\"+getTime() manifestPlaceholders = [CHANNEL_VALUE:\"xiaomi\"] &#125; //豌豆荚 wandoujia&#123; applicationId \"com.channel.wandoujia.application\" versionCode 1 versionName \"1.0.\"+getTime() manifestPlaceholders = [CHANNEL_VALUE:\"wandoujia\"] &#125; //应用宝 yingyongbao&#123; applicationId \"com.channel.yingyongbao.application\" versionCode 1 versionName \"1.0.\"+getTime() manifestPlaceholders = [CHANNEL_VALUE:\"yingyongbao\"] &#125;&#125;...&#125; 重新打包后发现我们的applicationid与版本信息都定制化了。 manifestPlaceholders中也可以加入多个配置，如加入第三方的APPKEY： 1manifestPlaceholders = [CHANNEL_VALUE:\"wandoujia\",BaiduMapAPPKEY:\"s9s87d7f9s6df6s78sd\"] 还可以不同的渠道引入不同的jar包： 123456dependencies &#123; ... implementation 'com.github.leifzhang:IjkLib:0.4.3' xiaomiImplementation 'io.reactivex.rxjava2:rxandroid:2.1.1' xiaomiImplementation 'io.reactivex.rxjava2:rxjava:2.2.11'&#125; 使用BuildConfig传递配置一些参数： 123456789101112131415161718192021222324252627flavorDimensions \"channelpackage\"productFlavors&#123; //小米 xiaomi&#123; ... buildConfigField \"String\", \"buildparam\",\"\\\"xiaomi\\\"\" &#125; //豌豆荚 wandoujia&#123; ... buildConfigField \"String\", \"buildparam\",\"\\\"wandoujia\\\"\" &#125; //应用宝 yingyongbao&#123; ... buildConfigField \"String\", \"buildparam\",\"\\\"yingyongbao\\\"\" &#125;&#125;代码中获取：if (BuildConfig.buildparam.equals(\"xiaomi\"))&#123; &#125;else if (BuildConfig.buildparam.equals(\"wandoujia\"))&#123; &#125;else if (BuildConfig.buildparam.equals(\"yingyongbao\"))&#123; &#125; BuildConfig也有一些默认的配置属性： 甚至还可以各渠道包使用不同的资源： 1234567891011121314151617181920212223242526272829303132sourceSets &#123; main &#123; java.srcDir \"src/main/java\" res.srcDir \"src/main/res\" jniLibs.srcDir \"src/main/jniLibs\" manifest.srcFile \"src/main/AndroidManifest.xml\" assets.srcDir \"src/main/assets\" &#125; xiaomi&#123; java.srcDir \"src/main/java\" res.srcDir \"src/main/res\" jniLibs.srcDir \"src/main/jniLibs\" manifest.srcFile \"src/main/AndroidManifest.xml\" assets.srcDir \"src/main/assets\" &#125; wandoujia&#123; java.srcDir \"src/main/java\" res.srcDir \"src/main/res\" jniLibs.srcDir \"src/main/jniLibs\" manifest.srcFile \"src/main/AndroidManifest.xml\" assets.srcDir \"src/main/assets\" &#125; yingyongbao&#123; java.srcDir \"src/main/java\" res.srcDir \"src/main/res\" jniLibs.srcDir \"src/main/jniLibs\" manifest.srcFile \"src/main/AndroidManifest.xml\" assets.srcDir \"src/main/assets\" &#125; &#125; 可能遇到的问题？问题1：Android studio Error occurred during initialization of VM 问题解决 问题2： 12Execution failed for task ':app:compileWandoujiaDebugJavaWithJavac'.&gt; Could not find tools.jar. Please check that C:\\Program Files (x86)\\Java\\jre1.8.0_211 contains a valid JDK installation. 环境变量中配置JAVA_HOME 指向jdk所在目录，path中加入%JAVA_HOME%\\bin","categories":[{"name":"打包","slug":"打包","permalink":"http://www.zydeveloper.com/categories/打包/"}],"tags":[{"name":"多渠道打包","slug":"多渠道打包","permalink":"http://www.zydeveloper.com/tags/多渠道打包/"}]},{"title":"帧动画和补间动画","slug":"Animation1","date":"2019-08-07T16:00:00.000Z","updated":"2019-09-04T01:18:57.145Z","comments":true,"path":"2019/08/08/Animation1/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/Animation1/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"动画","slug":"动画","permalink":"http://www.zydeveloper.com/tags/动画/"}]},{"title":"属性动画","slug":"Animation2","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T09:45:32.038Z","comments":true,"path":"2019/08/08/Animation2/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/Animation2/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"动画","slug":"动画","permalink":"http://www.zydeveloper.com/tags/动画/"}]},{"title":"自定义View使用","slug":"CustomView1","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T09:47:51.204Z","comments":true,"path":"2019/08/08/CustomView1/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/CustomView1/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"自定义View","slug":"自定义View","permalink":"http://www.zydeveloper.com/tags/自定义View/"}]},{"title":"组合View和自定义属性","slug":"CustomView2","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T09:48:59.484Z","comments":true,"path":"2019/08/08/CustomView2/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/CustomView2/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"自定义View","slug":"自定义View","permalink":"http://www.zydeveloper.com/tags/自定义View/"}]},{"title":"自实现页面注解框架","slug":"CustomAnnFramwork","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T08:02:54.878Z","comments":true,"path":"2019/08/08/CustomAnnFramwork/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/CustomAnnFramwork/","excerpt":"闲来无事使用自定义注解+反射实现一个简单的页面注解框架，离项目中使用还有很大距离，纯属练习使用。","text":"闲来无事使用自定义注解+反射实现一个简单的页面注解框架，离项目中使用还有很大距离，纯属练习使用。 项目结构 页面应用 ContentView 12345678910package com.baweigame.viewinjectlibrary.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface ContentView &#123; int value();&#125; InjectView 12345678910package com.baweigame.viewinjectlibrary.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface InjectView &#123; int value();&#125; SuperEvent 123456789101112131415161718192021222324package com.baweigame.viewinjectlibrary.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface SuperEvent &#123; /** * 事件名 * @return */ String listenerName(); /** * 事件类型 * @return */ Class&lt;?&gt; listenerType(); /** * 消费的事件名称 * @return */ String callbackListenerName();&#125; OnClick 12345678910111213package com.baweigame.viewinjectlibrary.annotation.eventannotation;import android.view.View;import com.baweigame.viewinjectlibrary.annotation.SuperEvent;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@SuperEvent(listenerName = \"setOnClickListener\",listenerType = View.OnClickListener.class,callbackListenerName = \"onClick\")public @interface OnClick &#123; int[] values();&#125; InjectManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.baweigame.viewinjectlibrary;import android.app.Activity;import android.os.Build;import android.support.annotation.RequiresApi;import android.view.View;import com.baweigame.viewinjectlibrary.annotation.ContentView;import com.baweigame.viewinjectlibrary.annotation.InjectView;import com.baweigame.viewinjectlibrary.annotation.SuperEvent;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManager &#123; private static InjectManager instance=new InjectManager(); private InjectManager()&#123;&#125; public static InjectManager getInstance()&#123; return instance; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) public void injectActivity(Activity activity)&#123; injectLayout(activity); injectViews(activity); injectEvents(activity); &#125; /** * 注册activity布局 * @param activity */ private void injectLayout(Activity activity)&#123; Class&lt;? extends Activity&gt; clazz = activity.getClass(); ContentView contentView = clazz.getAnnotation(ContentView.class); if (contentView!=null)&#123; int layoutId=contentView.value(); try &#123; Method setContentView = clazz.getMethod(\"setContentView\", int.class); setContentView.invoke(activity,layoutId); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e)&#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 注册视图 * @param activity */ private void injectViews(Activity activity)&#123; Class&lt;? extends Activity&gt; clazz = activity.getClass(); Field[] fields = clazz.getDeclaredFields(); for (Field field: fields) &#123; InjectView injectView = field.getAnnotation(InjectView.class); if (injectView!=null)&#123; int viewId=injectView.value(); try &#123; Method fvbMethod = clazz.getMethod(\"findViewById\", int.class); Object obj = fvbMethod.invoke(activity, viewId); field.setAccessible(true); field.set(activity,obj); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 注册事件 * @param activity */ @RequiresApi(api = Build.VERSION_CODES.KITKAT) private void injectEvents(Activity activity) &#123; Class&lt;? extends Activity&gt; clazz = activity.getClass(); Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; Annotation[] annotations = method.getAnnotations(); for (Annotation annotation : annotations) &#123; Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType(); if (annotationType != null) &#123; SuperEvent eventBase = annotationType.getAnnotation(SuperEvent.class); if (eventBase != null) &#123; String listenerSetter = eventBase.listenerName(); Class&lt;?&gt; listenerType = eventBase.listenerType(); String callBackListener = eventBase.callbackListenerName(); try &#123; Method valueMethod = annotationType.getDeclaredMethod(\"values\"); int[] viewIds = (int[]) valueMethod.invoke(annotation); ListenerInvocationHandler handler = new ListenerInvocationHandler(activity); handler.addMethod(callBackListener, method); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]&#123;listenerType&#125;, handler); // 遍历注解的值 for (int viewId : viewIds) &#123; View view = activity.findViewById(viewId); Method setter = view.getClass().getMethod(listenerSetter, listenerType); setter.invoke(view, listener); &#125; &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ListenerInvocationHandler 1234567891011121314151617181920212223242526272829303132333435package com.baweigame.viewinjectlibrary;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ListenerInvocationHandler implements InvocationHandler &#123; // 需要拦截的对象 private Object target; // 需要拦截的对象键值对 private HashMap&lt;String, Method&gt; methodHashMap = new HashMap&lt;&gt;(); public ListenerInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method 等于拦截的onclick if (target != null) &#123; // 获取需要拦截的方法名 String methodName = method.getName(); // 假如是onClick // 重新赋值 method = methodHashMap.get(methodName); // 执行拦截的方法 if (method != null) &#123; return method.invoke(target, args); &#125; &#125; return null; &#125; /** * 将需要拦截的方法添加 * @param methodName 需要拦截的方法，如：onClick() * @param method 执行拦截后的方法，如：show() */ public void addMethod(String methodName, Method method) &#123; methodHashMap.put(methodName, method); &#125;&#125;","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"页面框架","slug":"页面框架","permalink":"http://www.zydeveloper.com/tags/页面框架/"}]},{"title":"自定义View绘制一些基本图形","slug":"CustomView3","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T09:50:09.265Z","comments":true,"path":"2019/08/08/CustomView3/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/CustomView3/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"自定义View","slug":"自定义View","permalink":"http://www.zydeveloper.com/tags/自定义View/"}]},{"title":"事件分发","slug":"Event","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-08T09:46:40.699Z","comments":true,"path":"2019/08/08/Event/","link":"","permalink":"http://www.zydeveloper.com/2019/08/08/Event/","excerpt":"","text":"","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/categories/Android基础/"}],"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://www.zydeveloper.com/tags/Android基础/"},{"name":"事件","slug":"事件","permalink":"http://www.zydeveloper.com/tags/事件/"}]},{"title":"AutoDispose 解决RxJava内存泄漏问题","slug":"AutoDispose","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-09T06:07:18.452Z","comments":true,"path":"2019/08/05/AutoDispose/","link":"","permalink":"http://www.zydeveloper.com/2019/08/05/AutoDispose/","excerpt":"Auto Dispose GitHub地址 前一篇我们介绍了RxLifecycle解决Rxjava可能发生的内存泄漏问题： RxLifecycle 解决RxJava内存泄漏问题 AutoDispose是一个RxJava2工具，用于解决Rxjava内存泄漏问题。","text":"Auto Dispose GitHub地址 前一篇我们介绍了RxLifecycle解决Rxjava可能发生的内存泄漏问题： RxLifecycle 解决RxJava内存泄漏问题 AutoDispose是一个RxJava2工具，用于解决Rxjava内存泄漏问题。 如何使用?导入依赖： 1implementation 'com.uber.autodispose:autodispose-android-archcomponents:1.3.0' 手写一个RxJava的内存泄漏问题： 12345678910111213141516171819202122232425262728293031@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable.interval(1,TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.d(\"123\", \"onNext: \"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"123\", \"onComplete: \"); &#125; &#125;);&#125; 这段代码我们在前一篇文章中已经验证了存在内存泄漏问题，即点击back键后onNext仍然被回调，log一直持续输出。 下面我们通过使用AutoDispose来修复Rxjava内存泄漏问题。 修改代码为： 12345678910111213141516171819202122232425Observable.interval(1,TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(this))) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.d(\"123\", \"onNext: \"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"123\", \"onComplete: \"); &#125; &#125;); 我们发现加入了 1.as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(this))) 运行项目后，再次验证是否还存在内存泄漏。查看log输出：我们发现onNext不再被回调。 我们来看看AndroidLifecycleScopeProvider.from 传入的参数为LifecycleOwner类型。该类型是Android中的生命周期类型，也就说实现了该接口的Activity及Fragment都可以使用AutoDispose。 注： 集成AutoDispose后如出现如下错误： 1Error: Invoke-customs are only supported starting with Android O (--min-api 26) 解决方法: app 的 build.gradle中android下加入如下配置: 123456android&#123; compileOptions&#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; &#125;","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"AutoDispose","slug":"AutoDispose","permalink":"http://www.zydeveloper.com/tags/AutoDispose/"}]},{"title":"RxJava操作符","slug":"RxJava2","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-08T07:02:08.926Z","comments":true,"path":"2019/08/05/RxJava2/","link":"","permalink":"http://www.zydeveloper.com/2019/08/05/RxJava2/","excerpt":"借用网上一仁兄博客,讲的很全面： 《RxJava操作符汇总》","text":"借用网上一仁兄博客,讲的很全面： 《RxJava操作符汇总》 参考链接地址： RxJava操作符（一） —-创建操作符RxJava操作符（二）—-转换操作符RxJava操作符（三）—-合并操作符RxJava操作符（四）—-功能操作符RxJava操作符（五） —-过滤操作符RxJava操作符（六）—-条件操作符","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"RxJava","slug":"RxJava","permalink":"http://www.zydeveloper.com/tags/RxJava/"}]},{"title":"RxLifecycle 解决RxJava内存泄漏问题","slug":"RxLifecycle","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-07T08:13:59.783Z","comments":true,"path":"2019/08/05/RxLifecycle/","link":"","permalink":"http://www.zydeveloper.com/2019/08/05/RxLifecycle/","excerpt":"RxLifecycle官网 RxLifecycle的出现是为了解决RxJava的内存泄漏问题，RxJava什么时候会出现内存泄漏？ 当使用RxJava订阅执行耗时操作，这是Activity被finish了，如果任务还未执行完成没有取消订阅，这时导致Activity无法回收进而导致内存泄漏问题。","text":"RxLifecycle官网 RxLifecycle的出现是为了解决RxJava的内存泄漏问题，RxJava什么时候会出现内存泄漏？ 当使用RxJava订阅执行耗时操作，这是Activity被finish了，如果任务还未执行完成没有取消订阅，这时导致Activity无法回收进而导致内存泄漏问题。 RxLifecycle让RxJava变得可以感知Activity的生命周期，进而在合适的位置取消订阅，解决内存泄漏问题。 如何使用RxLifecycle？首先导入依赖： 123456implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'implementation 'io.reactivex.rxjava2:rxjava:2.2.11'implementation 'com.trello.rxlifecycle3:rxlifecycle:3.0.0'implementation 'com.trello.rxlifecycle3:rxlifecycle-android:3.0.0'implementation 'com.trello.rxlifecycle3:rxlifecycle-components:3.0.0' 使用Rxlifecycle比较简单，我们的当前Activity需要继承Rx…Activity,当然Fragemnt同理。如： 1public class MainActivity extends RxAppCompatActivity 我们写一个简单的Rxjava应用，每隔1秒执行一次，用于模拟一个可能发送内存泄漏的场景。如: 123456789101112131415161718192021Observable.interval(1, TimeUnit.SECONDS).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.d(\"123\", \"onNext: \"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"123\", \"onComplete: \"); &#125; &#125;); 我们运行代码后，发现onNext的回调一直被执行，在按back键退出发现onNext回调仍然持续执行。我们说这样的情况很容易发生内存泄漏了。 使用bindToLifecycle那么我们如何使用RxLifecycle里避免内存泄漏呢？我们把刚才的程序完善一下，如： 1234567891011121314151617181920212223242526Observable.interval(1, TimeUnit.SECONDS).doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; Log.d(\"123\", \"run: rxjava on dispose\"); &#125; &#125;).compose(this.&lt;Long&gt;bindToLifecycle()).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.d(\"123\", \"onNext: \"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"123\", \"onComplete: \"); &#125; &#125;); 再次运行发现，当我们按下back键时，doOnDispose被执行了，如： 也就是感应到了Activity的生命周期，从而解决可能发生的内存泄露问题。 我们看上面的代码中，加入了一句.compose(this.bindToLifecycle())就可以使用RxLifecycle了是不是很简单。 对应compose操作符不了解的可以参考： Rxjava中compose()操作符的使用 使用bindUntilEventActivityEvent类包括 CREATE、START、 RESUME、PAUSE、STOP、 DESTROY 这些是我们很熟悉的生命周期。我们把刚才的代码稍微修改一下如： 1.compose(this.&lt;Long&gt;bindUntilEvent(ActivityEvent.STOP)) 运行代码，点击back键，看看log输出： 我们发现在Activity的onStop生命周期Rxjava执行了doOnDispose回调。 如上就是我们对RxLifecycle的使用。 注： 运行项目如出现异常： 123Manifest merger failed : Attribute application@appComponentFactory value=(android.support.v4.app.CoreComponentFactory) from [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91 is also present at [androidx.core:core:1.0.0] AndroidManifest.xml:22:18-86 value=(androidx.core.app.CoreComponentFactory). Suggestion: add 'tools:replace=\"android:appComponentFactory\"' to &lt;application&gt; element at AndroidManifest.xml:5:5-19:19 to override. 以为依赖中使用了androidx，所以与我们的support冲突了，解决办法是将我们自己项目的support更换为androidx。 12// implementation 'com.android.support:appcompat-v7:28.0.0'implementation 'androidx.appcompat:appcompat:1.0.0'","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"RxLifecycle","slug":"RxLifecycle","permalink":"http://www.zydeveloper.com/tags/RxLifecycle/"}]},{"title":"ARouter Demo","slug":"ARouterDemo","date":"2019-07-31T16:00:00.000Z","updated":"2019-08-02T01:00:54.410Z","comments":true,"path":"2019/08/01/ARouterDemo/","link":"","permalink":"http://www.zydeveloper.com/2019/08/01/ARouterDemo/","excerpt":"这个Demo用于演示ARouter在项目中的实际使用。 本Demo建立在 Android 组件化开发 的代码基础上，大家可参考相关代码。","text":"这个Demo用于演示ARouter在项目中的实际使用。 本Demo建立在 Android 组件化开发 的代码基础上，大家可参考相关代码。 首先，集成ARouter，在之前的代码中我们说过第三方库的集成我们一般放到Common业务组件中。 12345678910111213141516 defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; ... &#125; dependencies &#123; ... implementation 'com.alibaba:arouter-api:1.5.0' annotationProcessor 'com.alibaba:arouter-compiler:1.2.2' ...&#125; 我们已壳工程中的MainActivity为例让其跳转到Funny业务组件中的FunnyMainActivity。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"ARouter","slug":"ARouter","permalink":"http://www.zydeveloper.com/tags/ARouter/"}]},{"title":"Android 插件化 动态加载Activity","slug":"ActivityDynamicLoad","date":"2019-07-30T16:00:00.000Z","updated":"2019-07-31T09:18:15.839Z","comments":true,"path":"2019/07/31/ActivityDynamicLoad/","link":"","permalink":"http://www.zydeveloper.com/2019/07/31/ActivityDynamicLoad/","excerpt":"之前介绍了如何热更新如何动态加载资源，可参考： Android 热修复 Android插件化——动态资源加载","text":"之前介绍了如何热更新如何动态加载资源，可参考： Android 热修复 Android插件化——动态资源加载 现在我们来看看如何动态加载Activity？ 首先有的人可能会问，activity也是一个类，不同样可以使用DexClassLoader加载上来吗？activity是个类没错，但特殊的是activity有生命周期的，比如我们平时使用activity时会有onCreate onStart … 如果按普通的类加载显然这些生命周期并不会正常回调，activity也不会正常使用。 目前使用的方案有反射实现、接口实现、Hook实现。反射实现有性能问题所以暂不介绍，我们先来介绍一下接口实现方式。 接口实现方式有已经完成的框架 dynamic-load-apk大家可参考使用。 我们来实现一个简单的Demo来看看接口方式实现有哪些优缺点？ 什么是接口实现方式呢？我们可以这样理解，在我们的APP中（也就是宿主APP）的activity是有完整的生命周期的，但Plugin APP中的activity是没有，我们需要让插件中的activity具备生命周期，那我们是否可以使用宿主APP中的activity来通过接口的方式让插件APP中的activity同样具有生命周期呢。 话不多说上代码： 我们先来定义一个module工程用于作为宿主APP与插件APP共同的依赖库。 然后定义一个插件契约接口 12345678910111213141516public interface IPluginContract &#123; void onCreate(Bundle saveInstance); void attachContext(FragmentActivity context); void onStart(); void onResume(); void onRestart(); void onDestroy(); void onStop(); void onPause();&#125; 宿主APP与插件APP都依赖该库，如： 宿主APP中我们需要一个管理插件的类来完成插件的管理工作，如： 12","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"}]},{"title":"Android 插件化 动态加载Activity","slug":"ApkDynamicLoad","date":"2019-07-30T16:00:00.000Z","updated":"2019-07-31T08:08:21.889Z","comments":true,"path":"2019/07/31/ApkDynamicLoad/","link":"","permalink":"http://www.zydeveloper.com/2019/07/31/ApkDynamicLoad/","excerpt":"之前介绍了如何热更新如何动态加载资源，可参考： Android 热修复 Android插件化——动态资源加载","text":"之前介绍了如何热更新如何动态加载资源，可参考： Android 热修复 Android插件化——动态资源加载 现在我们来看看如果","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"}]},{"title":"AsyncTask原理及源码分析（全）","slug":"AsyncTaskSource","date":"2019-07-29T16:00:00.000Z","updated":"2020-03-21T13:05:37.006Z","comments":true,"path":"2019/07/30/AsyncTaskSource/","link":"","permalink":"http://www.zydeveloper.com/2019/07/30/AsyncTaskSource/","excerpt":"","text":"1234567btnMain2Asynctask.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //开始执行异步任务 new MyTask().execute(\"我是入口参数\"); &#125;&#125;); 1234567891011121314151617181920212223242526272829303132333435private class MyTask extends AsyncTask&lt;String,Integer,String&gt;&#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.d(\"123\",\"onPreExecute -&gt; \"+Thread.currentThread().getName()); &#125; @Override protected String doInBackground(String... strings) &#123; Log.i(\"123\", \"doInBackground params =&gt; \"+strings[0]); Log.d(\"123\",\"doInBackground -&gt; \"+Thread.currentThread().getName()); for (int i=0;i&lt;=100;i++)&#123; try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; publishProgress(i); &#125; return \"当前请求已经执行完\"; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(\"123\", \"onProgressUpdate value =&gt; \"+values[0]); Log.d(\"123\",\"onProgressUpdate -&gt; \"+Thread.currentThread().getName()); pbMain2.setProgress(values[0]); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); Log.i(\"123\", \"result =&gt; \"+s); Log.d(\"123\",\"onPostExecute -&gt; \"+Thread.currentThread().getName()); tvMain2Result.setText(s); &#125;&#125; 我们来看 new MyTask().execute(“我是入口参数”); 具体的执行过程： 我们发现execute调用了executeOnExecutor（sDefaultExecutor，params）方法，params这个就是外面传递进来的参数，我们来看看sDefaultExecutor是什么？ 我们发现sDefaultExecutor就是SerialExecutor的实例，接下来我们继续看 1234567891011121314151617181920212223242526272829private static class SerialExecutor implements Executor &#123; //线程队列 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; //加入队列尾 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; //执行runnable的run方法 r.run(); &#125; finally &#123; //执行下一个任务 scheduleNext(); &#125; &#125; &#125;); //如果mActive==null 执行scheduleNext方法 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //从队列中取出runnable 如果不为空交给THREAD_POOL_EXECUTOR线程池执行 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 接下来我们来看看THREAD_POOL_EXECUTOR线程池是如果创建的 12345678910public static final Executor THREAD_POOL_EXECUTOR;static &#123; //线程池创建 CORE_POOL_SIZE 核心线程数 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); //将创建的线程池赋值给THREAD_POOL_EXECUTOR THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 12345678910//获取系统CPU数量private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();// We want at least 2 threads and at most 4 threads in the core pool,// preferring to have 1 less than the CPU count to avoid saturating// the CPU with background work//获取设置的核心线程数private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));//获取设置的最大线程数private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30; 如下是executeOnExecutor方法的源码逻辑： 12345678910111213141516171819202122232425@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //判断如果当前任务状态不是“就绪”就直接抛异常 if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; //更新任务当前状态为RUNNING mStatus = Status.RUNNING; //回调onPreExecute方法，该方法我们Demo中已经实现 onPreExecute(); //将入口参数传递mWorker mWorker.mParams = params; //通过线程池执行mFuture exec.execute(mFuture); return this;&#125; 如上实现线程池执行的mFuture对象及后续的调用流程参见如下分析： 先来分析 new MyTask（）发生了什么？ 首先MyTask继续了AsyncTask所以 new AsyncTask构造会被调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public AsyncTask(@Nullable Looper callbackLooper) &#123; //判断入口参数callbackLooper是否为空或者是否是MainLooper 如果为空或者是MainLooper从而返回MainHandler 其他返回对应callbackLooper的Hander mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); //创建了一个工作任务 WorkerRunnable继承了Callable 所以重写了如下的call方法 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; //设置任务已经执行 mTaskInvoked.set(true); Result result = null; try &#123; //设置当前线程优先级为Background线程 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked //调用了doInBackground,该方法我们已经在demo中复写了 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; //设置了取消标记为True mCancelled.set(true); throw tr; &#125; finally &#123; //发送了结果数据 postResult(result); &#125; //返回执行结果 return result; &#125; &#125;; //计划待执行任务 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 如下是我们自己实现的doInBackground方法逻辑，最终也返回了执行结果。postResult（）代码逻辑如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 如上代码使用了AsyncTask里的Handler发送了Message，交给handler handleMessage来处理。如下就是处理消息的代码逻辑： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; //处理如上发过来的Message case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; result.mTask.finish(result.mData[0]);就是将result结果数据传递并调用了AsyncTask的finish方法。具体代码如下： 123456789101112private void finish(Result result) &#123; //判断是否取消，如果取消就调用onCancelled回调方法，如果没有取消就调用onPostExecute方法，该方法我们已经在Demo中复写了。 if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; //回调结果数据 onPostExecute(result); &#125; //设置当前任务状态为已完成 mStatus = Status.FINISHED;&#125; 下面来分析一下AsyncTask的进度更新逻辑： 12345678910111213141516@Overrideprotected String doInBackground(String... strings) &#123; Log.i(\"123\", \"doInBackground params =&gt; \"+strings[0]); Log.d(\"123\",\"doInBackground -&gt; \"+Thread.currentThread().getName()); for (int i=0;i&lt;=100;i++)&#123; try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //此处代码进行了进度发布 publishProgress(i); &#125; return \"当前请求已经执行完\";&#125; 如下是AsyncTask的publishProgress方法处理逻辑： 123456789@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; //同理使用Handler发送了MESSAGE_POST_PROGRESS的Message getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 与刚才MESSAGE_POST_RESULT一样逻辑还是由InternalHandler来处理对应的What类型数据， 12345678910111213@Overridepublic void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125;&#125; 如上onProgressUpdate我们也在Demo中实现了进度条控件的进度更新。 如上就是对AsyncTask的源码分析。","categories":[{"name":"源码分析","slug":"源码分析","permalink":"http://www.zydeveloper.com/categories/源码分析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.zydeveloper.com/tags/源码分析/"}]},{"title":"Android 组件化开发","slug":"Componentization","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-03T00:40:50.472Z","comments":true,"path":"2019/07/30/Componentization/","link":"","permalink":"http://www.zydeveloper.com/2019/07/30/Componentization/","excerpt":"什么是组件化？组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科","text":"什么是组件化？组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程，有多种属性、状态反映其内部特性。组件化是一种高效的处理复杂应用系统，更好的明确功能模块作用的方式。 ————百度百科 本人对于组件化的理解为是一种架构思想，与传统项目（一般指模块化）相比各个业务组件相互隔离，使各个组件可以单独运行单独测试，使用“壳工程”将其组装到一起。这样带来的好处是业务模块单独开发维护降低耦合性，使项目可测试性及可维护性提升。 （该图片来源于互联网） 上图很形象的描述了组件化各层级的结构。 对于之前我们的项目大多是将业务模块与基础模块都放到一个app工程中开发维护，这样做的缺点是不易测试，耦合度高等问题显而易见。有的朋友可能会说我们使用了MVC MVP 甚至 MVVM架构不可以解耦吗？使用架构当然可以解耦，但与组件化还不在一个层面上，组件化更偏向于将业务功能模块拆分。 下面我们通过一个Demo来具体演示一下组件化该如何搭建？ 例如我们要实现上图这样的一个咨询类app，我们的项目结构搭建如下： app——壳工程mainmodule——欢迎页面 启动页面 主页面模块videomodule——视频模块funnymodule——段子业务模块usermodule——用户模块对应“我的”messagemodule——系统消息模块commonmodule——通用模块，主要放一下BaseActivity BaseFragment 网络框架等customviewmodule——自定义View模块 如上是我们对应该app拆分出的业务模块，其中还包括一些基础模块。 下面我们来建立一个config.gradle来统一配置工程信息。如： 1234567891011121314151617181920212223242526272829ext&#123; /** * 是否模块化 */ isCommonModule = true isCustomModule = true isFunnyModule = true isMainModule = true isMessageModule = true isUserModule =true isVideoModule = true /*defaultConfig*/ compile_sdk_version = 28 min_sdk_version = 15 target_sdk_version = 28 version_code = 1 version_name = \"1.0.0\" multiDexEnabled = true /*dependencies*/ android_support = \"28.0.0\" retrofit = \"2.4.0\" ok_http = \"3.10.0\" rx_android = \"2.0.2\" rx_java = \"2.1.4\" dagger2 = \"2.16\"&#125; 然后在project的build.gradle中引入config.gradle. 这样在我们的module中就可以使用我们的配置信息了。使用app的module build.gradle 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950apply plugin: 'com.android.application'android &#123; compileSdkVersion compile_sdk_version defaultConfig &#123; applicationId \"com.baweigame.componentdemoapplication\" minSdkVersion min_sdk_version targetSdkVersion target_sdk_version versionCode version_code versionName version_name testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') implementation \"com.android.support:appcompat-v7:$android_support\" implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' if (isCommonModule.toBoolean())&#123; implementation project(':commonmodule') &#125; if (isCustomModule.toBoolean())&#123; implementation project(':customviewmodule') &#125; if(isFunnyModule.toBoolean())&#123; implementation project(':funnymodule') &#125; if (isMainModule.toBoolean())&#123; implementation project(':mainmodule') &#125; if (isMessageModule.toBoolean())&#123; implementation project(':messagemodule') &#125; if (isUserModule.toBoolean())&#123; implementation project(':usermodule') &#125; if (isVideoModule.toBoolean())&#123; implementation project(':videomodule') &#125;&#125; 多个模块build.gradle大多一样，所以使用mainmodule 举例，build.gradle： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455if (isMainModule.toBoolean())&#123; apply plugin: 'com.android.library'&#125;else&#123; apply plugin: 'com.android.application'&#125;android &#123; compileSdkVersion compile_sdk_version //限定命名前缀避免冲突 resourcePrefix \"$&#123;project.name&#125;_\" defaultConfig &#123; if (!isMainModule.toBoolean())&#123; applicationId \"com.baweigame.mainmodule\" &#125; minSdkVersion min_sdk_version targetSdkVersion target_sdk_version versionCode version_code versionName version_name testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; sourceSets &#123; main &#123; if (isMainModule.toBoolean()) &#123; manifest.srcFile module_Manifest &#125; else &#123; manifest.srcFile app_Manifest &#125; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation \"com.android.support:appcompat-v7:$android_support\" implementation 'com.android.support.constraint:constraint-layout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; 我们发现几处需要注意的地方： 123456if (isMainModule.toBoolean())&#123; apply plugin: 'com.android.library'&#125;else&#123; apply plugin: 'com.android.application'&#125; 如果开启main模块模式，就设置该module为library模式，反之使用application模式。 12//限定命名前缀避免冲突resourcePrefix \"$&#123;project.name&#125;_\" 限定资源命名加前缀避免冲突 123456789sourceSets &#123; main &#123; if (isMainModule.toBoolean()) &#123; manifest.srcFile module_Manifest &#125; else &#123; manifest.srcFile app_Manifest &#125; &#125; &#125; 我们知道AnroidMainfest文件是android工程的必须文件，用于设置权限及四大组件注册声明等。当我们module工程为application模式时我们之前的清单文件可以正常使用，但设置成module模式后我们的清单文件就需要合并到app工程中，这样我们源清单文件中的application设置及LAUNCHER的activity都会出现合并错误。 所以我们采用使用两份清单文件提供给两种模式使用。我们看看module模式下的清单文件： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.baweigame.mainmodule\"&gt; &lt;application android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainModuleActivity\"&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 在看看application模式下的清单文件： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.baweigame.mainmodule\"&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainModuleActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 123if (!isMainModule.toBoolean())&#123; applicationId \"com.baweigame.mainmodule\" &#125; 如果不开启main模块模式就设置applicationId 当然还可以管理我们第三方的库版本。 关于Applicaton Context 获取问题？我们知道一个APP有且只有一个Application，我们在APP工程中获取Application Context很容易就能获取到，但是如果使用组件化方案时各业务组件获取Application Context就比较麻烦了。那么我们如何解决这个问题呢？我们还记得模块中有个Common业务模块吗？这个模块就是用于存放BaseApplcation BaseActivity的地方，也就是说我们可以让壳APP与各业务模块都依赖这个Common模块，然后壳App工程application实现Common模块中的BaseApplication。如：Common 模块中的BaseApplication。 123456789101112131415161718package com.baweigame.commonmodule;import android.app.Application;import android.content.Context;public class BaseApplication extends Application &#123; private Context mContext; @Override public void onCreate() &#123; super.onCreate(); mContext=this.getApplicationContext(); &#125; public Context getContext()&#123; return mContext; &#125;&#125; 壳APP工程的MyApplication 12345678910package com.baweigame.componentdemoapplication;import com.baweigame.commonmodule.BaseApplication;public class MyApplication extends BaseApplication &#123; @Override public void onCreate() &#123; super.onCreate(); &#125;&#125; 当然清单文件中要指定该Application。 12345678&lt;application android:name=\".MyApplication\" android:allowBackup=\"false\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; Common模块下面来说说Common模块，该模块是所有业务模块的基础，不只单单放一下BaseXX,它还有如下用处： 1、Common组件清单文件（AndroidMainfest.xml）声明了我们应用中用到的所有使用权限 uses-permission，放到这里是因为在组件开发模式下，所有业务组件就无需在自己的 AndroidManifest.xm 声明自己要用到的权限了。 2、Common组件的 build.gradle 需要统一依赖第三方依赖库和jar包，例如我们用到的RXJava、Dagger2,Okhttp等等。 3、Common组件中封装了Android应用的 Base类和网络请求工具、图片加载工具等等，公用的 widget控件也应该放在Common 组件中；业务组件中都用到的数据也应放于Common组件中，例如保存到 SharedPreferences 和 DataBase 中的登陆数据； 4、Common组件的资源文件中需要放置项目公用的 Drawable、layout、sting、dimen、color和style 等等，另外项目中的 Activity 主题必须定义在 Common中，方便和 BaseActivity 配合保持整个Android应用的界面风格统一。 如上引用至 Android组件化方案 上面我们就已经搭建了一个基础的组件结构。 主界面搭建下面我们使用该结构搭建一下主界面，如：页面结构我们放到了app工程中，然后使用RadioGroup做底部导航，上面使用4个业务模块中的Fragment。（main video funny user）在common中建立BaseFragment。然后4个业务模块中的Fragment都集成BaseFragment。如： 12345678public class VideoModuleFragment extends BaseFragment &#123; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View v=inflater.inflate(R.layout.videomodule_video_fragment,null); return v; &#125;&#125; 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:gravity=\"center\" style=\"@style/TextViewStyle\" android:text=\"视频 Fragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; 其中的TextView style在common中设置如： 1234&lt;style name=\"TextViewStyle\"&gt; &lt;item name=\"android:textSize\"&gt;35sp&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@android:color/holo_green_light&lt;/item&gt; &lt;/style&gt; 其他3个业务模块同上。看一下app MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" android:orientation=\"vertical\"&gt; &lt;FrameLayout android:id=\"@+id/fl_main\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"9\"&gt;&lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"&gt; &lt;RadioGroup android:id=\"@+id/rg_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;RadioButton android:id=\"@+id/rb_main\" style=\"@style/RadioButtonStyle\" android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"主页\"/&gt; &lt;RadioButton android:id=\"@+id/rb_video\" style=\"@style/RadioButtonStyle\" android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"视频\"/&gt; &lt;RadioButton android:id=\"@+id/rb_funney\" style=\"@style/RadioButtonStyle\" android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"段子\"/&gt; &lt;RadioButton android:id=\"@+id/rb_my\" style=\"@style/RadioButtonStyle\" android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"我的\"/&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 其中 style=”@style/RadioButtonStyle” 同样来自于common中设置，如： 1234567891011121314151617181920212223&lt;style name=\"RadioButtonStyle\"&gt; &lt;item name=\"android:textSize\"&gt;25sp&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/commonmodule_radiobutton_textcolor_selector&lt;/item&gt; &lt;item name=\"android:background\"&gt;@drawable/commonmodule_radiobutton_selecter&lt;/item&gt; &lt;item name=\"android:gravity\"&gt;center&lt;/item&gt; &lt;item name=\"android:button\"&gt;@null&lt;/item&gt;&lt;/style&gt;commonmodule_radiobutton_textcolor_selector&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\" android:color=\"@android:color/white\"&gt;&lt;/item&gt; &lt;item android:state_checked=\"false\" android:color=\"@android:color/black\"&gt;&lt;/item&gt;&lt;/selector&gt;commonmodule_radiobutton_selecter&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\" android:drawable=\"@android:color/holo_orange_dark\"&gt;&lt;/item&gt; &lt;item android:state_checked=\"false\" android:drawable=\"@android:color/white\"&gt;&lt;/item&gt;&lt;/selector&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.baweigame.componentdemoapplication;import android.support.v4.app.Fragment;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.FrameLayout;import android.widget.RadioGroup;import com.baweigame.commonmodule.BaseFragment;import com.baweigame.funnymodule.FunnyMainFragment;import com.baweigame.mainmodule.MainModuleFragment;import com.baweigame.usermodule.UserModuleFragment;import com.baweigame.videomodule.VideoModuleFragment;public class MainActivity extends AppCompatActivity &#123; private FrameLayout flMain; private RadioGroup rgMain; private BaseFragment mainFragment; private BaseFragment videoFragment; private BaseFragment funnyFragment; private BaseFragment myFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); replaceFragment(new MainModuleFragment()); &#125; private &lt;T extends Fragment&gt; void replaceFragment(T fragment)&#123; getSupportFragmentManager().beginTransaction().replace(R.id.fl_main,fragment).commit(); &#125; private void initListener() &#123; rgMain.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; switch (checkedId)&#123; case R.id.rb_main: replaceFragment(new MainModuleFragment()); break; case R.id.rb_video: replaceFragment(new VideoModuleFragment()); break; case R.id.rb_funney: replaceFragment(new FunnyMainFragment()); break; case R.id.rb_my: replaceFragment(new UserModuleFragment()); break; &#125; &#125; &#125;); &#125; private void initView() &#123; flMain = (FrameLayout) findViewById(R.id.fl_main); rgMain = (RadioGroup) findViewById(R.id.rg_main); &#125;&#125; 如上我们搭建了一下主界面。 下一篇我们来使用阿里的ARouter来进行组件间的通信。 Android 组件化 ARouter","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"}]},{"title":"Android 组件化 ARouter","slug":"Arouter","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-01T08:24:32.681Z","comments":true,"path":"2019/07/30/Arouter/","link":"","permalink":"http://www.zydeveloper.com/2019/07/30/Arouter/","excerpt":"ARouter 官网","text":"ARouter 官网 ARouter是什么？A framework for assisting in the renovation of Android componentization (帮助 Android App 进行组件化改造的路由框架) 是Alibaba推出的一个路由框架。 ————-如下内容来自ARouter官网 ARouter 官方文档 一、功能介绍支持直接解析标准URL进行跳转，并自动注入参数到目标页面中支持多模块工程使用支持添加多个拦截器，自定义拦截顺序支持依赖注入，可单独作为依赖注入框架使用支持InstantRun支持MultiDex(Google方案)映射关系按组分类、多级管理，按需初始化支持用户指定全局降级与局部降级策略页面、拦截器、服务等组件均自动注册到框架支持多种方式配置转场动画支持获取Fragment完全支持Kotlin以及混编(配置见文末 其他#5)支持第三方 App 加固(使用 arouter-register 实现自动注册)支持生成路由文档提供 IDE 插件便捷的关联路径和目标类 二、典型应用从外部URL映射到内部页面，以及参数传递与解析跨模块页面跳转，模块间解耦拦截跳转过程，处理登陆、埋点等逻辑跨模块API调用，通过控制反转来做组件解耦 三、基础功能添加依赖和配置 123456789101112131415161718android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile 'com.alibaba:arouter-api:x.x.x' annotationProcessor 'com.alibaba:arouter-compiler:x.x.x' ...&#125; // 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末’其他#4’// Kotlin配置参考文末’其他#5’添加注解 123456// 在支持路由的页面上添加注解(必选)// 这里的路径需要注意的是至少需要有两级，/xx/xx@Route(path = \"/test/activity\")public class YourActivity extend Activity &#123; ...&#125; 初始化SDK 12345678910111213141516if (isDebug()) &#123; // 这两行必须写在init之前，否则这些配置在init过程中将无效 ARouter.openLog(); // 打印日志 ARouter.openDebug(); // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)&#125;ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化发起路由操作// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)ARouter.getInstance().build(\"/test/activity\").navigation();// 2. 跳转并携带参数ARouter.getInstance().build(\"/test/1\") .withLong(\"key1\", 666L) .withString(\"key3\", \"888\") .withObject(\"key4\", new Test(\"Jack\", \"Rose\")) .navigation(); 添加混淆规则(如果使用了Proguard) 123-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125; 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口 1-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现 1-keep class * implements com.alibaba.android.arouter.facade.template.IProvider 使用 Gradle 插件实现路由表的自动加载 (可选) 1234567891011apply plugin: 'com.alibaba.arouter'buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath \"com.alibaba:arouter-register:?\" &#125;&#125; 可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载(power by AutoRegister)， 默认通过扫描 dex 的方式 进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问 dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！ 使用 IDE 插件导航到目标类 (可选) 在 Android Studio 插件市场中搜索 ARouter Helper, 或者直接下载文档上方 最新版本 中列出的 arouter-idea-plugin zip 安装包手动安装，安装后 插件无任何设置，可以在跳转代码的行首找到一个图标 (navigation) 点击该图标，即可跳转到标识了代码中路径的目标类 四、进阶用法通过URL跳转 1234567891011// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125;&#125; AndroidManifest.xml 12345678910111213&lt;activity android:name=\".activity.SchameFilterActivity\"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host=\"m.aliyun.com\" android:scheme=\"arouter\"/&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 解析参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 为每一个参数声明一个字段，并使用 @Autowired 标注// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象@Route(path = \"/test/activity\")public class Test1Activity extends Activity &#123; @Autowired public String name; @Autowired int age; // 通过name来映射URL中的不同参数 @Autowired(name = \"girl\") boolean boy; // 支持解析自定义对象，URL中使用json传递 @Autowired TestObj obj; // 使用 withObject 传递 List 和 Map 的实现了 // Serializable 接口的实现类(ArrayList/HashMap) // 的时候，接收该对象的地方不能标注具体的实现类类型 // 应仅标注为 List 或 Map，否则会影响序列化中类型 // 的判断, 其他类似情况需要同样处理 @Autowired List&lt;TestObj&gt; list; @Autowired Map&lt;String, List&lt;TestObj&gt;&gt; map; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // ARouter会自动对字段进行赋值，无需主动获取 Log.d(\"param\", name + age + boy); &#125;&#125;// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：@Route(path = \"/yourservicegroupname/json\")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125;&#125; 声明拦截器(拦截跳转过程，面向切面编程) 123456789101112131415161718// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行@Interceptor(priority = 8, name = \"测试用拦截器\")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... callback.onContinue(postcard); // 处理完成，交还控制权 // callback.onInterrupt(new RuntimeException(\"我觉得有点异常\")); // 觉得有问题，中断路由流程 // 以上两种至少需要调用其中一种，否则不会继续路由 &#125; @Override public void init(Context context) &#123; // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次 &#125;&#125; 处理跳转结果 123456789101112// 使用两个参数的navigation方法，可以获取单次跳转的结果ARouter.getInstance().build(\"/test/1\").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; ... &#125; @Override public void onLost(Postcard postcard) &#123; ... &#125;&#125;); 自定义全局降级策略 12345678910111213// 实现DegradeService接口，并加上一个Path内容任意的注解即可@Route(path = \"/xxx/xxx\")public class DegradeServiceImpl implements DegradeService &#123;@Overridepublic void onLost(Context context, Postcard postcard) &#123; // do something.&#125;@Overridepublic void init(Context context) &#123;&#125;&#125; 为目标页面声明更多信息 12345678910111213141516171819202122232425// 我们经常需要在目标页面中配置一些属性，比方说\"是否需要登陆\"之类的// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断@Route(path = \"/test/activity\", extras = Consts.XXXX)通过依赖注入解耦:服务管理(一) 暴露服务// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = \"/yourservicegroupname/hello\", name = \"测试服务\")public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return \"hello, \" + name; &#125; @Override public void init(Context context) &#123; &#125;&#125; 通过依赖注入解耦:服务管理(二) 发现服务 12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = \"/yourservicegroupname/hello\") HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello(\"Vergil\"); helloService2.sayHello(\"Vergil\"); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build(\"/yourservicegroupname/hello\").navigation(); helloService3.sayHello(\"Vergil\"); helloService4.sayHello(\"Vergil\"); &#125;&#125; 预处理服务 12345678910111213// 实现 PretreatmentService 接口，并加上一个Path内容任意的注解即可@Route(path = \"/xxx/xxx\")public class PretreatmentServiceImpl implements PretreatmentService &#123; @Override public boolean onPretreatment(Context context, Postcard postcard) &#123; // 跳转前预处理，如果需要自行处理跳转，该方法返回 false 即可 &#125; @Override public void init(Context context) &#123; &#125;&#125; 五、更多功能初始化中的其他设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110ARouter.openLog(); // 开启日志ARouter.openDebug(); // 使用InstantRun的时候，需要打开该开关，上线之后关闭，否则有安全风险ARouter.printStackTrace(); // 打印日志的时候打印线程堆栈详细的API说明// 构建标准的路由请求ARouter.getInstance().build(\"/home/main\").navigation();// 构建标准的路由请求，并指定分组ARouter.getInstance().build(\"/home/main\", \"ap\").navigation();// 构建标准的路由请求，通过Uri直接解析Uri uri;ARouter.getInstance().build(uri).navigation();// 构建标准的路由请求，startActivityForResult// navigation的第一个参数必须是Activity，第二个参数则是RequestCodeARouter.getInstance().build(\"/home/main\", \"ap\").navigation(this, 5);// 直接传递BundleBundle params = new Bundle();ARouter.getInstance() .build(\"/home/main\") .with(params) .navigation();// 指定FlagARouter.getInstance() .build(\"/home/main\") .withFlags(); .navigation();// 获取FragmentFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation(); // 对象传递ARouter.getInstance() .withObject(\"key\", new TestObj(\"Jack\", \"Rose\")) .navigation();// 觉得接口不够多，可以直接拿出Bundle赋值ARouter.getInstance() .build(\"/home/main\") .getExtra();// 转场动画(常规方式)ARouter.getInstance() .build(\"/test/activity2\") .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前ActivityARouter.getInstance() .build(\"/test/activity2\") .withOptionsCompat(compat) .navigation(); // 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build(\"/home/main\").greenChannel().navigation();// 使用自己的日志工具打印日志ARouter.setLogger();// 使用自己提供的线程池ARouter.setExecutor();获取原始的URIString uriStr = getIntent().getStringExtra(ARouter.RAW_URI);重写跳转URL// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可@Route(path = \"/xxx/xxx\") // 必须标明注解public class PathReplaceServiceImpl implements PathReplaceService &#123; /** * For normal path. * * @param path raw path */ String forString(String path) &#123; return path; // 按照一定的规则处理之后返回处理后的结果 &#125;/** * For uri type. * * @param uri raw uri */Uri forUri(Uri uri) &#123; return url; // 按照一定的规则处理之后返回处理后的结果&#125;&#125;生成路由文档// 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.jsonandroid &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: \"enable\"] &#125; &#125; &#125;&#125; 六、其他路由中的分组概念 SDK中针对所有的路径(/test/1 /test/2)进行分组，分组只有在分组中的某一个路径第一次被访问的时候，该分组才会被初始化可以通过 @Route 注解主动指定分组，否则使用路径中第一段字符串(/*/)作为分组注意：一旦主动指定分组之后，应用内路由需要使用 ARouter.getInstance().build(path, group) 进行跳转，手动指定分组，否则无法找到@Route(path = “/test/1”, group = “app”)拦截器和服务的异同 拦截器和服务所需要实现的接口不同，但是结构类似，都存在 init(Context context) 方法，但是两者的调用时机不同拦截器因为其特殊性，会被任何一次路由所触发，拦截器会在ARouter初始化的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。服务没有该限制，某一服务可能在App整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作旧版本gradle插件的配置方式 1234567891011121314151617181920212223apply plugin: 'com.neenbedankt.android-apt'buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' &#125;&#125;apt &#123; arguments &#123; AROUTER_MODULE_NAME project.getName(); &#125;&#125;dependencies &#123; compile 'com.alibaba:arouter-api:x.x.x' apt 'com.alibaba:arouter-compiler:x.x.x' ...&#125; Kotlin项目中的配置方式 1234567891011121314// 可以参考 module-kotlin 模块中的写法apply plugin: 'kotlin-kapt'kapt &#123; arguments &#123; arg(\"AROUTER_MODULE_NAME\", project.getName()) &#125;&#125;dependencies &#123; compile 'com.alibaba:arouter-api:x.x.x' kapt 'com.alibaba:arouter-compiler:x.x.x' ...&#125; 七、Q&amp;A“W/ARouter::: ARouter::No postcard![ ]” 这个Log正常的情况下也会打印出来，如果您的代码中没有实现DegradeService和PathReplaceService的话，因为ARouter本身的一些功能也依赖 自己提供的Service管理功能，ARouter在跳转的时候会尝试寻找用户实现的PathReplaceService，用于对路径进行重写(可选功能)，所以如果您没有 实现这个服务的话，也会抛出这个日志 推荐在app中实现DegradeService、PathReplaceService “W/ARouter::: ARouter::There is no route match the path [/xxx/xxx], in group [xxx][ ]” 通常来说这种情况是没有找到目标页面，目标不存在如果这个页面是存在的，那么您可以按照下面的步骤进行排查检查目标页面的注解是否配置正确，正确的注解形式应该是 (@Route(path=”/test/test”), 如没有特殊需求，请勿指定group字段，废弃功能)检查目标页面所在的模块的gradle脚本中是否依赖了 arouter-compiler sdk (需要注意的是，要使用apt依赖，而不是compile关键字依赖)检查编译打包日志，是否出现了形如 ARouter::�Compiler &gt;&gt;&gt; xxxxx 的日志，日志中会打印出发现的路由目标启动App的时候，开启debug、log(openDebug/openLog), 查看映射表是否已经被扫描出来，形如 D/ARouter::: LogisticsCenter has already been loaded, GroupIndex[4]，GroupIndex &gt; 0开启InstantRun之后无法跳转(高版本Gradle插件下无法跳转)？ 因为开启InstantRun之后，很多类文件不会放在原本的dex中，需要单独去加载，ARouter默认不会去加载这些文件，因为安全原因，只有在开启了openDebug之后 ARouter才回去加载InstantRun产生的文件，所以在以上的情况下，需要在init之前调用openDebug TransformException:java.util.zip.ZipException: duplicate entry …. ARouter有按组加载的机制，关于分组可以参考 6-1 部分，ARouter允许一个module中存在多个分组，但是不允许多个module中存在相同的分组，会导致映射文件冲突 Kotlin类中的字段无法注入如何解决？ 首先，Kotlin中的字段是可以自动注入的，但是注入代码为了减少反射，使用的字段赋值的方式来注入的，Kotlin默认会生成set/get方法，并把属性设置为private 所以只要保证Kotlin中字段可见性不是private即可，简单解决可以在字段上添加 @JvmField 通过URL跳转之后，在intent中拿不到参数如何解决？ 需要注意的是，如果不使用自动注入，那么可以不写 ARouter.getInstance().inject(this)，但是需要取值的字段仍然需要标上 @Autowired 注解，因为 只有标上注解之后，ARouter才能知道以哪一种数据类型提取URL中的参数并放入Intent中，这样您才能在intent中获取到对应的参数 新增页面之后，无法跳转？ ARouter加载Dex中的映射文件会有一定耗时，所以ARouter会缓存映射文件，直到新版本升级(版本号或者versionCode变化)，而如果是开发版本(ARouter.openDebug())， ARouter 每次启动都会重新加载映射文件，开发阶段一定要打开 Debug 功能","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"组件化","slug":"组件化","permalink":"http://www.zydeveloper.com/tags/组件化/"},{"name":"ARouter","slug":"ARouter","permalink":"http://www.zydeveloper.com/tags/ARouter/"}]},{"title":"RxJava使用","slug":"RxJava","date":"2019-07-29T16:00:00.000Z","updated":"2019-07-30T00:44:21.192Z","comments":true,"path":"2019/07/30/RxJava/","link":"","permalink":"http://www.zydeveloper.com/2019/07/30/RxJava/","excerpt":"RxJava 到底是什么一个词：异步。RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。","text":"RxJava 到底是什么一个词：异步。RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 RxJava 好在哪换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』一个词：简洁。异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 GITHUB 地址 Rxjava github地址Rxandroid github地址 项目中依赖 12implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'implementation 'io.reactivex.rxjava2:rxjava:2.2.9' 一个小 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/*** 创建观察者*/Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;@Overridepublic void onSubscribe(Disposable d) &#123; // Disposable 用于解除绑定使用 d.dispose(); Log.d(TAG, \"onSubscribe: \");&#125;@Overridepublic void onNext(String s) &#123; Log.d(TAG, \"Item: \" + s);&#125;@Overridepublic void onError(Throwable e) &#123; Log.d(TAG, \"Error!\");&#125;@Overridepublic void onComplete() &#123; Log.d(TAG, \"Completed!\");&#125;&#125;;// 被观察者Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;@Overridepublic void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onNext(\"4\"); emitter.onComplete();&#125;&#125;);// 订阅observable.subscribe(observer);另一个demoDefaultSubscriber subscriber = new DefaultSubscriber&lt;String&gt;() &#123;@Overridepublic void onNext(String s) &#123; Log.d(TAG, \"Item: \" + s);&#125;@Overridepublic void onError(Throwable e) &#123; Log.d(TAG, \"Error!\");&#125;@Overridepublic void onComplete() &#123; Log.d(TAG, \"onComplete!\");&#125;&#125;;Flowable&lt;String&gt; stringFlowable = (Flowable&lt;String&gt;) Flowable.create(new FlowableOnSubscribe&lt;String&gt;() &#123;@Overridepublic void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"11\"); emitter.onNext(\"22\"); emitter.onNext(\"33\"); emitter.onNext(\"44\"); emitter.onComplete();&#125;&#125;, BackpressureStrategy.BUFFER);stringFlowable.subscribe(subscriber);第3个demoFlowable.range(0,10).subscribe(new Subscriber&lt;Integer&gt;() &#123;@Overridepublic void onSubscribe(Subscription s) &#123;&#125;@Overridepublic void onNext(Integer integer) &#123;&#125;@Overridepublic void onError(Throwable t) &#123;&#125;@Overridepublic void onComplete() &#123;&#125;&#125;); 什么是背压（Backpressure）在RxJava中，可以通过对Observable连续调用多个Operator组成一个调用链，其中数据从上游向下游传递。当上游发送数据的速度大于下游处理数据的速度时，就需要进行Flow Control了。如果不进行Flow Control，就会抛出MissingBackpressureException异常。这就像小学做的那道数学题：一个水池，有一个进水管和一个出水管。如果进水管水流更大，过一段时间水池就会满（溢出）。这就是没有Flow Control导致的结果。再举个例子，在 RxJava1.x 中的 observeOn， 因为是切换了消费者的线程，因此内部实现用队列存储事件。在 Android 中默认的 buffersize 大小是16，因此当消费比生产慢时， 队列中的数目积累到超过16个，就会抛出MissingBackpressureException。 在RxJava2.0中，有五种观察者模式： 1. Observable/Observer 2. Flowable/Subscriber 3. Single/SingleObserver 4. Completable/CompletableObserver 5. Maybe/MaybeObserver 后面三种观察者模式差不多，Maybe/MaybeObserver可以说是Single/SingleObserver和Completable/CompletableObserver的复合体。下面列出这五个观察者模式相关的接口。 Observable/Observer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt;&#123;...&#125;public interface ObservableSource&lt;T&gt; &#123; void subscribe(Observer&lt;? super T&gt; observer);&#125;public interface Observer&lt;T&gt; &#123; void onSubscribe(Disposable d); void onNext(T t); void onError(Throwable e); void onComplete();&#125;**Completable/CompletableObserver**//代表一个延迟计算没有任何价值,但只显示完成或异常。类似事件模式Reactive-Streams:onSubscribe(onError | onComplete)?public abstract class Completable implements CompletableSource&#123;...&#125;//没有子类继承Completablepublic interface CompletableSource &#123;void subscribe(CompletableObserver cs);&#125;public interface CompletableObserver &#123; void onSubscribe(Disposable d); void onComplete(); void onError(Throwable e);&#125;**Flowable/Subscriber**public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt;&#123;...&#125;public interface Publisher&lt;T&gt; &#123; public void subscribe(Subscriber&lt;? super T&gt; s);&#125;public interface Subscriber&lt;T&gt; &#123; public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete();&#125;**Maybe/MaybeObserver**//Maybe类似Completable，它的主要消费类型是MaybeObserver顺序的方式，遵循这个协议:onSubscribe(onSuccess | onError | onComplete)public abstract class Maybe&lt;T&gt; implements MaybeSource&lt;T&gt;&#123;...&#125;public interface MaybeSource&lt;T&gt; &#123; void subscribe(MaybeObserver&lt;? super T&gt; observer);&#125;public interface MaybeObserver&lt;T&gt; &#123; void onSubscribe(Disposable d); void onSuccess(T t); void onError(Throwable e); void onComplete();&#125;**Single/SingleObserver**//Single功能类似于Observable,除了它只能发出一个成功的值,或者一个错误(没有“onComplete”事件)，这个特性是由SingleSource接口决定的。public abstract class Single&lt;T&gt; implements SingleSource&lt;T&gt;&#123;...&#125;public interface SingleSource&lt;T&gt; &#123; void subscribe(SingleObserver&lt;? super T&gt; observer);&#125;public interface SingleObserver&lt;T&gt; &#123; void onSubscribe(Disposable d); void onSuccess(T t); void onError(Throwable e);&#125; 其实从API中我们可以看到，每一种观察者都继承自各自的接口（都有一个共同的方法subscrib()），但是参数不一样），正是各自接口的不同，决定了他们功能不同，各自独立（特别是Observable和Flowable），同时保证了他们各自的拓展或者配套的操作符不会相互影响。 下面我们重点说说在实际开发中经常会用到的两个模式：Observable/Observer和Flowable/Subscriber。 Observable/Observer Observable正常用法： 12345678910111213141516171819202122232425262728Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); 需要注意的是，这类观察模式不支持背压，下面我们具体分析下。当被观察者快速发送大量数据时，下游不会做其他处理，即使数据大量堆积，调用链也不会报MissingBackpressureException，消耗内存过大只会OOM。在测试的时候，快速发送了100000个整形数据，下游延迟接收，结果被观察者的数据全部发送出去了，内存确实明显增加了，遗憾的是没有OOM。所以，当我们使用Observable/Observer的时候，我们需要考虑的是，数据量是不是很大(官方给出以1000个事件为分界线)。 Flowable/Subscriber 123Flowable.range(0, 10).subscribe(new Subscriber&lt;Integer&gt;() &#123;Subscription subscription; 1234567891011121314151617181920212223242526//当订阅后，会首先调用这个方法，其实就相当于onStart()，//传入的Subscription s参数可以用于请求数据或者取消订阅@Overridepublic void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onsubscribe start\"); subscription = s; subscription.request(1); Log.d(TAG, \"onsubscribe end\");&#125;@Overridepublic void onNext(Integer o) &#123; Log.d(TAG, \"onNext---&gt;\" + o); subscription.request(3);&#125;@Overridepublic void onError(Throwable t) &#123; t.printStackTrace();&#125;@Overridepublic void onComplete() &#123; Log.d(TAG, \"onComplete\");&#125;&#125;); 输出结果如下：onsubscribe startonNext—&gt;0onNext—&gt;1onNext—&gt;2onNext—&gt;3onNext—&gt;4onNext—&gt;5onNext—&gt;6onNext—&gt;7onNext—&gt;8onNext—&gt;9onCompleteonsubscribe endFlowable是支持背压的，也就是说，一般而言，上游的被观察者会响应下游观察者的数据请求，下游调用request(n)来告诉上游发送多少个数据。这样避免了大量数据堆积在调用链上，使内存一直处于较低水平。当然，Flowable也可以通过create()来创建： 123456789Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;@Overridepublic void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete();&#125;&#125;, BackpressureStrategy.BUFFER);//指定背压策略 以下是5种背压策略： Flowable虽然可以通过create()来创建，但是你必须指定背压的策略，以保证你创建的Flowable是支持背压的（这个在1.0的时候就很难保证，可以说RxJava2.0收紧了create()的权限）。根据上面的代码的结果输出中可以看到，当我们调用subscription.request(n)方法的时候，不等onSubscribe()中后面的代码执行，就会立刻执行onNext方法，因此，如果你在onNext方法中使用到需要初始化的类时，应当尽量在subscription.request(n)这个方法调用之前做好初始化的工作;当然，这也不是绝对的，我在测试的时候发现，通过create()自定义Flowable的时候，即使调用了subscription.request(n)方法，也会等onSubscribe()方法中后面的代码都执行完之后，才开始调用onNext。","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"RxJava","slug":"RxJava","permalink":"http://www.zydeveloper.com/tags/RxJava/"}]},{"title":"Android 插件化 Tinker","slug":"Tinker","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-16T06:40:15.482Z","comments":true,"path":"2019/07/30/Tinker/","link":"","permalink":"http://www.zydeveloper.com/2019/07/30/Tinker/","excerpt":"Tinker 官网 什么是 Tinker？Tinker 是一个开源项目(Github链接)，它是微信官方的 Android 热补丁解决方案，它支持动态下发代码、So 库以及资源，让应用能够在不需要重新安装的情况下实现更新。","text":"Tinker 官网 什么是 Tinker？Tinker 是一个开源项目(Github链接)，它是微信官方的 Android 热补丁解决方案，它支持动态下发代码、So 库以及资源，让应用能够在不需要重新安装的情况下实现更新。 为什么使用 Tinker？当前市面的热补丁方案有很多，其中比较出名的有阿里的 AndFix、美团的 Robust 以及 QZone 的超级补丁方案。但它们都存在无法解决的问题，这也是正是推出 Tinker 的原因。 Tinker热补丁方案不仅支持类、So 以及资源的替换，它还是2.X－7.X的全平台支持。利用Tinker我们不仅可以用做 bugfix,甚至可以替代功能的发布。Tinker 已运行在微信的数亿 Android 设备上，那么为什么你不使用 Tinker 呢？ 一步一步来集成Tinker添加gradle依赖 123456789101112131415buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.3.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // TinkerPatch 插件 classpath \"com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.2.13.3\" &#125;&#125; 集成 TinkerPatch SDKapp gradle中： 1234567dependencies &#123; ... // 若使用annotation需要单独引用,对于tinker的其他库都无需再引用 compileOnly(\"com.tinkerpatch.tinker:tinker-android-anno:1.9.13.3\") implementation(\"com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.2.13.3\")&#125; 注意,若使用 annotation 自动生成 Application， 需要单独引入 Tinker 的 tinker-android-anno 库。除此之外，我们无需再单独引入 tinker 的其他库。 为了简单方便，我们将 TinkerPatch 相关的配置都放于 tinkerpatch.gradle 中, 我们需要将其引入： 1apply from: 'tinkerpatch.gradle' tinkerpatch.gradle文件内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495apply plugin: 'tinkerpatch-support'/** * TODO: 请按自己的需求修改为适应自己工程的参数 */def bakPath = file(\"$&#123;buildDir&#125;/bakApk/\")def baseInfo = \"app-1.0.1-0814-08-39-19\"def variantName = \"release\"/** * 对于插件各参数的详细解析请参考 * http://tinkerpatch.com/Docs/SDK */tinkerpatchSupport &#123; /** 可以在debug的时候关闭 tinkerPatch **/ /** 当disable tinker的时候需要添加multiDexKeepProguard和proguardFiles, 这些配置文件本身由tinkerPatch的插件自动添加，当你disable后需要手动添加 你可以copy本示例中的proguardRules.pro和tinkerMultidexKeep.pro, 需要你手动修改'tinker.sample.android.app'本示例的包名为你自己的包名, com.xxx前缀的包名不用修改 **/ tinkerEnable = true reflectApplication = true /** * 是否开启加固模式，只能在APK将要进行加固时使用，否则会patch失败。 * 如果只在某个渠道使用了加固，可使用多flavors配置 **/ protectedApp = false /** * 实验功能 * 补丁是否支持新增 Activity (新增Activity的exported属性必须为false) **/ supportComponent = true autoBackupApkPath = \"$&#123;bakPath&#125;\" appKey = \"f938475486f91936\" /** 注意: 若发布新的全量包, appVersion一定要更新 **/ appVersion = \"1.0.1\" def pathPrefix = \"$&#123;bakPath&#125;\\\\$&#123;baseInfo&#125;\\\\$&#123;variantName&#125;\" def name = \"$&#123;project.name&#125;-$&#123;variantName&#125;\" baseApkFile = \"$&#123;pathPrefix&#125;\\\\$&#123;name&#125;.apk\" baseProguardMappingFile = \"$&#123;pathPrefix&#125;\\\\$&#123;name&#125;-mapping.txt\" baseResourceRFile = \"$&#123;pathPrefix&#125;\\\\$&#123;name&#125;-R.txt\" /** * 若有编译多flavors需求, 可以参照： https://github.com/TinkerPatch/tinkerpatch-flavors-sample * 注意: 除非你不同的flavor代码是不一样的,不然建议采用zip comment或者文件方式生成渠道信息（相关工具：walle 或者 packer-ng） **/&#125;/** * 用于用户在代码中判断tinkerPatch是否被使能 */android &#123; defaultConfig &#123; buildConfigField \"boolean\", \"TINKER_ENABLE\", \"$&#123;tinkerpatchSupport.tinkerEnable&#125;\" &#125;&#125;/** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */tinkerPatch &#123; ignoreWarning = false useSign = true dex &#123; dexMode = \"jar\" pattern = [\"classes*.dex\"] loader = [] &#125; lib &#123; pattern = [\"lib/*/*.so\"] &#125; res &#123; pattern = [\"res/*\", \"r/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"] ignoreChange = [] largeModSize = 100 &#125; packageConfig &#123; &#125; sevenZip &#123; zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\"// path = \"/usr/local/bin/7za\" &#125; buildConfig &#123; keepDexApply = false &#125;&#125; 具体含义： 初始化TinkerPatch SDK最后在我们的代码中，只需简单的初始化 TinkerPatch 的 SDK 即可，我们无需考虑 Tinker 是如何下载/合成/应用补丁包， 也无需引入各种各样 Tinker 的相关类。 reflectApplication = true 的情况若我们使用 reflectApplication 模式，我们无需为接入 Tinker 而改造我们的 Application 类。 1234567891011121314151617181920212223public class MyApplication extends Application &#123; private ApplicationLike tinkerApplicationLike; @Override public void onCreate() &#123; super.onCreate(); // 我们可以从这里获得Tinker加载过程的信息 tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK TinkerPatch.init(tinkerApplicationLike) .reflectPatchLibrary() //强制检查更新 .fetchPatchUpdate(true) .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时(通过setFetchPatchIntervalByHours设置)去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125;&#125; reflectApplication = false 的情况若我们已经完成了应用的 Application 改造，即将 Application 的逻辑移动到 ApplicationLike类中。 12345678910111213141516171819202122public class MyApplication extends DefaultApplicationLike &#123; private ApplicationLike tinkerApplicationLike; public MyApplication(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent); &#125; @Override public void onCreate() &#123; super.onCreate(); // 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化 SDK TinkerPatch.init(this) .reflectPatchLibrary() .setPatchRollbackOnScreenOff(true) .setPatchRestartOnSrceenOff(true) .setFetchPatchIntervalByHours(3); // 每隔3个小时（通过setFetchPatchIntervalByHours设置）去访问后台时候有更新,通过handler实现轮训的效果 TinkerPatch.with().fetchPatchUpdateAndPollWithInterval(); &#125;&#125; 注意：初始化的代码建议紧跟 super.onCreate(),并且所有进程都需要初始化，已达到所有进程都可以被 patch 的目的 如果你确定只想在主进程中初始化 tinkerPatch，那也请至少在 :patch 进程中初始化，否则会有造成 :patch 进程crash，无法使补丁生效 TinkerPatch 的使用步骤非常简单，一般来说可以参考以下几个步骤：根目录下执行： 1gradlew assemblerelease task 构建基准包（请在发布前确保更新tinkerpatchSupport中的appVersion），tinkerPatch会基于你填入的autoBackupApkPath自动备份基础包信息到相应的文件夹，包含：apk文件、R.txt文件和mapping.txt文件 （注：mapping.txt是proguard的产物，如果你没有开启proguard则不会有这个文件\u0002）若想发布补丁包， 只需将自动保存下来的文件分别填到tinkerpatchSupport中的baseApkFile、baseProguardMappingFile和baseResourceRFile 参数中： 运行: 1gradlew tinkerPatchRelease task 构建补丁包，补丁包将位于 build/outputs/tinkerPatch下。 patch_signed_7zip.apk就是我们的补丁包了。 在Tinker后台下发补丁包： 测试使用“开发预览”方式下发，不会对线上版本直接更新。我们用一个简单的界面为例： 修改部分代码： 1tvTest.setText(\"123456\"); 使用上面方式制作出补丁包，然后发布到Tinker后台。更新后如下： 更多功能请参见 —— Tinker 官方文档 可能遇到的问题？问题1： 解决方法： 1234567891011121314defaultConfig &#123; applicationId \"com.baweigame.umengdemoapplication\" minSdkVersion 15 targetSdkVersion 28 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath = true &#125; &#125; &#125; 问题2：release版本签名问题,即默认打包后的release版本是个未签名的apk版本，导致制作补丁包时报错。 解决办法： 提前准备好jks文件","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"},{"name":"Tinker","slug":"Tinker","permalink":"http://www.zydeveloper.com/tags/Tinker/"}]},{"title":"Android插件化——动态资源加载","slug":"ResourceDynamicLoad","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-30T12:52:00.030Z","comments":true,"path":"2019/07/24/ResourceDynamicLoad/","link":"","permalink":"http://www.zydeveloper.com/2019/07/24/ResourceDynamicLoad/","excerpt":"之前我们聊了一下Android插件化中的热修复，参考：（Android 热修复），现在我们聊聊资源的动态加载。","text":"之前我们聊了一下Android插件化中的热修复，参考：（Android 热修复），现在我们聊聊资源的动态加载。 顾名思义我们之前的热更新只是解决了代码的加载，对于外部资源我们还不能直接使用。我们工程的资源最终打包后都会放到R.java文件中，然后我们可以获取Resources然后通过类似resources.getDrawable(id);方式通过id来获取我们具体的资源。但对于外部资源也就是不在我们工程中没有被放到R.java文件中的资源我们如果使用呢？ 1Drawable drawable = resources.getDrawable(resId); 上面这种方式是我们平时获取资源的使用方式。 我们使用Resources的getXXX 通过resId来获取资源。那我们考虑考虑是否可以获取插件的Resources呢？如果可以我们是不是就可以实现资源的动态加载了呢？答案是可以的！ 我们先来看看Activity是如何获取Resources的：我们直接定位到代码，ContextThemeWrapper继承关系，如 ContextThemeWrapper &gt; ContextWrapper &gt; Context 12345678910111213141516@Overridepublic Resources getResources() &#123; return getResourcesInternal();&#125;private Resources getResourcesInternal() &#123; if (mResources == null) &#123; if (mOverrideConfiguration == null) &#123; mResources = super.getResources(); &#125; else &#123; final Context resContext = createConfigurationContext(mOverrideConfiguration); mResources = resContext.getResources(); &#125; &#125; return mResources;&#125; 我们发现获取Resources的方法，再来看看Resources.java的构造函数 123456789101112131415161718/*** Create a new Resources object on top of an existing set of assets in an* AssetManager.** @deprecated Resources should not be constructed by apps.* See &#123;@link android.content.Context#createConfigurationContext(Configuration)&#125;.** @param assets Previously created AssetManager.* @param metrics Current display metrics to consider when* selecting/computing resource values.* @param config Desired device configuration to consider when* selecting/computing resource values (optional).*/@Deprecatedpublic Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) &#123;this(null);mResourcesImpl = new ResourcesImpl(assets, metrics, config, new DisplayAdjustments());&#125; 我们发现Resources是由AssetManager创建处理的。再来分析一下AssetManger 12345678910111213141516171819/** * Provides access to an application's raw asset files; see &#123;@link Resources&#125; * for the way most applications will want to retrieve their resource data. * This class presents a lower-level API that allows you to open and read raw * files that have been bundled with the application as a simple stream of * bytes. */public final class AssetManager implements AutoCloseable &#123; ... /** * @deprecated Use &#123;@link #setApkAssets(ApkAssets[], boolean)&#125; * @hide */ @Deprecated public int addAssetPath(String path) &#123; return addAssetPathInternal(path, false /*overlay*/, false /*appAsLib*/); &#125; ...&#125; 我们发现一个addAssetPath的方法，实际这个方法可以使我们传入的apk path为我们构建出AssetManager 然后通过AssetManager创建出Resources。如上是我们实现动态加载资源的初步思路。下面实践一下是否可行？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.baweigame.plugindemoapplication;import android.app.Application;import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.res.AssetManager;import android.content.res.Resources;import android.os.Environment;import android.util.Log;import java.io.File;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class MyApplication extends Application &#123; private AssetManager assetManager; private Resources newResource; private Resources.Theme mTheme; private PackageInfo packageInfo; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); //创建我们自己的Resource String apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/app-debug.apk\"; packageInfo = getPackageInfo(apkPath); if (new File(apkPath).exists())&#123; loadOtherResource(apkPath); &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; public void loadOtherResource(String apkPath)&#123; //创建AssetManager try &#123; assetManager = AssetManager.class.newInstance(); Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class); addAssetPathMethod.setAccessible(true); addAssetPathMethod.invoke(assetManager, apkPath); //初始化AssetManager内部参数 Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(\"ensureStringBlocks\"); ensureStringBlocks.setAccessible(true); ensureStringBlocks.invoke(assetManager); Resources supResource = getResources(); Log.e(\"Main\", \"supResource = \" + supResource); newResource = new Resources(assetManager, supResource.getDisplayMetrics(), supResource.getConfiguration()); mTheme = newResource.newTheme(); mTheme.setTo(super.getTheme()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; @Override public AssetManager getAssets() &#123; return assetManager==null?super.getAssets():assetManager; &#125; @Override public Resources getResources() &#123; return newResource==null?super.getResources():newResource; &#125; @Override public Resources.Theme getTheme() &#123; return mTheme == null ? super.getTheme() : mTheme; &#125; /** * 获取apk包信息 * @param resourcePath apk路径 * @return */ private PackageInfo getPackageInfo(String resourcePath)&#123; PackageInfo packageInfo=getPackageManager().getPackageArchiveInfo(resourcePath, PackageManager.GET_ACTIVITIES); return packageInfo; &#125; /** * 获取插件包名 * @return */ public String getPluginPackageName()&#123; return packageInfo.packageName; &#125;&#125; 上面代码中，我们发现获取了内置存储中的app-debug.apk文件，因为是demo所以直接写死了。下面我们来看看loadOtherResource这个方法都做了什么？我们发现它主要利用反射来获取assetManagernewResourcemTheme3个主要对象，并将我们的apk通过“addAssetPath”添加到了manager中。 然后重写了Application的3个方法getAssets、getResources、getTheme，用于替换成我们资源apk的资源。 然后我们看看MainActivity中做了什么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.baweigame.plugindemoapplication;import android.app.Activity;import android.content.res.AssetManager;import android.content.res.Resources;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyApplication application= (MyApplication) getApplication(); int aa=application.getResources().getIdentifier(\"activity_demo\",\"layout\",application.getPluginPackageName()); try&#123; setContentView(aa); &#125; catch (Exception e)&#123; Log.e(\"123\", \"onCreate: \"); &#125; &#125; @Override public AssetManager getAssets() &#123; if(getApplication() != null &amp;&amp; getApplication().getAssets() != null)&#123; return getApplication().getAssets(); &#125; return super.getAssets(); &#125; @Override public Resources.Theme getTheme() &#123; if(getApplication() != null &amp;&amp; getApplication().getTheme() != null)&#123; return getApplication().getTheme(); &#125; return super.getTheme(); &#125; @Override public Resources getResources() &#123; if(getApplication() != null &amp;&amp; getApplication().getTheme() != null)&#123; return getApplication().getResources(); &#125; return super.getResources(); &#125;&#125; 我们发现实现了从资源apk中获取activity_demo布局文件然后设置给MainActivity。注意我们要使用其他apk资源必须重写Activity中的getAssets、getTheme、getResources。 1application.getResources().getIdentifier(\"activity_demo\",\"layout\",application.getPluginPackageName()); 这个方法用于获取指定资源，目前获取的是layout类型的activity_demo布局文件资源。下面是我们加载的资源项目截图： 如上就是我们动态加载资源的简单实现。","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"},{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"}]},{"title":"Dagger2使用","slug":"Dagger2","date":"2019-07-21T16:00:00.000Z","updated":"2019-07-26T02:07:25.019Z","comments":true,"path":"2019/07/22/Dagger2/","link":"","permalink":"http://www.zydeveloper.com/2019/07/22/Dagger2/","excerpt":"Dagger官网地址 Dagger是一个完全静态的、编译时依赖 注入框架 ，适用于Java和Android。它是Square创建的早期版本的一个改编版本，现在由谷歌维护。","text":"Dagger官网地址 Dagger是一个完全静态的、编译时依赖 注入框架 ，适用于Java和Android。它是Square创建的早期版本的一个改编版本，现在由谷歌维护。 说说什么是依赖注入？依赖注入对于刚接触到这个概念的同学可能不太清楚什么意思，说起来也比较简单甚至我们每天都在编写这样的代码。 123456public class A&#123; private B b; public A(B _b)&#123; this.b = _b; &#125;&#125; 上面的代码是不是很常见，我们发现业务类A依赖了业务类B。这就是一个典型的依赖注入。那我们来想想如果A被很多的其他业务类依赖如果A做了修改是不是要修改很多的地方呢？这样我们的Dagger就应该登场了，Dagger就为了解决此类问题而生的。 简单使用：导依赖build.gradle中导入依赖如： 123456dependencies &#123; implementation 'com.google.dagger:dagger-android:2.17' annotationProcessor\"com.google.dagger:dagger-compiler:2.17\" implementation 'com.google.dagger:dagger-android-support:2.17' // if you use the support libraries annotationProcessor 'com.google.dagger:dagger-android-processor:2.17'&#125; 业务类ClassA1234567891011121314package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ClassA &#123; @Inject public ClassA()&#123; &#125; public int Add(int a,int b)&#123; return a+b; &#125;&#125; 业务类ClassB1234567891011121314151617package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ClassB &#123; @Inject public ClassB()&#123; &#125; @Inject ClassA classA; public int Add(int a,int b)&#123; return classA.Add(a,b); &#125;&#125; MainActivityComponent12345678910package com.baweigame.daggerdemoapplication;import android.app.Activity;import dagger.Component;@Componentpublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.baweigame.daggerdemoapplication;import android.app.Activity;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.Toast;import javax.inject.Inject;import dagger.Component;public class MainActivity extends AppCompatActivity &#123; private TextView tvTest; @Inject ClassB classB; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); DaggerMainActivityComponent.create().inject(this); &#125; private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+classB.Add(2,3), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void initView() &#123; tvTest = (TextView) findViewById(R.id.tv_test); &#125;&#125; 我们看上面的例子，比较简单，首先业务类B依赖了业务类A，MainActivity依赖了业务类B，我们发现用Dagger实现起来是不是很清爽。如果我们不用Dagger我的代码大概应该是下面的样子： 1234567--一段伪代码ClassA classA=new ClassA();ClassB classB=new ClassB();classB.set(classA);classB.Add(2,3); 使用Dagger2 1234@InjectClassB classB;classB.Add(2,3); 感觉是不是很简洁。上面的例子中出现了一些新的“东西”，我们发现大多出现的是注解。 下面是Dagger的常用注解。 Componet 注解 1234567@Retention(value=RUNTIME)@Target(value=TYPE)@Documentedpublic @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Component.html 注释接口或抽象类，为其从一组模块生成注入依赖关系的实现。生成的类的类型名称将带有@Component注释，前缀为Dagger。例如，@Component interface MyComponent{…}将生成一个名为DaggerMyComponent的实现。 Subcomponent 注解 123456@Retention(value=RUNTIME)@Target(value=TYPE)@Documentedpublic @interface Subcomponent &#123; Class&lt;?&gt;[] modules() default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Subcomponent.html 从父组件或子组件继承绑定的子组件。 Module 注解 1234567@Documented@Retention(value=RUNTIME)@Target(value=TYPE)public @interface Module&#123; Class&lt;?&gt;[] includes() default &#123;&#125;; Class&lt;?&gt;[] subcomponents default &#123;&#125;;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Module.html Provides 注解 1234@Documented@Target(value=METHOD)@Retention(value=RUNTIME)public @interface Provides&#123;&#125; 参考链接：https://dagger.dev/api/latest/dagger/Provides.html 注释模块的方法，以创建提供程序方法绑定。方法的返回类型绑定到其返回值。组件实现将依赖项作为参数传递给方法。 MapKey 注解 123456@Documented@Target(value=ANNOTATION_TYPE)@Retention(value=RUNTIME)public @interface MapKey&#123; boolean unwrapValue() default true;&#125; 参考链接：https://dagger.dev/api/latest/dagger/MapKey.html 标识用于将Key与方法返回的值关联以组成映射的注释类型。每个使用@ provide和@IntoMap注释的提供程序方法都必须有一个注释来标识映射条目的键。该注释的类型必须使用@MapKey进行注释。通常，键注释只有一个成员，其值用作映射键。 Dagger 2中用到的定义在 JSR-330的其他注解 12345678public @interface Inject &#123;&#125; public @interface Scope &#123;&#125; public @interface Qualifier &#123;&#125; 上面的例子中我们接触到了@Inject和@Component两个注解，下面来说说这两个注解是做什么用的？如果想使用Dagger来实现依赖注入就至少要使用这两个注解：@Inject用于标记需要注入的依赖，或者标记用于提供依赖的方法。依赖注入中最重要的注解，JSR-330标准中的一部分在javax.inject包中。 Dagger 2中有3种方式提供依赖： 1、构造函数注入，如我们上面例子中的 123456ClassA:@Injectpublic ClassA()&#123;&#125; 注：如果存在多个构造函数，我们只能标注一个，不能同时标注多个。 2、属性注入注：被标注的属性不能使用private修饰。 12@InjectClassB b; 3、方法注入 1234@Injectpublic void setClassB(ClassB _b) &#123; this.b = _b;&#125; 方法注入与属性注入基本上没区别，Dagger2会在构造执行完立即调用这个方法，也就是说如果我们需要使用this的时候，使用方法注入是安全的。 @Component用来完成注入，在上面的例子中目标MainActivity就是使用Component完成注入。@Component是Dagger2中最重要的一个注解，Dagger2是使用它来完成依赖注入的。 1234@Componentpublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; 上面是我们上面例子中的接口，使用Component的使用方式，命名一般用 类名+Component 方式，我们rebuild工程后，Dagger2会生成一个Dagger+XXX（如：DaggerMainActivityComponent）的类。 Component中一般使用两种方式定义方法。 void inject(目标类 obj);Dagger2会从目标类开始查找@Inject注解，自动生成依赖注入的代码，调用inject可完成依赖的注入。 Object getObj(); 如：ClassB getClassB();Dagger2会到ClassB类中找被@Inject注解标注的构造器，自动生成提供ClassB依赖的代码，这种方式一般为其他Component提供依赖。 Dagger2以@Component中定义的方法作为起点，到目标类中寻找@Inject标注，生成一系列提供依赖的Factory类和注入依赖的Injector类。而Component则是联系Factory和Injector，最终完成依赖的注入。 我们来看看Dagger2生成的类，我们发现ClassA_Factory ClassB_Factory 这两个类分别对应我们的ClassA ClassB构造函数上的@Inject注解。 Factory类 12345678910111213/** * An &#123;@linkplain Scope unscoped&#125; &#123;@link Provider&#125;. While a &#123;@link Provider&#125; &lt;i&gt;may&lt;/i&gt; apply * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise * the binding logic (&#123;@link Inject&#125; constructors, &#123;@link Provides&#125; methods) upon each call to * &#123;@link #get&#125;. * * &lt;p&gt;Note that while subsequent calls to &#123;@link #get&#125; will create new instances for bindings such * as those created by &#123;@link Inject&#125; constructors, a new instance is not guaranteed by all * bindings. For example, &#123;@link Provides&#125; methods may be implemented in ways that return the same * instance for each call. */public interface Factory&lt;T&gt; extends Provider&lt;T&gt; &#123;&#125; 我们看ClassA_Factory这个工厂类： 12345678910111213141516171819202122232425// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;public final class ClassA_Factory implements Factory&lt;ClassA&gt; &#123; private static final ClassA_Factory INSTANCE = new ClassA_Factory(); @Override public ClassA get() &#123; return provideInstance(); &#125; public static ClassA provideInstance() &#123; return new ClassA(); &#125; public static ClassA_Factory create() &#123; return INSTANCE; &#125; public static ClassA newClassA() &#123; return new ClassA(); &#125;&#125; 这个工厂类使用单例模式给我们提供了实例化ClassA的方法。再看看ClassB_Factory：ClassB依赖了ClassA，所有将ClassA Provider直接传入。 1234567891011121314151617181920212223242526272829303132// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;import javax.inject.Provider;public final class ClassB_Factory implements Factory&lt;ClassB&gt; &#123; private final Provider&lt;ClassA&gt; classAProvider; public ClassB_Factory(Provider&lt;ClassA&gt; classAProvider) &#123; this.classAProvider = classAProvider; &#125; @Override public ClassB get() &#123; return provideInstance(classAProvider); &#125; public static ClassB provideInstance(Provider&lt;ClassA&gt; classAProvider) &#123; ClassB instance = new ClassB(); ClassB_MembersInjector.injectClassA(instance, classAProvider.get()); return instance; &#125; public static ClassB_Factory create(Provider&lt;ClassA&gt; classAProvider) &#123; return new ClassB_Factory(classAProvider); &#125; public static ClassB newClassB() &#123; return new ClassB(); &#125;&#125; MainActivity上的@Inject直接对应MainActivity_MembersInjector,依赖了ClassB，所以ClassB Provider作为参数不直接传递。实现了MembersInjector接口 123456789101112131415161718192021222324252627282930313233343536373839404142/* * Copyright (C) 2012 The Dagger Authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package dagger;/** * Injects dependencies into the fields and methods on instances of type &#123;@code T&#125;. Ignores the * presence or absence of an injectable constructor. * * @param &lt;T&gt; type to inject members of * * @since 2.0 (since 1.0 without the provision that &#123;@link #injectMembers&#125; cannot accept * &#123;@code null&#125;) */public interface MembersInjector&lt;T&gt; &#123; /** * Injects dependencies into the fields and methods of &#123;@code instance&#125;. Ignores the presence or * absence of an injectable constructor. * * &lt;p&gt;Whenever a &#123;@link Component&#125; creates an instance, it performs this injection automatically * (after first performing constructor injection), so if you're able to let the component create * all your objects for you, you'll never need to use this method. * * @param instance into which members are to be injected * @throws NullPointerException if &#123;@code instance&#125; is &#123;@code null&#125; */ void injectMembers(T instance);&#125; 1234567891011121314151617181920212223242526// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.MembersInjector;import javax.inject.Provider;public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123; private final Provider&lt;ClassB&gt; classBProvider; public MainActivity_MembersInjector(Provider&lt;ClassB&gt; classBProvider) &#123; this.classBProvider = classBProvider; &#125; public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;ClassB&gt; classBProvider) &#123; return new MainActivity_MembersInjector(classBProvider); &#125; @Override public void injectMembers(MainActivity instance) &#123; injectClassB(instance, classBProvider.get()); &#125; public static void injectClassB(MainActivity instance, ClassB classB) &#123; instance.classB = classB; &#125;&#125; 最后来看看我们的@Component -&gt; DaggerMainActivityComponent 它将Factory和MainActivity两个类联系到一起。 1234567891011121314151617181920212223242526272829303132333435363738394041// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;public final class DaggerMainActivityComponent implements MainActivityComponent &#123; private DaggerMainActivityComponent(Builder builder) &#123;&#125; public static Builder builder() &#123; return new Builder(); &#125; public static MainActivityComponent create() &#123; return new Builder().build(); &#125; private ClassB getClassB() &#123; return injectClassB(ClassB_Factory.newClassB()); &#125; @Override public void inject(MainActivity activity) &#123; injectMainActivity(activity); &#125; private ClassB injectClassB(ClassB instance) &#123; ClassB_MembersInjector.injectClassA(instance, new ClassA()); return instance; &#125; private MainActivity injectMainActivity(MainActivity instance) &#123; MainActivity_MembersInjector.injectClassB(instance, getClassB()); return instance; &#125; public static final class Builder &#123; private Builder() &#123;&#125; public MainActivityComponent build() &#123; return new DaggerMainActivityComponent(this); &#125; &#125;&#125; @Module和@Provides这两个注解主要弥补@Inject的不足，因为在一些场景下无法使用@Inject，比如：第三方库或者抽象类中。 123456789101112package com.baweigame.daggerdemoapplication;/** * 人类 */public abstract class Person &#123; /** * 说话 * @return */ public abstract String speak();&#125; 12345678910111213package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class ChinaPerson extends Person &#123; @Inject ChinaPerson()&#123;&#125; @Override public String speak() &#123; return \"中国人说话\"; &#125;&#125; 12345678910111213package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class AmericaPerson extends Person &#123; @Inject AmericaPerson()&#123;&#125; @Override public String speak() &#123; return \"美国人说话\"; &#125;&#125; 123456789101112131415package com.baweigame.daggerdemoapplication;import javax.inject.Inject;public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 我们在MainActivity中加入如下代码： 123456789@InjectPersonManager person; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; person.speak(); &#125; &#125;); 重新build运行我们的工程，我们发现出现了错误。因为Person是个抽象类无法实例化。怎么解决类似这样的问题呢？ 我们可以使用@Module @Provides这两个注解来解决，注意这两个注解是成对出现使用的，@Module修饰在 类 上，@Provides修饰在 方法 上。我们把刚才的例子重新修改一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 人类 */public abstract class Person &#123; /** * 说话 * @return */ public abstract String speak();&#125;public class ChinaPerson extends Person &#123; @Override public String speak() &#123; return \"中国人说话\"; &#125;&#125;public class AmericaPerson extends Person &#123; @Override public String speak() &#123; return \"美国人说话\"; &#125;&#125;public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125;@Modulepublic class PersonModule &#123; @Provides Person getChinaPerson()&#123; return new ChinaPerson(); &#125;&#125;@Component(modules=PersonModule.class)public interface MainActivityComponent&#123; void inject(MainActivity activity);&#125;MainActivity中@InjectPersonManager personManager;private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 我们发现原来的两个实现类去掉了构造函数的@Inject，而且加入了PersonModule类，并在MainActivityComponent类的@Component注解中指定了我们的Module &gt;&gt;&gt;&gt; modules=PersonModule.class。我们来看看这个Module是干什么用的 12345678910111213141516171819202122232425262728293031// Generated by Dagger (https://google.github.io/dagger).package com.baweigame.daggerdemoapplication;import dagger.internal.Factory;import dagger.internal.Preconditions;public final class PersonModule_GetChinaPersonFactory implements Factory&lt;Person&gt; &#123; private final PersonModule module; public PersonModule_GetChinaPersonFactory(PersonModule module) &#123; this.module = module; &#125; @Override public Person get() &#123; return provideInstance(module); &#125; public static Person provideInstance(PersonModule module) &#123; return proxyGetChinaPerson(module); &#125; public static PersonModule_GetChinaPersonFactory create(PersonModule module) &#123; return new PersonModule_GetChinaPersonFactory(module); &#125; public static Person proxyGetChinaPerson(PersonModule instance) &#123; return Preconditions.checkNotNull( instance.getChinaPerson(), \"Cannot return null from a non-@Nullable @Provides method\"); &#125;&#125; 我们发现这个Module也是一个Factory类。 Module是告诉Component，可以从这里寻找依赖对象。Component就会去找@Provide标注的方法，相当于构造器的@Inject，来提供依赖。 注： @Component可以指定多个@Module Component也可以依赖其它Component @Qualifier和@Named@Qualifier是限定符，而@Named则是基于String的限定符。如上面的例子 12345678910111213@Modulepublic class PersonModule &#123; @Provides Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125; Module中有多个实现之类，这时我们可以通过限定符对其区分 123456789101112131415@Modulepublic class PersonModule &#123; @Provides @Named(\"china\") Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @Named(\"america\") Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125; 在依赖时，如： 1234567891011public class PersonManager &#123; Person person; @Inject public PersonManager(@Named(\"america\") Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 最终我们使用的是“AmericaPerson”实例。@Qualifier注解与@Named注解作用完全一样，但我们发现@Named注解有个弊端就是我们要手写字符串名称，这样很容易出错。@Qualifier注解可以解决这个问题，但该注解是修饰在注解上的，所以我们要这样使用，如： 1234567891011121314151617181920212223242526272829303132333435@Modulepublic class PersonModule &#123; @Provides @ChinaPersonAnn Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @AmericaPersonAnn Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125;@Qualifier@Retention(RetentionPolicy.RUNTIME)@interface ChinaPersonAnn &#123;&#125;@Qualifier@Retention(RetentionPolicy.RUNTIME)@interface AmericaPersonAnn &#123;&#125;public class PersonManager &#123; Person person; @Inject public PersonManager(@ChinaPersonAnn Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; @Component的dependence和@SubComponent上面我们说过Component可以依赖Component还是上面的例子我们新建PersonComponent 12345678@Component(modules = PersonModule.class)public interface PersonComponent &#123; @ChinaPersonAnn Person getChinaPerson(); @AmericaPersonAnn Person getAmericaPerson();&#125; 把我们的PersonManager修改一下去掉注解如: 1234567891011public class PersonManager &#123; Person person; @Inject public PersonManager(Person _person)&#123; this.person=_person; &#125; public String speak()&#123; return person.speak(); &#125;&#125; 新建PersonManagerModule 1234567@Modulepublic class PersonManagerModule &#123; @Provides PersonManager providePersonManager(@ChinaPersonAnn Person _persion)&#123; return new PersonManager(_persion); &#125;&#125; 新建PersonManagerComponent 1234@Component(modules = PersonManagerModule.class,dependencies = PersonComponent.class)public interface PersonManagerComponent &#123; PersonManager getManager();&#125; MainActivityComponent修改为： 1234@Component(dependencies=PersonManagerComponent.class)public interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; MainActivity修改为： 123456789101112131415161718192021DaggerMainActivityComponent.builder() .personManagerComponent( DaggerPersonManagerComponent.builder() .personComponent( DaggerPersonComponent.create() ).build() ).build() .inject(this);@InjectPersonManager personManager;private void initListener() &#123; tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 这就是Component的dependencies的用法，Component依赖了其他Component。如果换成Subcomponent，可以把它理解为继承的关系，则修改Component部分就可以： 1234567891011121314151617181920212223242526272829@Component(modules = PersonModule.class)public interface PersonComponent2 &#123; PersonManagerComponent2 personManagerComponent();&#125;@Subcomponent(modules = PersonManagerModule.class)public interface PersonManagerComponent2 &#123; MainActivityComponent2 mainActivityComponent();&#125;@Subcomponentpublic interface MainActivityComponent2 &#123; void Inject(MainActivity activity);&#125;MainActivity修改为：@InjectPersonManager personManager;DaggerPersonComponent2.create().personManagerComponent().mainActivityComponent().Inject(this);tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 上面代码开起来有些不合常理，PersonComponent2管理了PersonManagerComponent2和MainActivityComponent2。Dagger2生成的代码中，Subcomponent标记的类是Componpent的内部类。即MainActivityComponent2是PersonManagerComponent2的内部类，PersonManagerComponent2又是MainActivityComponent2的内部类。 比较适合使用Subcomponent的几个场景：很多工具类都需要使用到Application的Context对象，此时就可以用一个Component负责提供，我们可以命名为AppComponent。需要用到的context对象的SharePreferenceComponent，ToastComponent就可以它作为Subcomponent存在了。 而且在AppComponent中，我们可以很清晰的看到有哪些子Component，因为在里面我们定义了很多XxxComponent (Module… modules) 每个ActivityComponent也是可以作为AppComponent的Subcomponent，这样可以更方便的进行依赖注入，减少重复代码。 @Scope和@SingletonOne reason to break your application’s component up into Subcomponents is to use scopes. With normal, unscoped bindings, each user of an injected type may get a new, separate instance. But if the binding is scoped, then all users of that binding within the scope’s lifetime get the same instance of the bound type. 上面是google给的解释。简单理解为在不使用@Scope的情况下，可能每次注入的对象都会是一个新的不同的对象，而@Scope能限制被注入的对象，在同一个@Scope的生命周期(lifetime)中都只存在一个且仅有一个对象，是不是很像单例。 @Scope是标志一个注入器/对象的使用范围也可以说是用来管理依赖的生命周期（也可以理解为作用域）的。它也是用来修饰注解的，而@Singleton则是@Scope的实现。 123456789/** * Identifies a type that the injector only instantiates once. Not inherited. * * @see javax.inject.Scope @Scope */@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 顾名思义@Scope用来管理生命周期，所以我们的命名要尽量规范详细，如：ActivityScopeFragmentScopeApplicationScope。。。 @Scope所描述的注解用于两个地方： @Component类@Module中@Provides方法 如下内容引用：》》》Dagger2 知识梳理(4) - @Scope 注解的使用 如有侵权请告知！！！ 在单个Component情况下来使用Scope 1234567891011121314151617181920212223242526272829@Documented@Retention(RUNTIME)@Scopepublic @interface TestScope &#123;&#125;PersonModule 中@Provides@Named(\"China\")@TestScopePerson getChinaPerson()&#123; return new ChinaPerson();&#125;@Provides@Named(\"America\")Person getAmericaPerson()&#123; return new AmericaPerson();&#125;MainActivityComponent 中@Component(modules=PersonModule.class)@TestScopepublic interface MainActivityComponent&#123; void inject(MainActivity activity);&#125; 如果在Module的@Provides方法上加上了@Scope声明，那么在与他关联的Component上也必须加上相同的@Scope声明在Component实例的生命周期内，只会创建一个由@Provides方法返回的实例，可以理解为局部单例。 在多个Component情况下来使用Scope 在依赖或者继承的组织方式中，如果其中一个Component声明了@Scope，那么其它的Component也需要声明。在依赖关系中，被依赖的Component和需要依赖的Component的@Scope不能相同 在依赖关系中，需要依赖的Component的@Scope不可以为@Singleton。 在组织关系中，子Component的@Scope不可以和父Component的@Scope相同： 在组织关系中，如果父Component的@Scope不为@Singleton，那么子Component的@Scope可以为@Singleton。 这些限制是由Dagger2在编译时去检查的，其目的是保证使用者不要对@Scope产生滥用的现象，因为@Scope的目的是 在特定作用域内控制被注入实例的复用 示例：(1) ScopeApp对应于我们平时的Application类，并提供了全局的ScopeAppData类，在其ScopeAppComponent上有@Singleton注解。 123456789101112131415@Singleton@Component(modules = &#123;ScopeAppModule.class&#125;)public interface ScopeAppComponent &#123; public ScopeAppData getScopeAppData(); //如果它被其它的Component依赖，那么需要声明getXXX方法。&#125;@Modulepublic class ScopeAppModule &#123; @Provides @Singleton public ScopeAppData provideScopeAppData() &#123; return new ScopeAppData(); &#125;&#125; (2) ScopeActivity对应于一个主页面，其内部包含了ScopeActivitySharedData和ScopeActivityNormalData，前者在ScopeActivityComponent的生命周期内保持唯一性，并带有PerScopeActivity注解。 123456789101112131415161718192021@Component(dependencies = &#123;ScopeAppComponent.class&#125;, modules = &#123;ScopeActivityModule.class&#125;)@PerScopeActivitypublic interface ScopeActivityComponent &#123; public void inject(ScopeActivity scopeActivity); ScopeFragmentComponent scopeFragmentComponent();&#125;@Modulepublic class ScopeActivityModule &#123; @Provides @PerScopeActivity public ScopeActivitySharedData provideScopeActivityData() &#123; return new ScopeActivitySharedData(); &#125; @Provides public ScopeActivityNormalData provideScopeActivityNormalData() &#123; return new ScopeActivityNormalData(); &#125;&#125; (3) ScopeFragment对于于Activity下的一个子界面，它和ScopeActivityComponent是继承关系，并带有@PerScopeFragment注解： 123456789101112131415@Subcomponent(modules = &#123;ScopeFragmentModule.class&#125;)@PerScopeFragmentpublic interface ScopeFragmentComponent &#123; public void inject(ScopeFragment scopeFragment);&#125;@Modulepublic class ScopeFragmentModule &#123; @Provides @PerScopeFragment public ScopeFragmentData provideScopeFragmentData() &#123; return new ScopeFragmentData(); &#125;&#125; 以上三个部分的关系为： ScopeActivityComponent依赖于ScopeAppComponent ScopeFragmentComponent继承于ScopeActivityComponent 它们的Module上都有用@Scope描述的注解：@Singleton、@PerScopeActivity，@PerScopeFragment。 验证一下： App 1234567891011121314public class ScopeApp extends Application &#123; private ScopeAppComponent mScopeAppComponent; @Override public void onCreate() &#123; super.onCreate(); mScopeAppComponent = DaggerScopeAppComponent.builder().scopeAppModule(new ScopeAppModule()).build(); &#125; public ScopeAppComponent getAppComponent() &#123; return mScopeAppComponent; &#125;&#125; Activity类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ScopeActivity extends AppCompatActivity &#123; private static final String TAG = ScopeActivity.class.getSimpleName(); private ScopeActivityComponent mScopeActivityComponent; @Inject ScopeAppData mScopeAppData; @Inject ScopeActivitySharedData mScopeActivitySharedData1; @Inject ScopeActivitySharedData mScopeActivitySharedData2; @Inject ScopeActivityNormalData mScopeActivityNormalData1; @Inject ScopeActivityNormalData mScopeActivityNormalData2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scope); getScopeActivityComponent().inject(this); TextView tvData = (TextView) findViewById(R.id.tv_scope_activity); String result = \"[ScopeActivity Space] \\n mScopeAppData=\" + mScopeAppData + \"\\n\\n\" + \"mScopeActivitySharedData1=\" + mScopeActivitySharedData1 + \"\\n\\n\" + \"mScopeActivitySharedData2=\" + mScopeActivitySharedData2 + \"\\n\\n\" + \"mScopeActivityNormalData1=\" + mScopeActivityNormalData1 + \"\\n\\n\" + \"mScopeActivityNormalData2=\" + mScopeActivityNormalData2; tvData.setText(result); &#125; public ScopeActivityComponent getScopeActivityComponent() &#123; if (mScopeActivityComponent == null) &#123; ScopeAppComponent scopeAppComponent = ((ScopeApp) getApplication()).getAppComponent(); mScopeActivityComponent = DaggerScopeActivityComponent.builder().scopeAppComponent(scopeAppComponent).build(); &#125; return mScopeActivityComponent; &#125;&#125; Fragment类 1234567891011121314151617181920212223242526272829303132333435363738394041public class ScopeFragment extends Fragment &#123; private ScopeActivity mScopeActivity; @Inject ScopeAppData mScopeAppData; @Inject ScopeActivitySharedData mScopeActivitySharedData; @Inject ScopeActivityNormalData ScopeActivityNormalData; @Inject ScopeFragmentData mScopeFragmentData; @Override public void onAttach(Context context) &#123; super.onAttach(context); mScopeActivity = (ScopeActivity) context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_scope, container, false); mScopeActivity.getScopeActivityComponent().scopeFragmentComponent().inject(this); TextView tv = (TextView) rootView.findViewById(R.id.tv_scope_fragment); String result = \"[ScopeFragment Space] \\n mScopeAppData=\" + mScopeAppData + \"\\n\\n\" + \"mScopeActivitySharedData1=\" + mScopeActivitySharedData + \"\\n\\n\" + \"ScopeActivityNormalData=\" + ScopeActivityNormalData + \"\\n\\n\" + \"mScopeFragmentData=\" + mScopeFragmentData; tv.setText(result); return rootView; &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 由上面例子中的现象，可以总结出以下几点： ScopeAppData：该数据是由ScopeAppModule提供的，而它加上了@Singleton注解，并且我们调用的是同一个对象，因此在Activity和Fragment中地址相同。 ScopeActivitySharedData：在它的provide方法上，我们加上了@PerScopeActivity注解，因此在Activity和Fragment中，它的地址相同。 ScopeActivityNormalData：虽然在提供它的ScopeActivityModule中加上了@PerScopeActivity注解，但是在provide方法上没有声明，因此无论是在Activity，还是在Fragment中，都是指向不同的地址。 ScopeFragmentData：用于演示如何通过继承的方式，来实现依赖注入。 Set注入 Map注入 @MapKeySet注入之前的注入都是单个对象，Set注入即可以将多个对象注入到Set中。我们使用PersonModule加入@IntoSet加入到Set中。 123456789101112131415161718192021222324252627282930@Modulepublic class PersonModule &#123; @Provides @IntoSet Person getChinaPerson()&#123; return new ChinaPerson(); &#125; @Provides @IntoSet Person getAmericaPerson()&#123; return new AmericaPerson(); &#125;&#125;MainActivity 中：@InjectSet&lt;Person&gt; personSet;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (Person person: personSet) &#123; Toast.makeText(MainActivity.this, \"\"+person.speak(), Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); 我们也可以使用如下方式同时向Set注入多个对象：PersonModule.java 12345678@Provides@ElementsIntoSetpublic Set&lt;Person&gt; getPlayers()&#123; HashSet set = new HashSet&lt;&gt;(); set.add(new ChinaPerson()); set.add(new AmericaPerson()); return set;&#125; 使用@ElementsIntoSet 并且返回Set对象 Map注入Map注入与Set注入的区别是Map注入需要Key，如： 123456789101112131415161718192021222324252627@Provides@IntoMap@StringKey(\"china\")Person getChinaPerson()&#123; return new ChinaPerson();&#125;@Provides@IntoMap@StringKey(\"America\")Person getAmericaPerson()&#123; return new AmericaPerson();&#125;MainActivity 中：@InjectMap&lt;String,Person&gt; personMap;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (Map.Entry&lt;String,Person&gt; person: personMap.entrySet()) &#123; Toast.makeText(MainActivity.this, \"\"+person.getKey()+\" \"+person.getValue().speak(), Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); dagger还提供了一些内置的key类型，包裹classKey,IntKey等，android辅助包中也提供了ActivityKey等。 我们看看StringKey的源码,是被MapKey修饰的，下面我们来聊聊Mapkey。 1234567@Documented@Target(METHOD)@Retention(RUNTIME)@MapKeypublic @interface StringKey &#123; String value();&#125; @MapKeyMapKey支持的类型有：基本数据类型StringClass枚举类型注解类型以上数据类型的数组Enum如： 12345678910111213141516171819202122232425262728enum MyEnum &#123; ABC, DEF;&#125;@MapKey@interface MyEnumKey &#123; MyEnum value();&#125;@MapKey@interface MyNumberClassKey &#123; Class&lt;? extends Number&gt; value();&#125;@Moduleclass MyModule &#123; @Provides @IntoMap @MyEnumKey(MyEnum.ABC) static String provideABCValue() &#123; return \"value for ABC\"; &#125; @Provides @IntoMap @MyNumberClassKey(BigDecimal.class) static String provideBigDecimalValue() &#123; return \"value for BigDecimal\"; &#125;&#125; 复合Key，如： 123456789101112131415161718192021@MapKey(unwrapValue = false)@Retention(value=RUNTIME)public @interface GameInfo &#123; String name(); float price();&#125;@Modulepublic class GameModule &#123; @Provides @IntoMap @GameInfo(name = \"game\",price = 100f) public String getGameInfo()&#123; return \"gameinfo\"; &#125;&#125;MainActivity 中：@InjectMap&lt;GameInfo,String&gt; mGameInfoStringMap; 如上如果编译失败，要加入如下依赖：implementation ‘com.google.auto.value:auto-value:1.5.1’provided ‘javax.annotation:jsr250-api:1.0’ Lazy 和 ProviderDagger2还支持Lazy模式，通过Lazy或者Provider模拟提供的实例，在@Inject的时候并不初始化，而是等到你要使用的时候，主动调用其.get方法来获取实例。 如： 123456789101112@InjectLazy&lt;PersonManager&gt; personManager;@InjectProvider&lt;PersonManager&gt; personManager;tvTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"\"+personManager.get().speak(), Toast.LENGTH_SHORT).show(); &#125; &#125;); Lazy和Provider的区别在于： Lazy每次get都是同一实例Provider每次get都是新实例 名词解释： JSR-330JSR即Java Specification Requests，意思是java规范提要。而JSR-330则是 Java依赖注入标准 本文参考文章： Dagger2 最清晰的使用教程 Dagger2 使用（二）","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://www.zydeveloper.com/tags/Dagger2/"}]},{"title":"Android 进程保活（四）使用“前台服务”保活","slug":"processlive4","date":"2019-07-15T16:00:00.000Z","updated":"2019-07-16T01:55:49.528Z","comments":true,"path":"2019/07/16/processlive4/","link":"","permalink":"http://www.zydeveloper.com/2019/07/16/processlive4/","excerpt":"前台服务方式保活实际是利用了Android前台服务的一个漏洞。即：android api 在18之前的版本我们调用startForeground来提高应用程序的oom_adj值，在18版本后我们需要使用Service中启动一个InnerService两个服务同时startForeground并且绑定相同的ID，然后stop掉InnerService,这样做是将通知栏上的图标移除。 关于oom_adj可参考： Android 进程保活（一）写在前面","text":"前台服务方式保活实际是利用了Android前台服务的一个漏洞。即：android api 在18之前的版本我们调用startForeground来提高应用程序的oom_adj值，在18版本后我们需要使用Service中启动一个InnerService两个服务同时startForeground并且绑定相同的ID，然后stop掉InnerService,这样做是将通知栏上的图标移除。 关于oom_adj可参考： Android 进程保活（一）写在前面 用Demo来演示一下 首先创建一个Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.baweigame.mvvmdemoapplication;import android.app.Notification;import android.app.NotificationManager;import android.app.Service;import android.content.Intent;import android.os.Build;import android.os.Handler;import android.os.IBinder;import android.support.annotation.RequiresApi;public class MyService extends Service &#123; public static final int NOTIFICATION_ID=0x11; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException(\"Not yet implemented\"); &#125; @Override public void onCreate() &#123; super.onCreate(); //API Version 18以下 if (Build.VERSION.SDK_INT &lt;Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; startForeground(NOTIFICATION_ID, new Notification()); &#125; else &#123; //API Version 18以上 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); startService(new Intent(this, InnerService.class)); &#125; &#125; public static class InnerService extends Service&#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN) @Override public void onCreate() &#123; super.onCreate(); //发送与上面服务中ID相同的Notification，然后将其取消并取消自己的前台显示 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; stopForeground(true); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(NOTIFICATION_ID); stopSelf(); &#125; &#125;,100); &#125; &#125;&#125; 在没有使用这个服务前我们看看oom_adj的值变化，首先直接启动App，我们看一下oom_adj的值，如：我这里面进行了2次操作，分别为打开App 点击了Home键我们发现打开App时我们的oom_adj值为0点击Home键后我们的oom_adj的值为6 下面我们开启上面的服务在来验证一下oom_adj值的变化。 1startService(new Intent(this,MyService.class)); 我们发现刚打开App时我们的oom_adj值是0，点击Home键后我们的oom_adj的值为1 即使用这种方式确实提高了我们App的优先级提高了存活概率。 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（五）JobSheduler进程重生","slug":"processlive5","date":"2019-07-15T16:00:00.000Z","updated":"2019-07-16T08:21:45.779Z","comments":true,"path":"2019/07/16/processlive5/","link":"","permalink":"http://www.zydeveloper.com/2019/07/16/processlive5/","excerpt":"JobSheduler在android 5.0以上版本可用，所以该方案适合5.0以上的系统版本。关于JobService与JobSheduler不清楚的可参考官网API文档： 官网JobService 官网JobScheduler JobScheduler是用于计划基于应用进程的多种类型任务的api接口。当任务执行时，系统会为应用持有WakeLock，所以应用不需要做多余的确保设备唤醒的工作。 JobService继承自Service，是用于处理JobScheduler中规划的异步请求的特殊Service","text":"JobSheduler在android 5.0以上版本可用，所以该方案适合5.0以上的系统版本。关于JobService与JobSheduler不清楚的可参考官网API文档： 官网JobService 官网JobScheduler JobScheduler是用于计划基于应用进程的多种类型任务的api接口。当任务执行时，系统会为应用持有WakeLock，所以应用不需要做多余的确保设备唤醒的工作。 JobService继承自Service，是用于处理JobScheduler中规划的异步请求的特殊Service 使用JobService必须先在AndroidManifest.xml中声明service和权限 1&lt;service android:name=\"MyJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"/ &gt; 我们来实现一个JobService，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.baweigame.mvvmdemoapplication;import android.app.job.JobInfo;import android.app.job.JobParameters;import android.app.job.JobScheduler;import android.app.job.JobService;import android.content.ComponentName;import android.content.Context;import android.os.Build;import android.support.annotation.RequiresApi;import android.util.Log;@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)public class MyJobService extends JobService &#123; @Override public void onCreate() &#123; super.onCreate(); startJob(); &#125; /** * 开启工作 */ private void startJob() &#123; JobInfo.Builder builder = new JobInfo.Builder(1001, new ComponentName(getPackageName(), MyJobService.class.getName())); //500毫秒调用一次 builder.setPeriodic(500); builder.setPersisted(true); JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE); jobScheduler.schedule(builder.build()); &#125; @Override public boolean onStartJob(JobParameters params) &#123; Log.d(\"123\", \"onStartJob: ...\"); return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; Log.d(\"123\", \"onStopJob: ...\"); return false; &#125;&#125; 在Activity启动服务，如: 1startService(new Intent(this,MyJobService.class)); 我们添加了一个JobService并在服务启动及停止时加入了日志输出。使用JobScheduler来调度服务，每500毫秒调用一次。我们启动App来观察服务启动log的打印情况，启动后每500毫秒打印一次。我们手动关闭所有进程，发现服务停止后有复活了，正常输出了log信息。 注意：清单文件中加入相关权限。如： 1&lt;service android:name=\".MyJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"&gt;&lt;/service&gt; Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 热修复","slug":"hotupdate","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-15T10:19:21.663Z","comments":true,"path":"2019/07/15/hotupdate/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/hotupdate/","excerpt":"","text":"类如何加载？java中我们一般使用ClassLoader进行类的加载。android 中 我们都知道最后的代码文件都会被打包成dex格式的文件；class文件包含在dex文件中。加载dex中class文件我们需要使用DexClassLoader或者PathClassLoader。 类加载器PathClassLoader可以加载Android系统中的dex文件DexClassLoader可以加载任意目录的dex/zip/apk/jar文件 , 但是要指定optimizedDirectory.这两个类加载器都继承BaseDexClassLoader, 并且在构造函数中, DexClassLoader多传入了一个optimizedDirectory。 我们来看看 BaseDexClassLoader 1234567public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)&#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125;&#125; 构造方法中初始化了pathList, 传入三个参数 , 分别为dexPath：目标文件路径（一般是dex文件，也可以是jar/apk/zip文件）所在目录。热修复时用来指定新的dexoptimizedDirectory：dex文件的输出目录（因为在加载jar/apk/zip等压缩格式的程序文件时会解压出其中的dex文件，该目录就是专门用于存放这些被解压出来的dex文件的）。libraryPath：加载程序文件时需要用到的库路径。parent：父加载器 类的加载过程如下方法用于加载dex中的class文件， 拿到初始化完成的 pathList 之后 , 根据类名找出相应的class字节码文件, 如果没有异常直接返回class. 1234567891011121314@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); //从pathList中找到相应类名的class文件 Class c = pathList.findClass(name, suppressedExceptions); //判空, 抛出异常 if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c;&#125; DexPathList构造函数. 我们在BaseDexClassLoader中实例化DexPathList需要用到findClass方法, 在BaseDexClassLoader的findClass中, 本质调用了DexpathList的fndClass方法 1234567891011121314151617public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) &#123; this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); // save dexPath for BaseDexClassLoader this.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); this.nativeLibraryDirectories = splitPaths(libraryPath, false); this.systemNativeLibraryDirectories = splitPaths(System.getProperty(\"java.library.path\"), true); List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories); allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories); this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, null, suppressedExceptions); &#125; 将传入的classLoader保存起来 , 接下来使用makePathElements方法 ,来初始化Element数组 1234567891011121314151617181920212223242526private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123; // 1.创建Element集合 ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); // 2.遍历所有dex文件（也可能是jar、apk或zip文件） for (File file : files) &#123; ZipFile zip = null; DexFile dex = null; String name = file.getName(); ... // 如果是dex文件 if (name.endsWith(DEX_SUFFIX)) &#123; dex = loadDexFile(file, optimizedDirectory); // 如果是apk、jar、zip文件（这部分在不同的Android版本中，处理方式有细微差别） &#125; else &#123; zip = file; dex = loadDexFile(file, optimizedDirectory); &#125; ... // 3.将dex文件或压缩文件包装成Element对象，并添加到Element集合中 if ((zip != null) || (dex != null)) &#123; elements.add(new Element(file, false, zip, dex)); &#125; &#125; // 4.将Element集合转成Element数组返回 return elements.toArray(new Element[elements.size()]);&#125; DexPathList的构造函数是将一个个的目标（可能是dex、apk、jar、zip , 这些类型在一开始时就定义好了）封装成一个个Element对象，最后添加到Element集合中。 Android的类加载器（不管是PathClassLoader，还是DexClassLoader），它们最后只认dex文件，而loadDexFile()是加载dex文件的核心方法，可以从jar、apk、zip中提取出dex findClass 方法123456789101112131415public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null;&#125; 在DexPathList的构造函数中已经初始化了dexElements，所以这个方法就很好理解了，只是对Element数组进行遍历，一旦找到类名与name相同的类时，就直接返回这个class，找不到则返回null。 热修复的实现方法加载class会使用BaseDexClassLoader，在加载时，会遍历文件下的element，并从element中获取dex文件 class文件在dex里面 , 找到dex的方法是遍历数组 , 那么热修复的原理, 就是将改好bug的dex文件放进集合的头部, 这样遍历时会首先遍历修复好的dex并找到修复好的类。 一个Demo演示热修复的应用（代码修复）建立TestClass 类文件内容如下： 123456package com.baweigame.hotupdateapplication;public class TestClass &#123; public int Debug()&#123; return 10/0; &#125;&#125; 除0会报异常。这个类即我们需要热更新修复的类。 在MainActivity中调用如下：即点击 按钮 将发生错误。 下面是热修复核心工具类：FixDexUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.baweigame.hotupdateapplication;import android.content.Context;import android.os.Environment;import android.support.annotation.NonNull;import android.widget.Toast;import java.io.File;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.util.HashSet;import dalvik.system.DexClassLoader;import dalvik.system.PathClassLoader;public class FixDexUtil &#123; private static final String DEX_SUFFIX = \".dex\"; private static final String APK_SUFFIX = \".apk\"; private static final String JAR_SUFFIX = \".jar\"; private static final String ZIP_SUFFIX = \".zip\"; public static final String DEX_DIR = \"odex\"; private static final String OPTIMIZE_DEX_DIR = \"optimize_dex\"; private static HashSet&lt;File&gt; loadedDex = new HashSet&lt;&gt;(); static &#123; loadedDex.clear(); &#125; /** * 加载补丁，使用默认目录：data/data/包名/files/odex * * @param context */ public static void loadFixedDex(Context context) &#123; loadFixedDex(context, null); &#125; /** * 加载补丁 * * @param context 上下文 * @param patchFilesDir 补丁所在目录 */ public static void loadFixedDex(Context context, File patchFilesDir) &#123; // dex合并之前的dex doDexInject(context, loadedDex); &#125; /** * 验证是否需要热修复 */ public static boolean isGoingToFix(@NonNull Context context) &#123; boolean canFix = false; File externalStorageDirectory = null;//Environment.getExternalStorageDirectory(); // 遍历所有的修复dex , 因为可能是多个dex修复包 File fileDir = externalStorageDirectory != null ? externalStorageDirectory : new File(context.getFilesDir(), DEX_DIR);// data/data/包名/files/odex（这个可以任意位置） File[] listFiles = fileDir.listFiles(); if (listFiles==null)&#123; return false; &#125; for (File file : listFiles) &#123; if (file.getName().startsWith(\"classes\") &amp;&amp; (file.getName().endsWith(DEX_SUFFIX) || file.getName().endsWith(APK_SUFFIX) || file.getName().endsWith(JAR_SUFFIX) || file.getName().endsWith(ZIP_SUFFIX))) &#123; loadedDex.add(file);// 存入集合 //有目标dex文件, 需要修复 canFix = true; &#125; &#125; return canFix; &#125; private static void doDexInject(Context appContext, HashSet&lt;File&gt; loadedDex) &#123; String optimizeDir = appContext.getFilesDir().getAbsolutePath() + File.separator + OPTIMIZE_DEX_DIR; // data/data/包名/files/optimize_dex（这个必须是自己程序下的目录） File fopt = new File(optimizeDir); if (!fopt.exists()) &#123; fopt.mkdirs(); &#125; try &#123; // 1.加载应用程序dex的Loader PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader(); for (File dex : loadedDex) &#123; // 2.加载指定的修复的dex文件的Loader DexClassLoader dexLoader = new DexClassLoader( dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录 fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁） null,// 加载dex时需要的库 pathLoader// 父类加载器 ); // 3.开始合并 // 合并的目标是Element[],重新赋值它的值即可 /** * BaseDexClassLoader中有 变量: DexPathList pathList * DexPathList中有 变量 Element[] dexElements * 依次反射即可 */ //3.1 准备好pathList的引用 Object dexPathList = getPathList(dexLoader); Object pathPathList = getPathList(pathLoader); //3.2 从pathList中反射出element集合 Object leftDexElements = getDexElements(dexPathList); Object rightDexElements = getDexElements(pathPathList); //3.3 合并两个dex数组 Object dexElements = combineArray(leftDexElements, rightDexElements); // 重写给PathList里面的Element[] dexElements;赋值 Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错 setField(pathList, pathList.getClass(), \"dexElements\", dexElements); &#125; Toast.makeText(appContext, \"修复完成\", Toast.LENGTH_SHORT).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 反射给对象中的属性重新赋值 */ private static void setField(Object obj, Class&lt;?&gt; cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException &#123; Field declaredField = cl.getDeclaredField(field); declaredField.setAccessible(true); declaredField.set(obj, value); &#125; /** * 反射得到对象中的属性值 */ private static Object getField(Object obj, Class&lt;?&gt; cl, String field) throws NoSuchFieldException, IllegalAccessException &#123; Field localField = cl.getDeclaredField(field); localField.setAccessible(true); return localField.get(obj); &#125; /** * 反射得到类加载器中的pathList对象 */ private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; return getField(baseDexClassLoader, Class.forName(\"dalvik.system.BaseDexClassLoader\"), \"pathList\"); &#125; /** * 反射得到pathList中的dexElements */ private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException &#123; return getField(pathList, pathList.getClass(), \"dexElements\"); &#125; /** * 数组合并 */ private static Object combineArray(Object arrayLhs, Object arrayRhs) &#123; Class&lt;?&gt; clazz = arrayLhs.getClass().getComponentType(); int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组） int j = Array.getLength(arrayRhs);// 得到原dex数组长度 int k = i + j;// 得到总数组长度（补丁数组+原dex数组） Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组 System.arraycopy(arrayLhs, 0, result, 0, i); System.arraycopy(arrayRhs, 0, result, i, j); return result; &#125;&#125; 在MainActivity中调用，如： 123if (FixDexUtil.isGoingToFix(mContext)) &#123; FixDexUtil.loadFixedDex(mContext, Environment.getExternalStorageDirectory());&#125; 生成dex文件用于新版本修复旧版本bug： 修改TestClass,如下： 123456package com.baweigame.hotupdateapplication;public class TestClass &#123; public int Debug()&#123; return 10/2; &#125;&#125; rebuild project 找到class文件，如下：将TestClass.class 文件拷贝出来，注意：拷贝的存放路径要与工程包名目录一致，如：找到dx.bat 并将目录配置到环境变量中。 dx.bat目录 如： C:\\Users\\zhangyue\\AppData\\Local\\Android\\Sdk\\build-tools\\28.0.3 编译dex包命令 dx –dex –output c:\\Users\\zhangyue\\Desktop\\classes.dex C:\\Users\\zhangyue\\Desktop\\dex 生成的classes.dex 即升级修复的新版本dex文件。 将dex文件push到 /data/data/包名/files/odex 目录下，运行程序查看修复结果。 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 双亲委派机制 BootStrapClassLoader：启动类加载器，该ClassLoader是jvm在启动时创建的，用于加载 $JAVA_HOME/jre/lib下面的类库（或者通过参数-Xbootclasspath指定）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不能直接通过引用进行操作。 ExtClassLoader：扩展类加载器，该ClassLoader是在sun.misc.Launcher里作为一个内部类ExtClassLoader定义的（即 sun.misc.Launcher$ExtClassLoader），ExtClassLoader会加载 $JAVA_HOME/jre/lib/ext下的类库（或者通过参数-Djava.ext.dirs指定）。 AppClassLoader：应用程序类加载器，该ClassLoader同样是在sun.misc.Launcher里作为一个内部类AppClassLoader定义的（即 sun.misc.Launcher$AppClassLoader），AppClassLoader会加载java环境变量CLASSPATH所指定的路径下的类库，而CLASSPATH所指定的路径可以通过System.getProperty(“java.class.path”)获取；当然，该变量也可以覆盖，可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的class目录）。 CustomClassLoader：自定义类加载器，该ClassLoader是指我们自定义的ClassLoader，比如tomcat的StandardClassLoader属于这一类；当然，大部分情况下使用AppClassLoader就足够了。 ClassLoader的双亲委派机制是这样的（这里先忽略掉自定义类加载器CustomClassLoader： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。","categories":[{"name":"Android插件化","slug":"Android插件化","permalink":"http://www.zydeveloper.com/categories/Android插件化/"}],"tags":[{"name":"插件化","slug":"插件化","permalink":"http://www.zydeveloper.com/tags/插件化/"},{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"热修复","slug":"热修复","permalink":"http://www.zydeveloper.com/tags/热修复/"}]},{"title":"Android 进程保活（三）1像素方案保活","slug":"processlive3","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-16T01:55:40.136Z","comments":true,"path":"2019/07/15/processlive3/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive3/","excerpt":"1像素保活方案坊间流传是手机QQ的保活的方案。什么意思呢？就是我们在手机锁屏时开启一个Activity，为了不让用户有感知，让这个Activity大小为1像素并设置透明无切换动画。在开启屏幕时把这个Activity关掉。","text":"1像素保活方案坊间流传是手机QQ的保活的方案。什么意思呢？就是我们在手机锁屏时开启一个Activity，为了不让用户有感知，让这个Activity大小为1像素并设置透明无切换动画。在开启屏幕时把这个Activity关掉。 一个Demo来演示一下创建一个Android工程，默认为我们生成一个MainActivity，这是我们程序的入口Activity。我们通过观察oom_adj值来看一下优先级。首先启动App，我们看oom_adj的值我们看oom_adj的值为0，所以当前优先级很高不会被系统杀死。我们点击home键或者back键来观察一下oom_adj。我们发现oom_adj的值已经变为了6，所以退到后台的app在资源紧张的情况下就有可能被杀死了。 关于oom_adj可参考: Android 进程保活（一）写在前面 从而我们可通过提高oom_adj的值可以使我们的app被系统杀死的概率变低。 我们使用的1像素保活方案就是应用了这点。 创建一个1像素的Activity，如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.baweigame.mvvmdemoapplication;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Gravity;import android.view.Window;import android.view.WindowManager;public class OnePXActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_one_px); Log.d(\"123\", \"onCreate: OnePxActivity...\"); createOnePxWindow(); OnePxManager.getInstance().setActivity(this); &#125; /** * 创建1像素窗体 */ private void createOnePxWindow() &#123; Window window = getWindow(); //放在左上角 window.setGravity(Gravity.START | Gravity.TOP); WindowManager.LayoutParams attributes = window.getAttributes(); //宽高为1个像素 attributes.width = 1; attributes.height = 1; attributes.x = 0; attributes.y = 0; window.setAttributes(attributes); &#125;&#125; 同时为了更好的隐藏，可以给这个1像素Activity设置样式如： 123456&lt;style name=\"OnePxStyle\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@null&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;/style&gt; 即设置了背景透明及没有切换效果，这样可以更好的隐藏自己。 123&lt;activity android:name=\".OnePXActivity\" android:theme=\"@style/OnePxStyle\"&gt; &lt;/activity&gt; 创建一个管理类来控制Activity的开启与关闭，如下： 123456789101112131415161718192021222324252627282930313233343536package com.baweigame.mvvmdemoapplication;import android.app.Activity;import android.content.Context;import android.content.Intent;import java.lang.ref.WeakReference;public class OnePxManager &#123; private static OnePxManager instance=new OnePxManager(); public static OnePxManager getInstance()&#123; return instance; &#125; private OnePxManager()&#123;&#125; private WeakReference&lt;Activity&gt; weakReference; public void setActivity(Activity activity)&#123; weakReference=new WeakReference&lt;Activity&gt;(activity); &#125; public void startActivity(Context context)&#123; Intent intent = new Intent(context, OnePXActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; public void finishActivity()&#123; if (weakReference!=null)&#123; if (weakReference.get()!=null)&#123; weakReference.get().finish(); &#125; &#125; &#125;&#125; 我们开启与关闭Activity的时机设计为屏幕锁屏时开启，屏幕解锁时关闭。所以编写如下广播： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.mvvmdemoapplication;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class OnePxReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //开屏 if (intent.getAction().equals(Intent.ACTION_SCREEN_ON))&#123; Log.d(\"123\", \"onReceive: user screen_on\"); closeActivity(); &#125; //锁屏 else if(intent.getAction().equals(Intent.ACTION_SCREEN_OFF))&#123; Log.d(\"123\", \"onReceive: user screen_off\"); openActivity(context); &#125; &#125; /** * 开启1像素Activity * @param context */ private void openActivity(Context context) &#123; OnePxManager.getInstance().startActivity(context); &#125; /** * 关闭Activity */ private void closeActivity() &#123; OnePxManager.getInstance().finishActivity(); &#125;&#125; 由于SCREEN_ON与SCREEN_OFF这两个广播不能使用静态方式注册，所以我们在MainActivity中动态注册广播。 1234567891011121314151617181920212223242526272829package com.baweigame.mvvmdemoapplication;import android.content.Intent;import android.content.IntentFilter;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); registerOnePxReceiver(this); &#125; /** * 注册1像素广播 * @param mainActivity */ private void registerOnePxReceiver(MainActivity mainActivity) &#123; IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(Intent.ACTION_SCREEN_ON); intentFilter.addAction(Intent.ACTION_SCREEN_OFF); registerReceiver(new OnePxReceiver(),intentFilter); &#125;&#125; 我们来运行一下看看效果。 为了让我们的这种方法更加可靠，可以将广播注册过程放到服务中去，并将服务运行在另一个进程如： 12&lt;service android:name=\".OnePxService\" android:process=\":onepx_service\"/&gt; 同时提高存活概率可以使用双进程守护方案来进一步加强，可参考： Android 进程保活（二）双服务进程包活 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（二）双服务进程包活","slug":"processlive2","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-16T01:55:28.762Z","comments":true,"path":"2019/07/15/processlive2/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive2/","excerpt":"1、双进程守护保活方案","text":"1、双进程守护保活方案 创建aidl接口文件用于进程间通信，如下：方法自定义。 创建本地服务及远程服务 LocalService RemoteService 清单配置如下： 本地服务代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.baweigame.processliveapplication;import android.app.Notification;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.RemoteException;import android.util.Log;/*** 本地服务*/public class LocalService extends Service &#123; private IMyAidlInterface remoteService; private MyBinder myBinder; public LocalService() &#123; &#125; ServiceConnection serviceConnection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder binder) &#123; Log.d(\"zzzz\", \"onServiceConnected: localservice is connected...\"); try &#123;// remoteService = (IMyAidlInterface) binder;// remoteService.getData(\"localservice\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(\"zzzz\", \"onServiceDisconnected: localservice is disconnected...\"); startService(new Intent(LocalService.this,RemoteService.class)); bindService(new Intent(LocalService.this,RemoteService.class),serviceConnection, Context.BIND_IMPORTANT); &#125; &#125;; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(\"zzzz\", \"onStartCommand: localservice is onstartcommand...\"); startForeground(1,new Notification()); bindService(new Intent(this,RemoteService.class),serviceConnection, Context.BIND_IMPORTANT); startDo(); return START_STICKY; &#125; private void startDo() &#123; handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; handler.sendEmptyMessage(0); handler.postDelayed(this,2*1000); &#125; &#125;,2*1000); &#125; private Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.d(\"zzzz\", \"handleMessage: ****************************************\"); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; myBinder = new MyBinder(); return myBinder; &#125; private class MyBinder extends IMyAidlInterface.Stub&#123; @Override public String getData(String name) throws RemoteException &#123; return LocalService.class.getSimpleName(); &#125; &#125;&#125; 远程服务代码文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.baweigame.processliveapplication;import android.app.Notification;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;/*** 远程服务*/public class RemoteService extends Service &#123; private MyBinder myBinder; public RemoteService() &#123; &#125; ServiceConnection serviceConnection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(\"zzzz\", \"onServiceConnected: remoteservice is connected...\");// try &#123;// IMyAidlInterface localService= (IMyAidlInterface) service;// localService.getData(RemoteService.class.getSimpleName());// &#125; catch (RemoteException e) &#123;// e.printStackTrace();// &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(\"zzzz\", \"onServiceDisconnected: remoteservice is disconnected...\"); startService(new Intent(RemoteService.this,LocalService.class)); bindService(new Intent(RemoteService.this,LocalService.class),serviceConnection,Context.BIND_IMPORTANT); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; myBinder = new MyBinder(); return myBinder; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(\"zzzz\", \"onStartCommand: remoteservice is onstartcommand...\"); startForeground(1,new Notification()); bindService(new Intent(this,LocalService.class),serviceConnection, Context.BIND_IMPORTANT); return START_STICKY; &#125; private class MyBinder extends IMyAidlInterface.Stub&#123; @Override public String getData(String name) throws RemoteException &#123; return RemoteService.class.getSimpleName(); &#125; &#125;&#125; MainActivity中启动服务使用静态注册广播接收系统重启或者屏幕解锁等系统广播来启动本地服务增加存活概率清单文件：广播文件：使用电源锁保证息屏后服务不被杀清单文件中加入权限： Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"Android 进程保活（一）写在前面","slug":"processlive1","date":"2019-07-14T16:00:00.000Z","updated":"2019-07-19T06:14:24.353Z","comments":true,"path":"2019/07/15/processlive1/","link":"","permalink":"http://www.zydeveloper.com/2019/07/15/processlive1/","excerpt":"进程保活对于作为Android开发的程序猿应该并不陌生，一些App对于进程保活有着很强烈的需求。比如一个IM类App对于信息接收就需要app进程一直存活才可以，否则对方好友发送了信息，如果app已经被干掉从而导致无法收到信息，这样的用户体验是很差的。用户很可能会直接卸载掉你的app，因为这样的app对于用户来说没什么使用价值。","text":"进程保活对于作为Android开发的程序猿应该并不陌生，一些App对于进程保活有着很强烈的需求。比如一个IM类App对于信息接收就需要app进程一直存活才可以，否则对方好友发送了信息，如果app已经被干掉从而导致无法收到信息，这样的用户体验是很差的。用户很可能会直接卸载掉你的app，因为这样的app对于用户来说没什么使用价值。 我们都知道Android的App一般最少存在一个进程，或者多个进程。目前的主流App一般都会使用多进程的方案。多进程起到的作用可以增加进程存活的概率或者隔离危险代码（容易产生Crash）或者可以用来突破方法数65535的限制。 进程划分？Android中的进程通常被划分了5级，我们按重要程度由高到低排列一下： 1、Foreground process——前台进程某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。 2、Visible process——可见进程拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。拥有绑定到可见（或前台）Activity 的 Service 3、Service process——服务进程某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。 4、Background process——后台进程在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onPause方法 5、Empty process——空进程某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处。 什么是内存阀值？我们知道Android的App退到后台时，系统并不会直接结束掉该app。而是将其缓存起来，当打开的app越来越多后导致内存不足，那么系统就开始结束不重要的进程从而释放其内存提供给优先级高的应用使用。这套杀进程释放内存的机制，Android中被叫做Low Memory Killer。那么这个内存不足怎么来规定呢，我们知道不足一定有一个限定值，这个值就是内存阀值。使用cat /sys/module/lowmemorykiller/parameters/minfree可以查看手机的内存阀值。 内存不足时进程进行回收是按上面的重要程度有低到高进行回收。 进程是有优先级的，adj来表示我们的优先级。oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，我们可以通过cat /proc/进程id/oom_adj可以看到当前进程的adj值。我们发现 设置 的进程优先级现在是10，我们现在没有启动 设置。下面我们来打开设置app并查看一下现在的优先级。我们看当前 设置 的进程优先级已经变为了0。优先级有了提高。oom_adj主要由一下几种，注意每个手机厂商可能不一样。 从上面我们发现在系统内存紧张的情况下会优先杀时oom_adj值比较大的应用，反过来说我们将oom_adj的值变小也可以减少系统杀死我们应用的概率。 Android 进程保活系列：Android 进程保活（一）写在前面Android 进程保活（二）双服务进程包活Adnroid 进程保活（三）1像素方案保活Android 进程保活（四）使用“前台服务”保活Android 进程保活（五）JobSheduler进程重生","categories":[{"name":"Android进程保活","slug":"Android进程保活","permalink":"http://www.zydeveloper.com/categories/Android进程保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.zydeveloper.com/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"http://www.zydeveloper.com/tags/进程保活/"}]},{"title":"OKHttp使用","slug":"OKHttp","date":"2019-07-12T16:00:00.000Z","updated":"2019-07-15T06:01:16.028Z","comments":true,"path":"2019/07/13/OKHttp/","link":"","permalink":"http://www.zydeveloper.com/2019/07/13/OKHttp/","excerpt":"","text":"","categories":[{"name":"Android第三方框架","slug":"Android第三方框架","permalink":"http://www.zydeveloper.com/categories/Android第三方框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.zydeveloper.com/tags/框架/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://www.zydeveloper.com/tags/OKHttp/"}]},{"title":"MVP架构","slug":"MVP","date":"2019-07-09T16:00:00.000Z","updated":"2019-07-10T06:56:46.855Z","comments":true,"path":"2019/07/10/MVP/","link":"","permalink":"http://www.zydeveloper.com/2019/07/10/MVP/","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"MVP","slug":"MVP","permalink":"http://www.zydeveloper.com/tags/MVP/"}]},{"title":"Jetpack系列之ViewModel","slug":"jetpack-viewmodel","date":"2019-07-08T16:00:00.000Z","updated":"2019-07-11T06:44:41.640Z","comments":true,"path":"2019/07/09/jetpack-viewmodel/","link":"","permalink":"http://www.zydeveloper.com/2019/07/09/jetpack-viewmodel/","excerpt":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。","text":"ViewModel类旨在以生命周期的方式存储和管理ui相关的数据。ViewModel类允许数据在配置更改(如屏幕旋转)之后继续存活下来。 聊聊ViewModel主要作用？1、应用于MVVM模式将UI层与Model业务层分离。2、可以存储数据（如：fragment之间共享数据）3、为UI提供数据 Android Framwork管理UI控件的生命周期，比如Activity和Fragment。Framwork可能决定销毁或重新创建一个UI控件，以响应某些用户操作或设备事件。如果系统销毁或重新创建一个UI控件，您存储在其中的任何与UI相关的临时数据都将丢失。例如，您的应用程序可能在其中一个活动中包含一个用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。对于简单数据,活动可以使用方法在onCreate()中恢复数据,但这种方法只适用于少量的数据可以序列化反序列化,而不是潜在的大量数据的用户列表或位图。另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁这些调用后对其进行清理，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改重新创建对象的情况下，这是对资源的浪费，因为对象可能不得不重新发出它已经发出的调用。活动和片段等UI控件主要用于显示UI数据、响应用户操作或处理操作系统通信(如权限请求)。要求UI控制器也负责从数据库或网络加载数据，会使类膨胀。将过多的责任分配给UI控制器可能导致一个类试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式将过多的责任分配给UI控制器也会使测试变得更加困难。将视图数据所有权从UI控制器逻辑中分离出来更容易也更有效。 体系结构组件为负责UI准备数据的UI控制器提供ViewModel helper类。在配置更改期间自动保留ViewModel对象，以便它们所持有的数据可以立即用于下一个Activity或Fragment实例。例如，如果您需要在应用程序中显示用户列表，请确保将获取和保存用户列表的责任分配给ViewModel，而不是activity或fragment。 ViewModel对象的作用域是在获取ViewModel时传递给ViewModelProvider的生命周期。视图模型一直保存在内存中，直到它的作用域永久消失:对于Activity，当它结束时，而对于Fragment，当它被分离时。下图说明了一个活动在进行旋转并完成时的各种生命周期状态。图中还显示了关联活动生命周期旁边的ViewModel的生命周期。这个图说明了活动的状态。同样的基本状态也适用于片段的生命周期。 参考：https://developer.android.google.cn/topic/libraries/architecture/viewmodel 基本使用首先导依赖：implementation ‘android.arch.lifecycle:extensions:1.1.1’ ViewModel类 12345678910111213141516171819202122232425package com.baweigame.databindingjavademoapplication;import android.arch.lifecycle.MutableLiveData;import android.arch.lifecycle.ViewModel;public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;PersonBean&gt; personLiveData=new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;PersonBean&gt; getPersonLiveData() &#123; return personLiveData; &#125; public void setPersonLiveData(MutableLiveData&lt;PersonBean&gt; personLiveData) &#123; this.personLiveData = personLiveData; &#125; public void loadPersonData()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; personLiveData.postValue(new PersonBean(\"小明\",20,\"北京市海淀区\")); &#125; &#125;).start(); &#125;&#125; Activity中使用 123456ViewModelProviders.of(this).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); 然后，可在Activity中观察数据变化。 Fragment中共享数据 由于ViewModel的生命周期一直在内存中存在知道被销毁，所以可以在Fragment间传递数据，如：有两个Fragment Fragment1： 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125;&#125;); Fragment2: 123456ViewModelProviders.of(getActivity()).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); Activity中更新数据： 1ViewModelProviders.of(this).get(MyViewModel.class).loadPersonData(); 这样就实现了Fragment间的数据共享。 ViewModelProviders 类提供了4个方法 of() 创建新的 ViewModelProvider 对象。 1234ViewModelProviders.of(Fragment)ViewModelProviders.of(FragmentActivity)ViewModelProviders.of(Fragment, Factory)ViewModelProviders.of(FragmentActivity, Factory) 我们发现方法中出现了一个Factory参数 Factory 接口定义创建 ViewModel 的接口 create()。public interface Factory { T create(@NonNull Class modelClass);} Android内置了2个 Factory 实现类，分别是： AndroidViewModelFactory 实现类，可以创建 ViewModel 和 AndroidViewModel 子类对象。NewInstanceFactory 类，只可以创建 ViewModel 子类对象。 假设有种场景我们需要向ViewModel实现子类中传递参数该如何处理呢？ 实现如上需求，如： 原ViewModel实现类中加入有参构造如： 我们可以使用新建Factory之类来进行参数传递，如： 123456789101112131415161718package com.baweigame.databindingjavademoapplication;import android.arch.lifecycle.ViewModel;import android.arch.lifecycle.ViewModelProvider;import android.support.annotation.NonNull;public class MyFactory extends ViewModelProvider.NewInstanceFactory &#123; private String params; public MyFactory(String _params)&#123; params=_params; &#125; @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; return (T) new MyViewModel(params); &#125;&#125; 然后在activity中使用将原有代码修改为如： 123456ViewModelProviders.of(this,new MyFactory(\"我是参数\")).get(MyViewModel.class).getPersonLiveData().observe(this, new Observer&lt;PersonBean&gt;() &#123; @Override public void onChanged(@Nullable PersonBean personBean) &#123; &#125; &#125;); 我们发现在of中加入了我们的自定义工厂子类并传递了参数。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"ViewModel","slug":"ViewModel","permalink":"http://www.zydeveloper.com/tags/ViewModel/"}]},{"title":"Jetpack系列之Lifecycles","slug":"jetpack-lifecycles","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T05:54:41.117Z","comments":true,"path":"2019/07/02/jetpack-lifecycles/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-lifecycles/","excerpt":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.","text":"Lifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain. A common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves. 生命周期感知组件执行操作，以响应另一个组件生命周期状态的更改，例如Activity和Fragment。这些组件可以帮助您生成更有组织、更容易维护的轻量级代码。 一个常见的模式是在Activity和Fragment的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码错误的增加。通过使用生命周期感知组件，您可以将依赖组件的代码从生命周期方法转移到组件本身。 参考链接：https://developer.android.google.cn/topic/libraries/architecture/lifecycle Android中的大多数应用程序组件都具有生命周期,如：Activity/Service/Fragment等。生命周期由操作系统或Framwork管理。它们是Android工作原理的核心，应用程序必须遵守它们。不这样做可能会引发内存泄漏，甚至应用程序崩溃。 可能我们之前的使用方法，如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 上面代码来源于https://developer.android.google.cn/topic/libraries/architecture/lifecycle 尽管这个示例看起来很好，但是在实际应用程序中，最终会有太多的调用来管理UI和其他组件，以响应生命周期的当前状态。管理多个组件会在生命周期方法中放置大量的代码，比如onStart()和onStop()，这使得它们很难维护。此外，不能保证组件在活动或片段停止之前启动。如果我们需要执行长时间运行的操作，比如一些配置check in onStart()，这一点尤其重要。这可能会导致一个竞态条件，即onStop()方法在onStart()之前结束，从而使组件存活的时间超过所需的时间。 Lifecycle是一个类，它保存关于组件(如Activity或Fragment)生命周期状态的信息，并允许其他对象观察这个状态。Lifecycle使用两个主要枚举来跟踪其关联组件的生命周期状态: Event从框架和Lifecycle类发出的生命周期事件。这些事件映射到活动和片段中的回调事件。State声明生命周期对象跟踪的组件的当前状态。 上图演示了States与events的对应关系。 先看一下如下两个系统接口： 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 1234public interface LifecycleObserver &#123;&#125; 一个Demo演示： 12345678910111213141516171819202122232425262728293031323334353637package com.baweigame.databindingapplication;import android.arch.lifecycle.Lifecycle;import android.arch.lifecycle.LifecycleObserver;import android.arch.lifecycle.OnLifecycleEvent;import android.util.Log;public class ActivityLifecycleObserver implements LifecycleObserver &#123; private final String TAG=ActivityLifecycleObserver.class.getSimpleName(); private Lifecycle mLifecycle; public ActivityLifecycleObserver(Lifecycle lifecycle) &#123; mLifecycle=lifecycle; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; Log.d(TAG, \"onStart: ...\"); Log.d(TAG, \"onStart: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate()&#123; Log.d(TAG, \"onCreate: ...\"); Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause()&#123; Log.d(TAG, \"onPause: ...\"); Log.d(TAG, \"onPause: lifecycle=\"+mLifecycle.getCurrentState().name()); &#125;&#125; MainActivity的onCreate中将上面的Observer注册为观察者（典型的观察者模式） 1getLifecycle().addObserver(new ActivityLifecycleObserver(getLifecycle())); 我们看到注解 OnLifecycleEvent 即 我们上面提到的Event。再来看一下输出：我们注意到上面的代码中，如： 1Log.d(TAG, \"onCreate: lifecycle=\"+mLifecycle.getCurrentState().name()); 打印了State信息。输出的State信息与我们上图中的State信息对应。 如上就是我们用一个小demo演示了一下lifecycle的使用方法。 可能大家看后还不清楚lifecycle究竟再我们实际工作开发中能帮我们处理什么问题，下面我给大家列举一个使用场景中的实际问题，如：MVP架构这个大家应该都不陌生，Prestener层之前我们的管理代码片段如下： 12345678910111213class MyActivity extends AppCompatActivity &#123; private MyPresenter presenter; public void onCreate(...) &#123; presenter= new MyPresenter (); presenter.create(); &#125; public void onDestroy() &#123; super.onDestroy(); presenter.destory(); &#125;&#125; 相信如上代码段会出现在大家的工程项目中，这样的后果是导致相应生命周期中代码臃肿也不利于维护。使用lifecycle可以解决如上问题，如： 123456789101112public interface IPresenter extends LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy(@NotNull LifecycleOwner owner); @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onLifecycleChanged(@NotNull LifecycleOwner owner, @NotNull Lifecycle.Event event);&#125; 这样让我们的BasePresenter实现这个接口，在我们的Presenter中就可以感知到组件的生命周期，在接口方法中做业务处理即可。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Lifecycles","slug":"Lifecycles","permalink":"http://www.zydeveloper.com/tags/Lifecycles/"}]},{"title":"Jetpack系列之Room","slug":"jetpack-room","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-02T04:08:26.492Z","comments":true,"path":"2019/07/02/jetpack-room/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-room/","excerpt":"","text":"","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Room","slug":"Room","permalink":"http://www.zydeveloper.com/tags/Room/"}]},{"title":"Mvvm架构","slug":"mvvm","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-04T08:14:30.612Z","comments":true,"path":"2019/07/02/mvvm/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/mvvm/","excerpt":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科","text":"MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。 ——百度百科 Mvvm架构与Mvp架构相同的是同样分为三层，并且对应层的职责功能相同： Model层——主要负责提供数据。Model层提供数据如：网络数据及本地数据库中提取的数据，及数据结构如实体bean类。 ViewModel层——同Mvp中P层，主要负责业务逻辑的处理。通过使用官方的Databinding组件进行View层的数据更新等。ViewModel层中不包含任何View层api，使用双向绑定对View层控件进行数据更新，同样不需要View层的引用。 View层——负责界面的显示，View层只管负责UI展示不涉及任何业务逻辑，持有ViewModel层的引用。 Mvvm与Mvp的最大区别在于ViewModel层中不持有View层的引用，这样可以解耦View层，即View层的修改不会影响ViewModel层，同样使代码可测试性增强。也同样给项目团队协作提供可能，这样负责UI开发的人员和负责开发业务功能的人员可以专心关注自己的工作。 Mvvm带来的好处还有减少了很多代码，比如：findViewById 和 操作UI的代码。 举个栗子： 新建工程 一般我们习惯与建立模块后再模块下建立mvvm结构目录。如下图： 实体bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.baweigame.mvvmdemoapplication.student.model;public class StudentBean &#123; private String name; private int age; private String address; public StudentBean(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public StudentBean() &#123; &#125; @Override public String toString() &#123; return \"StudentBean&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; ViewModel类 123456789101112131415161718192021222324252627282930313233package com.baweigame.mvvmdemoapplication.student.viewmodel;import android.databinding.ObservableBoolean;import android.databinding.ObservableField;import android.os.Handler;import android.os.Message;public class StudentViewModel &#123; public final ObservableBoolean isVisible=new ObservableBoolean(false); public final ObservableBoolean isSuccess=new ObservableBoolean(false); public final ObservableBoolean isFalied=new ObservableBoolean(false); public final ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); public void addStudent()&#123; mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; isVisible.set(true); isSuccess.set(true); name.set(\"小红同学\"); &#125; &#125;,3000); &#125; private Handler mHandler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;;&#125; Activity Layout xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;import type=\"android.view.View\"&gt;&lt;/import&gt; &lt;variable name=\"viewmodel\" type=\"com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel\"&gt;&lt;/variable&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;viewmodel.name&#125;\" android:textColor=\"@android:color/holo_orange_dark\" android:textSize=\"20sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"2dp\" android:background=\"@android:color/holo_green_light\" android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\"&gt; &lt;/View&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"添加成功\" android:textColor=\"@android:color/holo_red_light\" android:textSize=\"20sp\" android:visibility=\"@&#123;viewmodel.isSuccess?View.VISIBLE:View.GONE&#125;\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;()-&gt;viewmodel.addStudent()&#125;\" android:text=\"添加学生\" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Activity代码 12345678910111213141516171819202122package com.baweigame.mvvmdemoapplication.student.view;import android.databinding.DataBindingUtil;import android.databinding.ViewDataBinding;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import com.baweigame.mvvmdemoapplication.R;import com.baweigame.mvvmdemoapplication.databinding.ActivityMainBinding;import com.baweigame.mvvmdemoapplication.student.viewmodel.StudentViewModel;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); StudentViewModel studentViewModel = new StudentViewModel(); studentViewModel.name.set(\"小明同学\"); viewDataBinding.setViewmodel(studentViewModel); &#125;&#125; 代码比较简单不再解释。 Databinding可参考Jetpack系列之Databinding 这里还有一个坑，我们的xml中设置了android:visibility属性 使用代码如： 1android:visibility=\"@&#123;viewmodel.isVisible?View.VISIBLE:View.GONE&#125;\" 原因是因为使用了View导致编译时错误，解决方案：也就是导入View。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.zydeveloper.com/tags/架构/"},{"name":"Mvvm","slug":"Mvvm","permalink":"http://www.zydeveloper.com/tags/Mvvm/"}]},{"title":"Jetpack系列之Databinding","slug":"jetpack-databinding","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-03T06:06:46.321Z","comments":true,"path":"2019/07/02/jetpack-databinding/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-databinding/","excerpt":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。","text":"jetpack databinding数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 jetpack官网地址：https://developer.android.google.cn/jetpack/ 什么是Android Jetpack？官方定义如下： Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！ Databinding概念解释参考链接：https://developer.android.google.cn/topic/libraries/data-binding/ 数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。 比较一下Databinding给我们带来的不同之处。 看一段我们之前的代码 12TextView textView = findViewById(R.id.tv_login_username);textView.setText(User.getUserName()); 这段代码很简单，实现的逻辑是找到TextView控件并设置其Text属性值。再来看看Databinding的实现方式。 12&lt;TextView android:text=\"@&#123;User.userName&#125;\" /&gt; 我们发现Databinding方式并没有使用java代码就实现了控件查找并设置Text属性值。带来的好处是其维护起来更简单、方便。还可以提高应用性能，并且有助于防止内存泄漏以及避免空指针异常。 Demo演示Databinding使用过程第一步 开启databinding在工程build.gradle文件中开启databinding，如: 第二步 新建实体bean类\\业务实体类新建实体bean类，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.baweigame.databindingapplication;import android.databinding.ObservableField;public class StudentBean &#123; public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); private int id; private int age; private String address; public StudentBean() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; public ObservableField name=new ObservableField&lt;&gt;();这里有个很有趣的东西如上。——ObservableFields一个类中的单独的字段做观察，如果数据有变动则会收到通知。除了ObservableField，还有ObservableBoolean、ObservableInt… 另一种实现： 12345678910111213141516171819202122232425262728293031323334353637383940public class StudentBean extends BaseObservable&#123; @Bindable private String name; private int id; private int age; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 我们发现了一些差异，首先继承了BaseObservable参考链接：https://developer.android.google.cn/reference/android/databinding/BaseObservable @Bindable 可以加到字段名上 也可以加载 get方法上 效果是一样 set方法上手动调用notifyPropertyChanged通知数据更新，注意：参数要写BR.XX（这是一个坑） 上面两处差异部分我们先记录下来，下面具体Demo演示时我们看具体有什么用处。 新建响应点击事件业务处理类，如： 12345public class ClickListener&#123; public void btnClickListener(View view)&#123; studentBean.setName(\"新名字\"); &#125;&#125; 第三步 新建布局文件新建layout布局并设置绑定关系 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"student\" type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt;&lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(student.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;student.address&#125;\"/&gt; &lt;Button android:text=\"点击\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;clickHandler.btnClickListener&#125;\"/&gt;&lt;/LinearLayout&gt;&lt;/layout&gt; 首先我们看根节点变成了layout 并且下方为data节点 ，data节点中有包含了variable节点，这些节点都什么作用，下面我们一一说明： 最外层用layout标签，databinding固定写法 data标签就是一个让我们数据绑定的标签 variable放置绑定的变量 variable包含type和name属性 type属性 标识变量类型，比如java.lang.String这就是String类型，com.baweigame.databindingapplication.StudentBean 这个就是一个定义的一个StudentBean类型com.baweigame.databindingapplication.MainActivity.ClickListener是我定义用于处理事件的业务类型 name属性 表示的就是我定义的一个变量名称，这个变量名称我们会在下方的布局和对应的java代码中用到 variable还有另一种写法如： 123456789101112&lt;data&gt; &lt;!--&lt;variable--&gt; &lt;!--name=\"student\"--&gt; &lt;!--type=\"com.baweigame.databindingapplication.StudentBean\"&gt;&lt;/variable&gt;--&gt; &lt;import type=\"com.baweigame.databindingapplication.StudentBean\" &lt;variable name=\"student\" type=\"StudentBean\"&gt;&lt;/variable&gt; &lt;variable name=\"clickHandler\" type=\"com.baweigame.databindingapplication.MainActivity.ClickListener\"&gt;&lt;/variable&gt; &lt;/data&gt; 其中@{}就是我们绑定数据的写法。 其中大家应该注意 1@&#123;String.valueOf(Student.age)&#125; 表达式即可以嵌入表达式，可以在表达式语言中使用以下运算符和关键字： 基本运算 + - / * % 字符串连接 + 逻辑表达式 &amp;&amp; || 二进制 &amp; | ^ 一元运算符 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较运算 == &gt; &lt; &gt;= &lt;= instanceof 分组 () 字面值 - 字符，字符串，数字， null 强转 方法调用 属性访问 数组访问 [] 三元运算符 ?: 绑定处理事件 1@&#123;clickHandler.btnClickListener&#125; 事件处理部分：(方法与butterknife处理事件类似) 1234public void btnClickListener(View view)&#123;// studentBean.name.set(\"新名字\"); studentBean.setName(\"新名字\"); &#125; 大家注意到方法中我们修改了studentbean类中name值，这里面为什么修改name值ui上会同步更新就是因为上面我们的两种设置，如：方法一： 1public ObservableField&lt;String&gt; name=new ObservableField&lt;&gt;(); 方法二： 1234public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125; 最后 设置Activity content就是MainActivity中的setContentView处理，我们之前设置内容视图方法都是使用setContentView，在Databinding中我们需要如下设置方法： 12345678 ActivityMainBinding dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);// studentBean.name.set(\"小明\"); studentBean.setName(\"小明\"); studentBean.setAddress(\"北京市朝阳区\"); studentBean.setAge(20); studentBean.setId(1); dataBinding.setStudent(studentBean); dataBinding.setClickHandler(new ClickListener()); ActivityMainBinding即自动生成的绑定类，我们看这个类生成的类名是我们的layout名+Binding组成，即生成规则=layout名+Binding当然你也可以自定义类名，方法如： 1MyStudent dataBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); 如果是Fragment、Listview、Recyclerview 使用则，需要使用inflate()绑定类或者DataBindingUtil类方法： 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);或者ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); 如上即通过一个小Demo演示了DataBinding的具体使用方式。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"Databinding","slug":"Databinding","permalink":"http://www.zydeveloper.com/tags/Databinding/"}]},{"title":"Jetpack系列之LiveData","slug":"jetpack-livedata","date":"2019-07-01T16:00:00.000Z","updated":"2019-07-12T02:42:01.585Z","comments":true,"path":"2019/07/02/jetpack-livedata/","link":"","permalink":"http://www.zydeveloper.com/2019/07/02/jetpack-livedata/","excerpt":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如Activity、Fragment或Service。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于STARTED或RESUMED状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为 DESTROYED时，此关系允许删除观察者。这对于Activity和Fragment尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当Activity和Fragment的生命周期被破坏时，它们会立即取消订阅。","text":"LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用程序组件的生命周期，比如Activity、Fragment或Service。这种意识确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。 LiveData认为，如果一个观察者的生命周期处于STARTED或RESUMED状态，那么这个观察者(由observer类表示)就处于活动状态。LiveData只将更新通知活动观察者。注册为监视LiveData对象的非活动观察者不会收到有关更改的通知。您可以注册一个与实现LifecycleOwner接口的对象配对的观察者。当相应的生命周期对象的状态更改为 DESTROYED时，此关系允许删除观察者。这对于Activity和Fragment尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏，当Activity和Fragment的生命周期被破坏时，它们会立即取消订阅。 LiveData有哪些优点呢? 1、保证UI与数据状态同步 LiveData遵循观察者模式。当生命周期状态发生变化时，LiveData通知观察者对象。可以合并代码来更新这些观察者对象中的UI。观察者可以在每次发生更改时更新UI，而不是每次应用程序数据更改时都更新UI。 2、不会发生内存泄漏 观察者被绑定到生命周期对象，并在其关联的生命周期被销毁后进行清理。 3、停止activity不会造成crash 如果观察者的生命周期是不活动的，例如在后堆栈中的活动，那么它不会接收任何LiveData事件。 4、不需要手动管理生命周期 UI组件只观察相关数据，不停止或恢复观察。LiveData自动管理所有这些，因为它在观察过程中知道相关的生命周期状态变化。 5、总是最新的数据 如果一个生命周期变为不活动的，它将在再次活动时接收最新的数据。例如，在后台的活动在返回到前台后立即接收最新的数据。 6、适当的配置更改 如果某个Activity或Fragment由于配置更改(如设备旋转)而重新创建，它将立即接收最新可用数据。 7、共享数据 可以使用singleton模式扩展LiveData对象来包装系统服务，以便在您的应用程序中共享它们。LiveData对象连接到系统服务一次，然后任何需要该资源的观察者都可以查看LiveData对象 参考：https://developer.android.google.cn/topic/libraries/architecture/livedata LiveData是一个装饰器，可以用于任何数据，包括实现集合的对象，比如List。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问。 一个示例新建ViewModel之类 1234567891011121314package com.baweigame.livedatademoapplication;import android.arch.lifecycle.MediatorLiveData;import android.arch.lifecycle.MutableLiveData;import android.arch.lifecycle.ViewModel;import java.util.List;public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;List&lt;String&gt;&gt; currentList=new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;List&lt;String&gt;&gt; getCurrentList()&#123; return currentList; &#125;&#125; Activity布局文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;TextView android:id=\"@+id/tv_txt\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; &lt;Button android:id=\"@+id/btn_additem\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"增加list item\"/&gt;&lt;/LinearLayout&gt; Activity 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.baweigame.livedatademoapplication;import android.arch.lifecycle.Observer;import android.arch.lifecycle.ViewModelProvider;import android.arch.lifecycle.ViewModelProviders;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private TextView tvTxt; private Button btnAdditem; private MyViewModel myViewModel; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); list = new ArrayList&lt;&gt;(); myViewModel= ViewModelProviders.of(this).get(MyViewModel.class); myViewModel.getCurrentList().observe(this, new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onChanged(@Nullable List&lt;String&gt; strings) &#123; tvTxt.setText(\"当前存在\"+strings.size()+\"条数据\"); &#125; &#125;); &#125; private void initListener() &#123; btnAdditem.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (int i=0;i&lt;3;i++)&#123; list.add(String.valueOf(i)); &#125; myViewModel.getCurrentList().setValue(list); &#125; &#125;); &#125; private void initView() &#123; tvTxt = (TextView) findViewById(R.id.tv_txt); btnAdditem = (Button) findViewById(R.id.btn_additem); &#125;&#125; 代码很简单，主要实现了使用LiveData的子类MutableLiveData 包含了List类型数据，页面上一个Button控件一个Textview控件，点击Button控件通过MutableLiveData的setValue方法更新数据。TextView文本更新list的size。 如上演示了LiveData的基本使用方式。 MutableLiveData 类继承于LiveData 1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 提供2个方法，分别为：postValue与setValuesetValue——只能从main线程调用postValue——可以从非主线程调用 MutableLiveData还有一个子类MediatorLiveData 可观察多个LiveData对象，响应来自所观察LiveData对象的onChanged事件。 我们修改一下上面的示例来演示一下MediatorLiveData我们加入另一个MutableLiveData list2 和 MediatorLiveData mediatorLiveDataactivity代码修改为调用了MediatorLiveData 方法加入了上面的两个MutableLiveData，并在观察者（Observer）中onChanged方法中吐丝了list的size。注意最下面的方法observe，如果不调用该方法进行注册上面的onChanged方法是不会回调的。我们分别设置了两个MutableLiveData的value。运行程序我们发现两个观察者都弹出了吐丝。 在将LiveData对象发送给观察者之前，您可能希望更改存储在LiveData对象中的值，或者您可能需要根据另一个LiveData实例的值返回另一个LiveData实例。 官方给我们提供两种方法： Transformations.map() Demo: 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); Transformations.switchMap() 与map()类似，将函数应用于存储在LiveData对象中的值，并将结果解包并向下分派。传递给switchMap()的函数必须返回LiveData对象 Demo: 123456private LiveData&lt;User&gt; getUser(String id) &#123; ...;&#125;LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/categories/Jetpack/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://www.zydeveloper.com/tags/Jetpack/"},{"name":"LiveData","slug":"LiveData","permalink":"http://www.zydeveloper.com/tags/LiveData/"}]}]}